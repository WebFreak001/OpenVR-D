{
	"typedefs": [
		{
			"doc": "A handle for a spatial anchor.  This handle is only valid during the session it was created in.\nAnchors that live beyond one session should be saved by their string descriptors.",
			"typedef": "vr::SpatialAnchorHandle_t",
			"type": "uint32_t"
		},
		{
			"doc": "Handle to a shared texture (HANDLE on Windows obtained using OpenSharedResource).",
			"typedef": "vr::glSharedTextureHandle_t",
			"type": "void *"
		},
		{
			"typedef": "vr::glInt_t",
			"type": "int32_t"
		},
		{
			"typedef": "vr::glUInt_t",
			"type": "uint32_t"
		},
		{
			"typedef": "vr::SharedTextureHandle_t",
			"type": "uint64_t"
		},
		{
			"typedef": "vr::DriverId_t",
			"type": "uint32_t"
		},
		{
			"doc": "Used to pass device IDs to API calls",
			"typedef": "vr::TrackedDeviceIndex_t",
			"type": "uint32_t"
		},
		{
			"typedef": "vr::WebConsoleHandle_t",
			"type": "uint64_t"
		},
		{
			"doc": "Refers to a single container of properties",
			"typedef": "vr::PropertyContainerHandle_t",
			"type": "uint64_t"
		},
		{
			"typedef": "vr::PropertyTypeTag_t",
			"type": "uint32_t"
		},
		{
			"typedef": "vr::DriverHandle_t",
			"type": "PropertyContainerHandle_t"
		},
		{
			"typedef": "vr::VRActionHandle_t",
			"type": "uint64_t"
		},
		{
			"typedef": "vr::VRActionSetHandle_t",
			"type": "uint64_t"
		},
		{
			"typedef": "vr::VRInputValueHandle_t",
			"type": "uint64_t"
		},
		{
			"typedef": "vr::VREvent_Data_t",
			"type": "union VREvent_Data_t"
		},
		{
			"typedef": "vr::VRComponentProperties",
			"type": "uint32_t"
		},
		{
			"typedef": "vr::VRControllerState_t",
			"type": "struct vr::VRControllerState001_t"
		},
		{
			"doc": "used to refer to a single VR overlay",
			"typedef": "vr::VROverlayHandle_t",
			"type": "uint64_t"
		},
		{
			"doc": "Type used for referring to bones by their index",
			"typedef": "vr::BoneIndex_t",
			"type": "int32_t"
		},
		{
			"typedef": "vr::TrackedCameraHandle_t",
			"type": "uint64_t"
		},
		{
			"typedef": "vr::ScreenshotHandle_t",
			"type": "uint32_t"
		},
		{
			"typedef": "vr::VROverlayIntersectionMaskPrimitive_Data_t",
			"type": "union VROverlayIntersectionMaskPrimitive_Data_t"
		},
		{
			"doc": "Session unique texture identifier. Rendermodels which share the same texture will have the same id.\nIDs <0 denote the texture is not present",
			"typedef": "vr::TextureID_t",
			"type": "int32_t"
		},
		{
			"typedef": "vr::VRNotificationId",
			"type": "uint32_t"
		},
		{
			"typedef": "vr::IOBufferHandle_t",
			"type": "uint64_t"
		},
		{
			"doc": "Handle for vr profiler events",
			"typedef": "vr::VrProfilerEventHandle_t",
			"type": "uint64_t"
		},
		{
			"typedef": "vr::HmdError",
			"type": "enum vr::EVRInitError"
		},
		{
			"typedef": "vr::Hmd_Eye",
			"type": "enum vr::EVREye"
		},
		{
			"typedef": "vr::ColorSpace",
			"type": "enum vr::EColorSpace"
		},
		{
			"typedef": "vr::HmdTrackingResult",
			"type": "enum vr::ETrackingResult"
		},
		{
			"typedef": "vr::TrackedDeviceClass",
			"type": "enum vr::ETrackedDeviceClass"
		},
		{
			"typedef": "vr::TrackingUniverseOrigin",
			"type": "enum vr::ETrackingUniverseOrigin"
		},
		{
			"typedef": "vr::TrackedDeviceProperty",
			"type": "enum vr::ETrackedDeviceProperty"
		},
		{
			"typedef": "vr::TrackedPropertyError",
			"type": "enum vr::ETrackedPropertyError"
		},
		{
			"typedef": "vr::VRSubmitFlags_t",
			"type": "enum vr::EVRSubmitFlags"
		},
		{
			"typedef": "vr::VRState_t",
			"type": "enum vr::EVRState"
		},
		{
			"typedef": "vr::CollisionBoundsStyle_t",
			"type": "enum vr::ECollisionBoundsStyle"
		},
		{
			"typedef": "vr::VROverlayError",
			"type": "enum vr::EVROverlayError"
		},
		{
			"typedef": "vr::VRFirmwareError",
			"type": "enum vr::EVRFirmwareError"
		},
		{
			"typedef": "vr::VRCompositorError",
			"type": "enum vr::EVRCompositorError"
		},
		{
			"typedef": "vr::VRScreenshotsError",
			"type": "enum vr::EVRScreenshotError"
		}
	],
	"enums": [
		{
			"enumname": "vr::EVREye",
			"values": [
				{
					"name": "Eye_Left",
					"value": "0"
				},
				{
					"name": "Eye_Right",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::ETextureType",
			"values": [
				{
					"doc": "Handle has been invalidated",
					"name": "TextureType_Invalid",
					"value": "-1"
				},
				{
					"doc": "Handle is an ID3D11Texture",
					"name": "TextureType_DirectX",
					"value": "0"
				},
				{
					"doc": "Handle is an OpenGL texture name or an OpenGL render buffer name, depending on submit flags",
					"name": "TextureType_OpenGL",
					"value": "1"
				},
				{
					"doc": "Handle is a pointer to a VRVulkanTextureData_t structure",
					"name": "TextureType_Vulkan",
					"value": "2"
				},
				{
					"doc": "Handle is a macOS cross-process-sharable IOSurfaceRef, deprecated in favor of TextureType_Metal on supported platforms",
					"name": "TextureType_IOSurface",
					"value": "3"
				},
				{
					"doc": "Handle is a pointer to a D3D12TextureData_t structure",
					"name": "TextureType_DirectX12",
					"value": "4"
				},
				{
					"doc": "Handle is a HANDLE DXGI share handle, only supported for Overlay render targets.\nthis texture is used directly by our renderer, so only perform atomic (copyresource or resolve) on it",
					"name": "TextureType_DXGISharedHandle",
					"value": "5"
				},
				{
					"doc": "Handle is a MTLTexture conforming to the MTLSharedTexture protocol. Textures submitted to IVRCompositor::Submit which are of type MTLTextureType2DArray assume layer 0 is the left eye texture (vr::EVREye::Eye_left), layer 1 is the right eye texture (vr::EVREye::Eye_Right)",
					"name": "TextureType_Metal",
					"value": "6"
				}
			]
		},
		{
			"enumname": "vr::EColorSpace",
			"values": [
				{
					"doc": "Assumes 'gamma' for 8-bit per component formats, otherwise 'linear'.  This mirrors the DXGI formats which have _SRGB variants.",
					"name": "ColorSpace_Auto",
					"value": "0"
				},
				{
					"doc": "Texture data can be displayed directly on the display without any conversion (a.k.a. display native format).",
					"name": "ColorSpace_Gamma",
					"value": "1"
				},
				{
					"doc": " Same as gamma but has been converted to a linear representation using DXGI's sRGB conversion algorithm.",
					"name": "ColorSpace_Linear",
					"value": "2"
				}
			]
		},
		{
			"enumname": "vr::ETrackingResult",
			"values": [
				{
					"name": "TrackingResult_Uninitialized",
					"value": "1"
				},
				{
					"name": "TrackingResult_Calibrating_InProgress",
					"value": "100"
				},
				{
					"name": "TrackingResult_Calibrating_OutOfRange",
					"value": "101"
				},
				{
					"name": "TrackingResult_Running_OK",
					"value": "200"
				},
				{
					"name": "TrackingResult_Running_OutOfRange",
					"value": "201"
				},
				{
					"name": "TrackingResult_Fallback_RotationOnly",
					"value": "300"
				}
			]
		},
		{
			"doc": "Describes what kind of object is being tracked at a given ID",
			"enumname": "vr::ETrackedDeviceClass",
			"values": [
				{
					"doc": "the ID was not valid.",
					"name": "TrackedDeviceClass_Invalid",
					"value": "0"
				},
				{
					"doc": "Head-Mounted Displays",
					"name": "TrackedDeviceClass_HMD",
					"value": "1"
				},
				{
					"doc": "Tracked controllers",
					"name": "TrackedDeviceClass_Controller",
					"value": "2"
				},
				{
					"doc": "Generic trackers, similar to controllers",
					"name": "TrackedDeviceClass_GenericTracker",
					"value": "3"
				},
				{
					"doc": "Camera and base stations that serve as tracking reference points",
					"name": "TrackedDeviceClass_TrackingReference",
					"value": "4"
				},
				{
					"doc": "Accessories that aren't necessarily tracked themselves, but may redirect video output from other tracked devices",
					"name": "TrackedDeviceClass_DisplayRedirect",
					"value": "5"
				},
				{
					"name": "TrackedDeviceClass_Max",
					"value": "6"
				}
			]
		},
		{
			"doc": "Describes what specific role associated with a tracked device",
			"enumname": "vr::ETrackedControllerRole",
			"values": [
				{
					"doc": "Invalid value for controller type",
					"name": "TrackedControllerRole_Invalid",
					"value": "0"
				},
				{
					"doc": "Tracked device associated with the left hand",
					"name": "TrackedControllerRole_LeftHand",
					"value": "1"
				},
				{
					"doc": "Tracked device associated with the right hand",
					"name": "TrackedControllerRole_RightHand",
					"value": "2"
				},
				{
					"doc": "Tracked device is opting out of left/right hand selection",
					"name": "TrackedControllerRole_OptOut",
					"value": "3"
				},
				{
					"doc": "Tracked device is a treadmill or other locomotion device",
					"name": "TrackedControllerRole_Treadmill",
					"value": "4"
				},
				{
					"doc": "Tracked device is a stylus",
					"name": "TrackedControllerRole_Stylus",
					"value": "5"
				},
				{
					"name": "TrackedControllerRole_Max",
					"value": "5"
				}
			]
		},
		{
			"doc": "Identifies which style of tracking origin the application wants to use for the poses it is requesting",
			"enumname": "vr::ETrackingUniverseOrigin",
			"values": [
				{
					"doc": "Poses are provided relative to the seated zero pose",
					"name": "TrackingUniverseSeated",
					"value": "0"
				},
				{
					"doc": "Poses are provided relative to the safe bounds configured by the user",
					"name": "TrackingUniverseStanding",
					"value": "1"
				},
				{
					"doc": "Poses are provided in the coordinate system defined by the driver.  It has Y up and is unified for devices of the same driver. You usually don't want this one.",
					"name": "TrackingUniverseRawAndUncalibrated",
					"value": "2"
				}
			]
		},
		{
			"enumname": "vr::EAdditionalRadioFeatures",
			"values": [
				{
					"name": "AdditionalRadioFeatures_None",
					"value": "0"
				},
				{
					"name": "AdditionalRadioFeatures_HTCLinkBox",
					"value": "1"
				},
				{
					"name": "AdditionalRadioFeatures_InternalDongle",
					"value": "2"
				},
				{
					"name": "AdditionalRadioFeatures_ExternalDongle",
					"value": "4"
				}
			]
		},
		{
			"doc": "Each entry in this enum represents a property that can be retrieved about a tracked device. Many fields are only valid for one ETrackedDeviceClass.",
			"enumname": "vr::ETrackedDeviceProperty",
			"values": [
				{
					"name": "Prop_Invalid",
					"value": "0"
				},
				{
					"name": "Prop_TrackingSystemName_String",
					"value": "1000"
				},
				{
					"name": "Prop_ModelNumber_String",
					"value": "1001"
				},
				{
					"name": "Prop_SerialNumber_String",
					"value": "1002"
				},
				{
					"name": "Prop_RenderModelName_String",
					"value": "1003"
				},
				{
					"name": "Prop_WillDriftInYaw_Bool",
					"value": "1004"
				},
				{
					"name": "Prop_ManufacturerName_String",
					"value": "1005"
				},
				{
					"name": "Prop_TrackingFirmwareVersion_String",
					"value": "1006"
				},
				{
					"name": "Prop_HardwareRevision_String",
					"value": "1007"
				},
				{
					"name": "Prop_AllWirelessDongleDescriptions_String",
					"value": "1008"
				},
				{
					"name": "Prop_ConnectedWirelessDongle_String",
					"value": "1009"
				},
				{
					"name": "Prop_DeviceIsWireless_Bool",
					"value": "1010"
				},
				{
					"name": "Prop_DeviceIsCharging_Bool",
					"value": "1011"
				},
				{
					"doc": "0 is empty, 1 is full",
					"name": "Prop_DeviceBatteryPercentage_Float",
					"value": "1012"
				},
				{
					"name": "Prop_StatusDisplayTransform_Matrix34",
					"value": "1013"
				},
				{
					"name": "Prop_Firmware_UpdateAvailable_Bool",
					"value": "1014"
				},
				{
					"name": "Prop_Firmware_ManualUpdate_Bool",
					"value": "1015"
				},
				{
					"name": "Prop_Firmware_ManualUpdateURL_String",
					"value": "1016"
				},
				{
					"name": "Prop_HardwareRevision_Uint64",
					"value": "1017"
				},
				{
					"name": "Prop_FirmwareVersion_Uint64",
					"value": "1018"
				},
				{
					"name": "Prop_FPGAVersion_Uint64",
					"value": "1019"
				},
				{
					"name": "Prop_VRCVersion_Uint64",
					"value": "1020"
				},
				{
					"name": "Prop_RadioVersion_Uint64",
					"value": "1021"
				},
				{
					"name": "Prop_DongleVersion_Uint64",
					"value": "1022"
				},
				{
					"name": "Prop_BlockServerShutdown_Bool",
					"value": "1023"
				},
				{
					"name": "Prop_CanUnifyCoordinateSystemWithHmd_Bool",
					"value": "1024"
				},
				{
					"name": "Prop_ContainsProximitySensor_Bool",
					"value": "1025"
				},
				{
					"name": "Prop_DeviceProvidesBatteryStatus_Bool",
					"value": "1026"
				},
				{
					"name": "Prop_DeviceCanPowerOff_Bool",
					"value": "1027"
				},
				{
					"name": "Prop_Firmware_ProgrammingTarget_String",
					"value": "1028"
				},
				{
					"name": "Prop_DeviceClass_Int32",
					"value": "1029"
				},
				{
					"name": "Prop_HasCamera_Bool",
					"value": "1030"
				},
				{
					"name": "Prop_DriverVersion_String",
					"value": "1031"
				},
				{
					"name": "Prop_Firmware_ForceUpdateRequired_Bool",
					"value": "1032"
				},
				{
					"name": "Prop_ViveSystemButtonFixRequired_Bool",
					"value": "1033"
				},
				{
					"name": "Prop_ParentDriver_Uint64",
					"value": "1034"
				},
				{
					"name": "Prop_ResourceRoot_String",
					"value": "1035"
				},
				{
					"name": "Prop_RegisteredDeviceType_String",
					"value": "1036"
				},
				{
					"doc": "input profile to use for this device in the input system. Will default to tracking system name if this isn't provided",
					"name": "Prop_InputProfilePath_String",
					"value": "1037"
				},
				{
					"doc": "Used for devices that will never have a valid pose by design",
					"name": "Prop_NeverTracked_Bool",
					"value": "1038"
				},
				{
					"name": "Prop_NumCameras_Int32",
					"value": "1039"
				},
				{
					"doc": "EVRTrackedCameraFrameLayout value",
					"name": "Prop_CameraFrameLayout_Int32",
					"value": "1040"
				},
				{
					"doc": "ECameraVideoStreamFormat value",
					"name": "Prop_CameraStreamFormat_Int32",
					"value": "1041"
				},
				{
					"doc": "driver-relative path to additional device and global configuration settings",
					"name": "Prop_AdditionalDeviceSettingsPath_String",
					"value": "1042"
				},
				{
					"doc": "Whether device supports being identified from vrmonitor (e.g. blink LED, vibrate haptics, etc)",
					"name": "Prop_Identifiable_Bool",
					"value": "1043"
				},
				{
					"name": "Prop_BootloaderVersion_Uint64",
					"value": "1044"
				},
				{
					"doc": "additional string to include in system reports about a tracked device",
					"name": "Prop_AdditionalSystemReportData_String",
					"value": "1045"
				},
				{
					"doc": "additional FW components from a device that gets propagated into reports",
					"name": "Prop_CompositeFirmwareVersion_String",
					"value": "1046"
				},
				{
					"name": "Prop_Firmware_RemindUpdate_Bool",
					"value": "1047"
				},
				{
					"name": "Prop_PeripheralApplicationVersion_Uint64",
					"value": "1048"
				},
				{
					"name": "Prop_ManufacturerSerialNumber_String",
					"value": "1049"
				},
				{
					"name": "Prop_ComputedSerialNumber_String",
					"value": "1050"
				},
				{
					"name": "Prop_EstimatedDeviceFirstUseTime_Int32",
					"value": "1051"
				},
				{
					"name": "Prop_ReportsTimeSinceVSync_Bool",
					"value": "2000"
				},
				{
					"name": "Prop_SecondsFromVsyncToPhotons_Float",
					"value": "2001"
				},
				{
					"name": "Prop_DisplayFrequency_Float",
					"value": "2002"
				},
				{
					"name": "Prop_UserIpdMeters_Float",
					"value": "2003"
				},
				{
					"name": "Prop_CurrentUniverseId_Uint64",
					"value": "2004"
				},
				{
					"name": "Prop_PreviousUniverseId_Uint64",
					"value": "2005"
				},
				{
					"name": "Prop_DisplayFirmwareVersion_Uint64",
					"value": "2006"
				},
				{
					"name": "Prop_IsOnDesktop_Bool",
					"value": "2007"
				},
				{
					"name": "Prop_DisplayMCType_Int32",
					"value": "2008"
				},
				{
					"name": "Prop_DisplayMCOffset_Float",
					"value": "2009"
				},
				{
					"name": "Prop_DisplayMCScale_Float",
					"value": "2010"
				},
				{
					"name": "Prop_EdidVendorID_Int32",
					"value": "2011"
				},
				{
					"name": "Prop_DisplayMCImageLeft_String",
					"value": "2012"
				},
				{
					"name": "Prop_DisplayMCImageRight_String",
					"value": "2013"
				},
				{
					"name": "Prop_DisplayGCBlackClamp_Float",
					"value": "2014"
				},
				{
					"name": "Prop_EdidProductID_Int32",
					"value": "2015"
				},
				{
					"name": "Prop_CameraToHeadTransform_Matrix34",
					"value": "2016"
				},
				{
					"name": "Prop_DisplayGCType_Int32",
					"value": "2017"
				},
				{
					"name": "Prop_DisplayGCOffset_Float",
					"value": "2018"
				},
				{
					"name": "Prop_DisplayGCScale_Float",
					"value": "2019"
				},
				{
					"name": "Prop_DisplayGCPrescale_Float",
					"value": "2020"
				},
				{
					"name": "Prop_DisplayGCImage_String",
					"value": "2021"
				},
				{
					"name": "Prop_LensCenterLeftU_Float",
					"value": "2022"
				},
				{
					"name": "Prop_LensCenterLeftV_Float",
					"value": "2023"
				},
				{
					"name": "Prop_LensCenterRightU_Float",
					"value": "2024"
				},
				{
					"name": "Prop_LensCenterRightV_Float",
					"value": "2025"
				},
				{
					"name": "Prop_UserHeadToEyeDepthMeters_Float",
					"value": "2026"
				},
				{
					"name": "Prop_CameraFirmwareVersion_Uint64",
					"value": "2027"
				},
				{
					"name": "Prop_CameraFirmwareDescription_String",
					"value": "2028"
				},
				{
					"name": "Prop_DisplayFPGAVersion_Uint64",
					"value": "2029"
				},
				{
					"name": "Prop_DisplayBootloaderVersion_Uint64",
					"value": "2030"
				},
				{
					"name": "Prop_DisplayHardwareVersion_Uint64",
					"value": "2031"
				},
				{
					"name": "Prop_AudioFirmwareVersion_Uint64",
					"value": "2032"
				},
				{
					"name": "Prop_CameraCompatibilityMode_Int32",
					"value": "2033"
				},
				{
					"name": "Prop_ScreenshotHorizontalFieldOfViewDegrees_Float",
					"value": "2034"
				},
				{
					"name": "Prop_ScreenshotVerticalFieldOfViewDegrees_Float",
					"value": "2035"
				},
				{
					"name": "Prop_DisplaySuppressed_Bool",
					"value": "2036"
				},
				{
					"name": "Prop_DisplayAllowNightMode_Bool",
					"value": "2037"
				},
				{
					"name": "Prop_DisplayMCImageWidth_Int32",
					"value": "2038"
				},
				{
					"name": "Prop_DisplayMCImageHeight_Int32",
					"value": "2039"
				},
				{
					"name": "Prop_DisplayMCImageNumChannels_Int32",
					"value": "2040"
				},
				{
					"name": "Prop_DisplayMCImageData_Binary",
					"value": "2041"
				},
				{
					"name": "Prop_SecondsFromPhotonsToVblank_Float",
					"value": "2042"
				},
				{
					"name": "Prop_DriverDirectModeSendsVsyncEvents_Bool",
					"value": "2043"
				},
				{
					"name": "Prop_DisplayDebugMode_Bool",
					"value": "2044"
				},
				{
					"name": "Prop_GraphicsAdapterLuid_Uint64",
					"value": "2045"
				},
				{
					"name": "Prop_DriverProvidedChaperonePath_String",
					"value": "2048"
				},
				{
					"doc": "expected number of sensors or basestations to reserve UI space for",
					"name": "Prop_ExpectedTrackingReferenceCount_Int32",
					"value": "2049"
				},
				{
					"doc": "expected number of tracked controllers to reserve UI space for",
					"name": "Prop_ExpectedControllerCount_Int32",
					"value": "2050"
				},
				{
					"doc": "placeholder icon for \"left\" controller if not yet detected/loaded",
					"name": "Prop_NamedIconPathControllerLeftDeviceOff_String",
					"value": "2051"
				},
				{
					"doc": "placeholder icon for \"right\" controller if not yet detected/loaded",
					"name": "Prop_NamedIconPathControllerRightDeviceOff_String",
					"value": "2052"
				},
				{
					"doc": "placeholder icon for sensor/base if not yet detected/loaded",
					"name": "Prop_NamedIconPathTrackingReferenceDeviceOff_String",
					"value": "2053"
				},
				{
					"doc": "currently no effect. was used to disable HMD pose prediction on MR, which is now done by MR driver setting velocity=0",
					"name": "Prop_DoNotApplyPrediction_Bool",
					"value": "2054"
				},
				{
					"name": "Prop_CameraToHeadTransforms_Matrix34_Array",
					"value": "2055"
				},
				{
					"doc": "custom resolution of compositor calls to IVRSystem::ComputeDistortion",
					"name": "Prop_DistortionMeshResolution_Int32",
					"value": "2056"
				},
				{
					"name": "Prop_DriverIsDrawingControllers_Bool",
					"value": "2057"
				},
				{
					"name": "Prop_DriverRequestsApplicationPause_Bool",
					"value": "2058"
				},
				{
					"name": "Prop_DriverRequestsReducedRendering_Bool",
					"value": "2059"
				},
				{
					"name": "Prop_MinimumIpdStepMeters_Float",
					"value": "2060"
				},
				{
					"name": "Prop_AudioBridgeFirmwareVersion_Uint64",
					"value": "2061"
				},
				{
					"name": "Prop_ImageBridgeFirmwareVersion_Uint64",
					"value": "2062"
				},
				{
					"name": "Prop_ImuToHeadTransform_Matrix34",
					"value": "2063"
				},
				{
					"name": "Prop_ImuFactoryGyroBias_Vector3",
					"value": "2064"
				},
				{
					"name": "Prop_ImuFactoryGyroScale_Vector3",
					"value": "2065"
				},
				{
					"name": "Prop_ImuFactoryAccelerometerBias_Vector3",
					"value": "2066"
				},
				{
					"name": "Prop_ImuFactoryAccelerometerScale_Vector3",
					"value": "2067"
				},
				{
					"name": "Prop_ConfigurationIncludesLighthouse20Features_Bool",
					"value": "2069"
				},
				{
					"name": "Prop_AdditionalRadioFeatures_Uint64",
					"value": "2070"
				},
				{
					"doc": "Prop_NumCameras_Int32-sized array of float[4] RGBG white balance calibration data (max size is vr::k_unMaxCameras)",
					"name": "Prop_CameraWhiteBalance_Vector4_Array",
					"value": "2071"
				},
				{
					"doc": "Prop_NumCameras_Int32-sized array of vr::EVRDistortionFunctionType values (max size is vr::k_unMaxCameras)",
					"name": "Prop_CameraDistortionFunction_Int32_Array",
					"value": "2072"
				},
				{
					"doc": "Prop_NumCameras_Int32-sized array of double[vr::k_unMaxDistortionFunctionParameters] (max size is vr::k_unMaxCameras)",
					"name": "Prop_CameraDistortionCoefficients_Float_Array",
					"value": "2073"
				},
				{
					"name": "Prop_ExpectedControllerType_String",
					"value": "2074"
				},
				{
					"doc": "one of EHmdTrackingStyle",
					"name": "Prop_HmdTrackingStyle_Int32",
					"value": "2075"
				},
				{
					"name": "Prop_DriverProvidedChaperoneVisibility_Bool",
					"value": "2076"
				},
				{
					"name": "Prop_HmdColumnCorrectionSettingPrefix_String",
					"value": "2077"
				},
				{
					"name": "Prop_CameraSupportsCompatibilityModes_Bool",
					"value": "2078"
				},
				{
					"doc": "populated by compositor from actual EDID list when available from GPU driver",
					"name": "Prop_DisplayAvailableFrameRates_Float_Array",
					"value": "2080"
				},
				{
					"doc": "if this is true but Prop_DisplayAvailableFrameRates_Float_Array is empty, explain to user",
					"name": "Prop_DisplaySupportsMultipleFramerates_Bool",
					"value": "2081"
				},
				{
					"name": "Prop_DisplayColorMultLeft_Vector3",
					"value": "2082"
				},
				{
					"name": "Prop_DisplayColorMultRight_Vector3",
					"value": "2083"
				},
				{
					"name": "Prop_DisplaySupportsRuntimeFramerateChange_Bool",
					"value": "2084"
				},
				{
					"name": "Prop_DisplaySupportsAnalogGain_Bool",
					"value": "2085"
				},
				{
					"name": "Prop_DisplayMinAnalogGain_Float",
					"value": "2086"
				},
				{
					"name": "Prop_DisplayMaxAnalogGain_Float",
					"value": "2087"
				},
				{
					"name": "Prop_DashboardScale_Float",
					"value": "2091"
				},
				{
					"name": "Prop_IpdUIRangeMinMeters_Float",
					"value": "2100"
				},
				{
					"name": "Prop_IpdUIRangeMaxMeters_Float",
					"value": "2101"
				},
				{
					"name": "Prop_DriverRequestedMuraCorrectionMode_Int32",
					"value": "2200"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_InnerLeft_Int32",
					"value": "2201"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_InnerRight_Int32",
					"value": "2202"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_InnerTop_Int32",
					"value": "2203"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_InnerBottom_Int32",
					"value": "2204"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_OuterLeft_Int32",
					"value": "2205"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_OuterRight_Int32",
					"value": "2206"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_OuterTop_Int32",
					"value": "2207"
				},
				{
					"name": "Prop_DriverRequestedMuraFeather_OuterBottom_Int32",
					"value": "2208"
				},
				{
					"name": "Prop_Audio_DefaultPlaybackDeviceId_String",
					"value": "2300"
				},
				{
					"name": "Prop_Audio_DefaultRecordingDeviceId_String",
					"value": "2301"
				},
				{
					"name": "Prop_Audio_DefaultPlaybackDeviceVolume_Float",
					"value": "2302"
				},
				{
					"name": "Prop_AttachedDeviceId_String",
					"value": "3000"
				},
				{
					"name": "Prop_SupportedButtons_Uint64",
					"value": "3001"
				},
				{
					"doc": "Return value is of type EVRControllerAxisType",
					"name": "Prop_Axis0Type_Int32",
					"value": "3002"
				},
				{
					"doc": "Return value is of type EVRControllerAxisType",
					"name": "Prop_Axis1Type_Int32",
					"value": "3003"
				},
				{
					"doc": "Return value is of type EVRControllerAxisType",
					"name": "Prop_Axis2Type_Int32",
					"value": "3004"
				},
				{
					"doc": "Return value is of type EVRControllerAxisType",
					"name": "Prop_Axis3Type_Int32",
					"value": "3005"
				},
				{
					"doc": "Return value is of type EVRControllerAxisType",
					"name": "Prop_Axis4Type_Int32",
					"value": "3006"
				},
				{
					"doc": "Return value is of type ETrackedControllerRole",
					"name": "Prop_ControllerRoleHint_Int32",
					"value": "3007"
				},
				{
					"name": "Prop_FieldOfViewLeftDegrees_Float",
					"value": "4000"
				},
				{
					"name": "Prop_FieldOfViewRightDegrees_Float",
					"value": "4001"
				},
				{
					"name": "Prop_FieldOfViewTopDegrees_Float",
					"value": "4002"
				},
				{
					"name": "Prop_FieldOfViewBottomDegrees_Float",
					"value": "4003"
				},
				{
					"name": "Prop_TrackingRangeMinimumMeters_Float",
					"value": "4004"
				},
				{
					"name": "Prop_TrackingRangeMaximumMeters_Float",
					"value": "4005"
				},
				{
					"name": "Prop_ModeLabel_String",
					"value": "4006"
				},
				{
					"doc": "volatile, based on radio presence and fw discovery",
					"name": "Prop_CanWirelessIdentify_Bool",
					"value": "4007"
				},
				{
					"name": "Prop_Nonce_Int32",
					"value": "4008"
				},
				{
					"doc": "DEPRECATED. Value not referenced. Now expected to be part of icon path properties.",
					"name": "Prop_IconPathName_String",
					"value": "5000"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceOff_String",
					"value": "5001"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceSearching_String",
					"value": "5002"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceSearchingAlert_String",
					"value": "5003"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceReady_String",
					"value": "5004"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceReadyAlert_String",
					"value": "5005"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceNotReady_String",
					"value": "5006"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceStandby_String",
					"value": "5007"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceAlertLow_String",
					"value": "5008"
				},
				{
					"doc": "{driver}/icons/icon_filename - PNG for static icon, or GIF for animation, 50x32 for headsets and 32x32 for others",
					"name": "Prop_NamedIconPathDeviceStandbyAlert_String",
					"value": "5009"
				},
				{
					"name": "Prop_DisplayHiddenArea_Binary_Start",
					"value": "5100"
				},
				{
					"name": "Prop_DisplayHiddenArea_Binary_End",
					"value": "5150"
				},
				{
					"name": "Prop_ParentContainer",
					"value": "5151"
				},
				{
					"name": "Prop_OverrideContainer_Uint64",
					"value": "5152"
				},
				{
					"name": "Prop_UserConfigPath_String",
					"value": "6000"
				},
				{
					"name": "Prop_InstallPath_String",
					"value": "6001"
				},
				{
					"name": "Prop_HasDisplayComponent_Bool",
					"value": "6002"
				},
				{
					"name": "Prop_HasControllerComponent_Bool",
					"value": "6003"
				},
				{
					"name": "Prop_HasCameraComponent_Bool",
					"value": "6004"
				},
				{
					"name": "Prop_HasDriverDirectModeComponent_Bool",
					"value": "6005"
				},
				{
					"name": "Prop_HasVirtualDisplayComponent_Bool",
					"value": "6006"
				},
				{
					"name": "Prop_HasSpatialAnchorsSupport_Bool",
					"value": "6007"
				},
				{
					"name": "Prop_ControllerType_String",
					"value": "7000"
				},
				{
					"doc": "Allows hand assignments to prefer some controllers over others. High numbers are selected over low numbers",
					"name": "Prop_ControllerHandSelectionPriority_Int32",
					"value": "7002"
				},
				{
					"name": "Prop_VendorSpecific_Reserved_Start",
					"value": "10000"
				},
				{
					"name": "Prop_VendorSpecific_Reserved_End",
					"value": "10999"
				},
				{
					"name": "Prop_TrackedDeviceProperty_Max",
					"value": "1000000"
				}
			]
		},
		{
			"doc": "Used to return errors that occur when reading properties.",
			"enumname": "vr::ETrackedPropertyError",
			"values": [
				{
					"name": "TrackedProp_Success",
					"value": "0"
				},
				{
					"name": "TrackedProp_WrongDataType",
					"value": "1"
				},
				{
					"name": "TrackedProp_WrongDeviceClass",
					"value": "2"
				},
				{
					"name": "TrackedProp_BufferTooSmall",
					"value": "3"
				},
				{
					"doc": "Driver has not set the property (and may not ever).",
					"name": "TrackedProp_UnknownProperty",
					"value": "4"
				},
				{
					"name": "TrackedProp_InvalidDevice",
					"value": "5"
				},
				{
					"name": "TrackedProp_CouldNotContactServer",
					"value": "6"
				},
				{
					"name": "TrackedProp_ValueNotProvidedByDevice",
					"value": "7"
				},
				{
					"name": "TrackedProp_StringExceedsMaximumLength",
					"value": "8"
				},
				{
					"doc": "The property value isn't known yet, but is expected soon. Call again later.",
					"name": "TrackedProp_NotYetAvailable",
					"value": "9"
				},
				{
					"name": "TrackedProp_PermissionDenied",
					"value": "10"
				},
				{
					"name": "TrackedProp_InvalidOperation",
					"value": "11"
				},
				{
					"name": "TrackedProp_CannotWriteToWildcards",
					"value": "12"
				},
				{
					"name": "TrackedProp_IPCReadFailure",
					"value": "13"
				},
				{
					"name": "TrackedProp_OutOfMemory",
					"value": "14"
				},
				{
					"name": "TrackedProp_InvalidContainer",
					"value": "15"
				}
			]
		},
		{
			"doc": "Used to drive certain text in the UI when talking about the tracking system for the HMD",
			"enumname": "vr::EHmdTrackingStyle",
			"values": [
				{
					"name": "HmdTrackingStyle_Unknown",
					"value": "0"
				},
				{
					"doc": "base stations and lasers",
					"name": "HmdTrackingStyle_Lighthouse",
					"value": "1"
				},
				{
					"doc": "Cameras and LED, Rift 1 style",
					"name": "HmdTrackingStyle_OutsideInCameras",
					"value": "2"
				},
				{
					"doc": "Cameras on HMD looking at the world",
					"name": "HmdTrackingStyle_InsideOutCameras",
					"value": "3"
				}
			]
		},
		{
			"doc": "Allows the application to control how scene textures are used by the compositor when calling Submit.",
			"enumname": "vr::EVRSubmitFlags",
			"values": [
				{
					"doc": "Simple render path. App submits rendered left and right eye images with no lens distortion correction applied.",
					"name": "Submit_Default",
					"value": "0"
				},
				{
					"doc": "App submits final left and right eye images with lens distortion already applied (lens distortion makes the images appear barrel distorted with chromatic aberration correction applied). The app would have used the data returned by vr::IVRSystem::ComputeDistortion() to apply the correct distortion to the rendered images before calling Submit().",
					"name": "Submit_LensDistortionAlreadyApplied",
					"value": "1"
				},
				{
					"doc": "If the texture pointer passed in is actually a renderbuffer (e.g. for MSAA in OpenGL) then set this flag.",
					"name": "Submit_GlRenderBuffer",
					"value": "2"
				},
				{
					"doc": "Do not use",
					"name": "Submit_Reserved",
					"value": "4"
				},
				{
					"doc": "Set to indicate that pTexture is a pointer to a VRTextureWithPose_t.\nThis flag can be combined with Submit_TextureWithDepth to pass a VRTextureWithPoseAndDepth_t.",
					"name": "Submit_TextureWithPose",
					"value": "8"
				},
				{
					"doc": "Set to indicate that pTexture is a pointer to a VRTextureWithDepth_t.\nThis flag can be combined with Submit_TextureWithPose to pass a VRTextureWithPoseAndDepth_t.",
					"name": "Submit_TextureWithDepth",
					"value": "16"
				},
				{
					"doc": "Set to indicate a discontinuity between this and the last frame.\nThis will prevent motion smoothing from attempting to extrapolate using the pair.",
					"name": "Submit_FrameDiscontinuty",
					"value": "32"
				}
			]
		},
		{
			"doc": "Status of the overall system or tracked objects",
			"enumname": "vr::EVRState",
			"values": [
				{
					"name": "VRState_Undefined",
					"value": "-1"
				},
				{
					"name": "VRState_Off",
					"value": "0"
				},
				{
					"name": "VRState_Searching",
					"value": "1"
				},
				{
					"name": "VRState_Searching_Alert",
					"value": "2"
				},
				{
					"name": "VRState_Ready",
					"value": "3"
				},
				{
					"name": "VRState_Ready_Alert",
					"value": "4"
				},
				{
					"name": "VRState_NotReady",
					"value": "5"
				},
				{
					"name": "VRState_Standby",
					"value": "6"
				},
				{
					"name": "VRState_Ready_Alert_Low",
					"value": "7"
				}
			]
		},
		{
			"doc": "The types of events that could be posted (and what the parameters mean for each event type)",
			"enumname": "vr::EVREventType",
			"values": [
				{
					"name": "VREvent_None",
					"value": "0"
				},
				{
					"name": "VREvent_TrackedDeviceActivated",
					"value": "100"
				},
				{
					"name": "VREvent_TrackedDeviceDeactivated",
					"value": "101"
				},
				{
					"name": "VREvent_TrackedDeviceUpdated",
					"value": "102"
				},
				{
					"name": "VREvent_TrackedDeviceUserInteractionStarted",
					"value": "103"
				},
				{
					"name": "VREvent_TrackedDeviceUserInteractionEnded",
					"value": "104"
				},
				{
					"name": "VREvent_IpdChanged",
					"value": "105"
				},
				{
					"name": "VREvent_EnterStandbyMode",
					"value": "106"
				},
				{
					"name": "VREvent_LeaveStandbyMode",
					"value": "107"
				},
				{
					"name": "VREvent_TrackedDeviceRoleChanged",
					"value": "108"
				},
				{
					"name": "VREvent_WatchdogWakeUpRequested",
					"value": "109"
				},
				{
					"name": "VREvent_LensDistortionChanged",
					"value": "110"
				},
				{
					"name": "VREvent_PropertyChanged",
					"value": "111"
				},
				{
					"name": "VREvent_WirelessDisconnect",
					"value": "112"
				},
				{
					"name": "VREvent_WirelessReconnect",
					"value": "113"
				},
				{
					"doc": "data is controller",
					"name": "VREvent_ButtonPress",
					"value": "200"
				},
				{
					"doc": "data is controller",
					"name": "VREvent_ButtonUnpress",
					"value": "201"
				},
				{
					"doc": "data is controller",
					"name": "VREvent_ButtonTouch",
					"value": "202"
				},
				{
					"doc": "data is controller",
					"name": "VREvent_ButtonUntouch",
					"value": "203"
				},
				{
					"doc": "Sent to overlays with the",
					"name": "VREvent_Modal_Cancel",
					"value": "257"
				},
				{
					"doc": "data is mouse",
					"name": "VREvent_MouseMove",
					"value": "300"
				},
				{
					"doc": "data is mouse",
					"name": "VREvent_MouseButtonDown",
					"value": "301"
				},
				{
					"doc": "data is mouse",
					"name": "VREvent_MouseButtonUp",
					"value": "302"
				},
				{
					"doc": "data is overlay",
					"name": "VREvent_FocusEnter",
					"value": "303"
				},
				{
					"doc": "data is overlay",
					"name": "VREvent_FocusLeave",
					"value": "304"
				},
				{
					"doc": "data is scroll",
					"name": "VREvent_ScrollDiscrete",
					"value": "305"
				},
				{
					"doc": "data is mouse",
					"name": "VREvent_TouchPadMove",
					"value": "306"
				},
				{
					"doc": "data is overlay, global event",
					"name": "VREvent_OverlayFocusChanged",
					"value": "307"
				},
				{
					"name": "VREvent_ReloadOverlays",
					"value": "308"
				},
				{
					"doc": "data is scroll",
					"name": "VREvent_ScrollSmooth",
					"value": "309"
				},
				{
					"name": "VREvent_LockMousePosition",
					"value": "310"
				},
				{
					"name": "VREvent_UnlockMousePosition",
					"value": "311"
				},
				{
					"doc": "data is process DEPRECATED",
					"name": "VREvent_InputFocusCaptured",
					"value": "400"
				},
				{
					"doc": "data is process DEPRECATED",
					"name": "VREvent_InputFocusReleased",
					"value": "401"
				},
				{
					"doc": "data is process - The App actually drawing the scene changed (usually to or from the compositor)",
					"name": "VREvent_SceneApplicationChanged",
					"value": "404"
				},
				{
					"doc": "data is process - New app got access to draw the scene",
					"name": "VREvent_SceneFocusChanged",
					"value": "405"
				},
				{
					"doc": "data is process",
					"name": "VREvent_InputFocusChanged",
					"value": "406"
				},
				{
					"doc": "data is process",
					"name": "VREvent_SceneApplicationUsingWrongGraphicsAdapter",
					"value": "408"
				},
				{
					"doc": "data is process - The App that action binds reloaded for",
					"name": "VREvent_ActionBindingReloaded",
					"value": "409"
				},
				{
					"doc": "Sent to the scene application to request hiding render models temporarily",
					"name": "VREvent_HideRenderModels",
					"value": "410"
				},
				{
					"doc": "Sent to the scene application to request restoring render model visibility",
					"name": "VREvent_ShowRenderModels",
					"value": "411"
				},
				{
					"doc": "No data; but query VRApplications()->GetSceneApplicationState();",
					"name": "VREvent_SceneApplicationStateChanged",
					"value": "412"
				},
				{
					"name": "VREvent_ConsoleOpened",
					"value": "420"
				},
				{
					"name": "VREvent_ConsoleClosed",
					"value": "421"
				},
				{
					"name": "VREvent_OverlayShown",
					"value": "500"
				},
				{
					"name": "VREvent_OverlayHidden",
					"value": "501"
				},
				{
					"name": "VREvent_DashboardActivated",
					"value": "502"
				},
				{
					"name": "VREvent_DashboardDeactivated",
					"value": "503"
				},
				{
					"doc": "Sent to the overlay manager - data is overlay",
					"name": "VREvent_DashboardRequested",
					"value": "505"
				},
				{
					"doc": "Send to the overlay manager",
					"name": "VREvent_ResetDashboard",
					"value": "506"
				},
				{
					"doc": "Sent to overlays when a SetOverlayRaw or SetOverlayFromFile call finishes loading",
					"name": "VREvent_ImageLoaded",
					"value": "508"
				},
				{
					"doc": "Sent to keyboard renderer in the dashboard to invoke it",
					"name": "VREvent_ShowKeyboard",
					"value": "509"
				},
				{
					"doc": "Sent to keyboard renderer in the dashboard to hide it",
					"name": "VREvent_HideKeyboard",
					"value": "510"
				},
				{
					"doc": "Sent to an overlay when IVROverlay::SetFocusOverlay is called on it",
					"name": "VREvent_OverlayGamepadFocusGained",
					"value": "511"
				},
				{
					"doc": "Send to an overlay when it previously had focus and IVROverlay::SetFocusOverlay is called on something else",
					"name": "VREvent_OverlayGamepadFocusLost",
					"value": "512"
				},
				{
					"name": "VREvent_OverlaySharedTextureChanged",
					"value": "513"
				},
				{
					"doc": "Screenshot button combo was pressed, Dashboard should request a screenshot",
					"name": "VREvent_ScreenshotTriggered",
					"value": "516"
				},
				{
					"doc": "Sent to overlays when a SetOverlayRaw or SetOverlayfromFail fails to load",
					"name": "VREvent_ImageFailed",
					"value": "517"
				},
				{
					"name": "VREvent_DashboardOverlayCreated",
					"value": "518"
				},
				{
					"name": "VREvent_SwitchGamepadFocus",
					"value": "519"
				},
				{
					"doc": "Sent by vrclient application to compositor to take a screenshot",
					"name": "VREvent_RequestScreenshot",
					"value": "520"
				},
				{
					"doc": "Sent by compositor to the application that the screenshot has been taken",
					"name": "VREvent_ScreenshotTaken",
					"value": "521"
				},
				{
					"doc": "Sent by compositor to the application that the screenshot failed to be taken",
					"name": "VREvent_ScreenshotFailed",
					"value": "522"
				},
				{
					"doc": "Sent by compositor to the dashboard that a completed screenshot was submitted",
					"name": "VREvent_SubmitScreenshotToDashboard",
					"value": "523"
				},
				{
					"doc": "Sent by compositor to the dashboard that a completed screenshot was submitted",
					"name": "VREvent_ScreenshotProgressToDashboard",
					"value": "524"
				},
				{
					"name": "VREvent_PrimaryDashboardDeviceChanged",
					"value": "525"
				},
				{
					"doc": "Sent by compositor whenever room-view is enabled",
					"name": "VREvent_RoomViewShown",
					"value": "526"
				},
				{
					"doc": "Sent by compositor whenever room-view is disabled",
					"name": "VREvent_RoomViewHidden",
					"value": "527"
				},
				{
					"doc": "data is showUi",
					"name": "VREvent_ShowUI",
					"value": "528"
				},
				{
					"doc": "data is showDevTools",
					"name": "VREvent_ShowDevTools",
					"value": "529"
				},
				{
					"name": "VREvent_Notification_Shown",
					"value": "600"
				},
				{
					"name": "VREvent_Notification_Hidden",
					"value": "601"
				},
				{
					"name": "VREvent_Notification_BeginInteraction",
					"value": "602"
				},
				{
					"name": "VREvent_Notification_Destroyed",
					"value": "603"
				},
				{
					"doc": "data is process",
					"name": "VREvent_Quit",
					"value": "700"
				},
				{
					"doc": "data is process",
					"name": "VREvent_ProcessQuit",
					"value": "701"
				},
				{
					"doc": "data is process",
					"name": "VREvent_QuitAcknowledged",
					"value": "703"
				},
				{
					"doc": "The driver has requested that SteamVR shut down",
					"name": "VREvent_DriverRequestedQuit",
					"value": "704"
				},
				{
					"doc": "A driver or other component wants the user to restart SteamVR",
					"name": "VREvent_RestartRequested",
					"value": "705"
				},
				{
					"doc": "this will never happen with the new chaperone system",
					"name": "VREvent_ChaperoneDataHasChanged",
					"value": "800"
				},
				{
					"name": "VREvent_ChaperoneUniverseHasChanged",
					"value": "801"
				},
				{
					"doc": "this will never happen with the new chaperone system",
					"name": "VREvent_ChaperoneTempDataHasChanged",
					"value": "802"
				},
				{
					"name": "VREvent_ChaperoneSettingsHaveChanged",
					"value": "803"
				},
				{
					"name": "VREvent_SeatedZeroPoseReset",
					"value": "804"
				},
				{
					"doc": "Sent when the process needs to reload any cached data it retrieved from VRChaperone()",
					"name": "VREvent_ChaperoneFlushCache",
					"value": "805"
				},
				{
					"doc": "Triggered by CVRChaperoneClient::RoomSetupStarting",
					"name": "VREvent_ChaperoneRoomSetupStarting",
					"value": "806"
				},
				{
					"doc": "Triggered by CVRChaperoneClient::CommitWorkingCopy",
					"name": "VREvent_ChaperoneRoomSetupFinished",
					"value": "807"
				},
				{
					"name": "VREvent_AudioSettingsHaveChanged",
					"value": "820"
				},
				{
					"name": "VREvent_BackgroundSettingHasChanged",
					"value": "850"
				},
				{
					"name": "VREvent_CameraSettingsHaveChanged",
					"value": "851"
				},
				{
					"name": "VREvent_ReprojectionSettingHasChanged",
					"value": "852"
				},
				{
					"name": "VREvent_ModelSkinSettingsHaveChanged",
					"value": "853"
				},
				{
					"name": "VREvent_EnvironmentSettingsHaveChanged",
					"value": "854"
				},
				{
					"name": "VREvent_PowerSettingsHaveChanged",
					"value": "855"
				},
				{
					"name": "VREvent_EnableHomeAppSettingsHaveChanged",
					"value": "856"
				},
				{
					"name": "VREvent_SteamVRSectionSettingChanged",
					"value": "857"
				},
				{
					"name": "VREvent_LighthouseSectionSettingChanged",
					"value": "858"
				},
				{
					"name": "VREvent_NullSectionSettingChanged",
					"value": "859"
				},
				{
					"name": "VREvent_UserInterfaceSectionSettingChanged",
					"value": "860"
				},
				{
					"name": "VREvent_NotificationsSectionSettingChanged",
					"value": "861"
				},
				{
					"name": "VREvent_KeyboardSectionSettingChanged",
					"value": "862"
				},
				{
					"name": "VREvent_PerfSectionSettingChanged",
					"value": "863"
				},
				{
					"name": "VREvent_DashboardSectionSettingChanged",
					"value": "864"
				},
				{
					"name": "VREvent_WebInterfaceSectionSettingChanged",
					"value": "865"
				},
				{
					"name": "VREvent_TrackersSectionSettingChanged",
					"value": "866"
				},
				{
					"name": "VREvent_LastKnownSectionSettingChanged",
					"value": "867"
				},
				{
					"name": "VREvent_DismissedWarningsSectionSettingChanged",
					"value": "868"
				},
				{
					"name": "VREvent_GpuSpeedSectionSettingChanged",
					"value": "869"
				},
				{
					"name": "VREvent_WindowsMRSectionSettingChanged",
					"value": "870"
				},
				{
					"name": "VREvent_OtherSectionSettingChanged",
					"value": "871"
				},
				{
					"name": "VREvent_StatusUpdate",
					"value": "900"
				},
				{
					"name": "VREvent_WebInterface_InstallDriverCompleted",
					"value": "950"
				},
				{
					"name": "VREvent_MCImageUpdated",
					"value": "1000"
				},
				{
					"name": "VREvent_FirmwareUpdateStarted",
					"value": "1100"
				},
				{
					"name": "VREvent_FirmwareUpdateFinished",
					"value": "1101"
				},
				{
					"name": "VREvent_KeyboardClosed",
					"value": "1200"
				},
				{
					"name": "VREvent_KeyboardCharInput",
					"value": "1201"
				},
				{
					"doc": "Sent when DONE button clicked on keyboard",
					"name": "VREvent_KeyboardDone",
					"value": "1202"
				},
				{
					"name": "VREvent_ApplicationListUpdated",
					"value": "1303"
				},
				{
					"name": "VREvent_ApplicationMimeTypeLoad",
					"value": "1304"
				},
				{
					"name": "VREvent_ProcessConnected",
					"value": "1306"
				},
				{
					"name": "VREvent_ProcessDisconnected",
					"value": "1307"
				},
				{
					"name": "VREvent_Compositor_ChaperoneBoundsShown",
					"value": "1410"
				},
				{
					"name": "VREvent_Compositor_ChaperoneBoundsHidden",
					"value": "1411"
				},
				{
					"name": "VREvent_Compositor_DisplayDisconnected",
					"value": "1412"
				},
				{
					"name": "VREvent_Compositor_DisplayReconnected",
					"value": "1413"
				},
				{
					"doc": "data is hdcpError",
					"name": "VREvent_Compositor_HDCPError",
					"value": "1414"
				},
				{
					"name": "VREvent_Compositor_ApplicationNotResponding",
					"value": "1415"
				},
				{
					"name": "VREvent_Compositor_ApplicationResumed",
					"value": "1416"
				},
				{
					"name": "VREvent_Compositor_OutOfVideoMemory",
					"value": "1417"
				},
				{
					"doc": "k_pch_SteamVR_PreferredRefreshRate",
					"name": "VREvent_Compositor_DisplayModeNotSupported",
					"value": "1418"
				},
				{
					"name": "VREvent_Compositor_StageOverrideReady",
					"value": "1419"
				},
				{
					"name": "VREvent_TrackedCamera_StartVideoStream",
					"value": "1500"
				},
				{
					"name": "VREvent_TrackedCamera_StopVideoStream",
					"value": "1501"
				},
				{
					"name": "VREvent_TrackedCamera_PauseVideoStream",
					"value": "1502"
				},
				{
					"name": "VREvent_TrackedCamera_ResumeVideoStream",
					"value": "1503"
				},
				{
					"name": "VREvent_TrackedCamera_EditingSurface",
					"value": "1550"
				},
				{
					"name": "VREvent_PerformanceTest_EnableCapture",
					"value": "1600"
				},
				{
					"name": "VREvent_PerformanceTest_DisableCapture",
					"value": "1601"
				},
				{
					"name": "VREvent_PerformanceTest_FidelityLevel",
					"value": "1602"
				},
				{
					"name": "VREvent_MessageOverlay_Closed",
					"value": "1650"
				},
				{
					"name": "VREvent_MessageOverlayCloseRequested",
					"value": "1651"
				},
				{
					"doc": "data is hapticVibration",
					"name": "VREvent_Input_HapticVibration",
					"value": "1700"
				},
				{
					"doc": "data is inputBinding",
					"name": "VREvent_Input_BindingLoadFailed",
					"value": "1701"
				},
				{
					"doc": "data is inputBinding",
					"name": "VREvent_Input_BindingLoadSuccessful",
					"value": "1702"
				},
				{
					"doc": "no data",
					"name": "VREvent_Input_ActionManifestReloaded",
					"value": "1703"
				},
				{
					"doc": "data is actionManifest",
					"name": "VREvent_Input_ActionManifestLoadFailed",
					"value": "1704"
				},
				{
					"doc": "data is progressUpdate",
					"name": "VREvent_Input_ProgressUpdate",
					"value": "1705"
				},
				{
					"name": "VREvent_Input_TrackerActivated",
					"value": "1706"
				},
				{
					"name": "VREvent_Input_BindingsUpdated",
					"value": "1707"
				},
				{
					"name": "VREvent_Input_BindingSubscriptionChanged",
					"value": "1708"
				},
				{
					"doc": "data is spatialAnchor. broadcast",
					"name": "VREvent_SpatialAnchors_PoseUpdated",
					"value": "1800"
				},
				{
					"doc": "data is spatialAnchor. broadcast",
					"name": "VREvent_SpatialAnchors_DescriptorUpdated",
					"value": "1801"
				},
				{
					"doc": "data is spatialAnchor. sent to specific driver",
					"name": "VREvent_SpatialAnchors_RequestPoseUpdate",
					"value": "1802"
				},
				{
					"doc": "data is spatialAnchor. sent to specific driver",
					"name": "VREvent_SpatialAnchors_RequestDescriptorUpdate",
					"value": "1803"
				},
				{
					"doc": "user or system initiated generation of a system report. broadcast",
					"name": "VREvent_SystemReport_Started",
					"value": "1900"
				},
				{
					"doc": "data is process",
					"name": "VREvent_Monitor_ShowHeadsetView",
					"value": "2000"
				},
				{
					"doc": "data is process",
					"name": "VREvent_Monitor_HideHeadsetView",
					"value": "2001"
				},
				{
					"name": "VREvent_VendorSpecific_Reserved_Start",
					"value": "10000"
				},
				{
					"name": "VREvent_VendorSpecific_Reserved_End",
					"value": "19999"
				}
			]
		},
		{
			"doc": "Level of Hmd activity\nUserInteraction_Timeout means the device is in the process of timing out.\nInUse = ( k_EDeviceActivityLevel_UserInteraction || k_EDeviceActivityLevel_UserInteraction_Timeout )\nVREvent_TrackedDeviceUserInteractionStarted fires when the devices transitions from Standby -> UserInteraction or Idle -> UserInteraction.\nVREvent_TrackedDeviceUserInteractionEnded fires when the devices transitions from UserInteraction_Timeout -> Idle",
			"enumname": "vr::EDeviceActivityLevel",
			"values": [
				{
					"name": "k_EDeviceActivityLevel_Unknown",
					"value": "-1"
				},
				{
					"doc": "No activity for the last 10 seconds",
					"name": "k_EDeviceActivityLevel_Idle",
					"value": "0"
				},
				{
					"doc": "Activity (movement or prox sensor) is happening now",
					"name": "k_EDeviceActivityLevel_UserInteraction",
					"value": "1"
				},
				{
					"doc": "No activity for the last 0.5 seconds",
					"name": "k_EDeviceActivityLevel_UserInteraction_Timeout",
					"value": "2"
				},
				{
					"doc": "Idle for at least 5 seconds (configurable in Settings -> Power Management)",
					"name": "k_EDeviceActivityLevel_Standby",
					"value": "3"
				},
				{
					"name": "k_EDeviceActivityLevel_Idle_Timeout",
					"value": "4"
				}
			]
		},
		{
			"doc": "VR controller button and axis IDs",
			"enumname": "vr::EVRButtonId",
			"values": [
				{
					"name": "k_EButton_System",
					"value": "0"
				},
				{
					"name": "k_EButton_ApplicationMenu",
					"value": "1"
				},
				{
					"name": "k_EButton_Grip",
					"value": "2"
				},
				{
					"name": "k_EButton_DPad_Left",
					"value": "3"
				},
				{
					"name": "k_EButton_DPad_Up",
					"value": "4"
				},
				{
					"name": "k_EButton_DPad_Right",
					"value": "5"
				},
				{
					"name": "k_EButton_DPad_Down",
					"value": "6"
				},
				{
					"name": "k_EButton_A",
					"value": "7"
				},
				{
					"name": "k_EButton_ProximitySensor",
					"value": "31"
				},
				{
					"name": "k_EButton_Axis0",
					"value": "32"
				},
				{
					"name": "k_EButton_Axis1",
					"value": "33"
				},
				{
					"name": "k_EButton_Axis2",
					"value": "34"
				},
				{
					"name": "k_EButton_Axis3",
					"value": "35"
				},
				{
					"name": "k_EButton_Axis4",
					"value": "36"
				},
				{
					"name": "k_EButton_SteamVR_Touchpad",
					"value": "32"
				},
				{
					"name": "k_EButton_SteamVR_Trigger",
					"value": "33"
				},
				{
					"name": "k_EButton_Dashboard_Back",
					"value": "2"
				},
				{
					"name": "k_EButton_IndexController_A",
					"value": "2"
				},
				{
					"name": "k_EButton_IndexController_B",
					"value": "1"
				},
				{
					"name": "k_EButton_IndexController_JoyStick",
					"value": "35"
				},
				{
					"name": "k_EButton_Max",
					"value": "64"
				}
			]
		},
		{
			"doc": "used for simulated mouse events in overlay space",
			"enumname": "vr::EVRMouseButton",
			"values": [
				{
					"name": "VRMouseButton_Left",
					"value": "1"
				},
				{
					"name": "VRMouseButton_Right",
					"value": "2"
				},
				{
					"name": "VRMouseButton_Middle",
					"value": "4"
				}
			]
		},
		{
			"enumname": "vr::EShowUIType",
			"values": [
				{
					"name": "ShowUI_ControllerBinding",
					"value": "0"
				},
				{
					"name": "ShowUI_ManageTrackers",
					"value": "1"
				},
				{
					"name": "ShowUI_Pairing",
					"value": "3"
				},
				{
					"name": "ShowUI_Settings",
					"value": "4"
				},
				{
					"name": "ShowUI_DebugCommands",
					"value": "5"
				},
				{
					"name": "ShowUI_FullControllerBinding",
					"value": "6"
				},
				{
					"name": "ShowUI_ManageDrivers",
					"value": "7"
				}
			]
		},
		{
			"enumname": "vr::EHDCPError",
			"values": [
				{
					"name": "HDCPError_None",
					"value": "0"
				},
				{
					"name": "HDCPError_LinkLost",
					"value": "1"
				},
				{
					"name": "HDCPError_Tampered",
					"value": "2"
				},
				{
					"name": "HDCPError_DeviceRevoked",
					"value": "3"
				},
				{
					"name": "HDCPError_Unknown",
					"value": "4"
				}
			]
		},
		{
			"enumname": "vr::EVRComponentProperty",
			"values": [
				{
					"name": "VRComponentProperty_IsStatic",
					"value": "1"
				},
				{
					"name": "VRComponentProperty_IsVisible",
					"value": "2"
				},
				{
					"name": "VRComponentProperty_IsTouched",
					"value": "4"
				},
				{
					"name": "VRComponentProperty_IsPressed",
					"value": "8"
				},
				{
					"name": "VRComponentProperty_IsScrolled",
					"value": "16"
				},
				{
					"name": "VRComponentProperty_IsHighlighted",
					"value": "32"
				}
			]
		},
		{
			"enumname": "vr::EVRInputError",
			"values": [
				{
					"name": "VRInputError_None",
					"value": "0"
				},
				{
					"name": "VRInputError_NameNotFound",
					"value": "1"
				},
				{
					"name": "VRInputError_WrongType",
					"value": "2"
				},
				{
					"name": "VRInputError_InvalidHandle",
					"value": "3"
				},
				{
					"name": "VRInputError_InvalidParam",
					"value": "4"
				},
				{
					"name": "VRInputError_NoSteam",
					"value": "5"
				},
				{
					"name": "VRInputError_MaxCapacityReached",
					"value": "6"
				},
				{
					"name": "VRInputError_IPCError",
					"value": "7"
				},
				{
					"name": "VRInputError_NoActiveActionSet",
					"value": "8"
				},
				{
					"name": "VRInputError_InvalidDevice",
					"value": "9"
				},
				{
					"name": "VRInputError_InvalidSkeleton",
					"value": "10"
				},
				{
					"name": "VRInputError_InvalidBoneCount",
					"value": "11"
				},
				{
					"name": "VRInputError_InvalidCompressedData",
					"value": "12"
				},
				{
					"name": "VRInputError_NoData",
					"value": "13"
				},
				{
					"name": "VRInputError_BufferTooSmall",
					"value": "14"
				},
				{
					"name": "VRInputError_MismatchedActionManifest",
					"value": "15"
				},
				{
					"name": "VRInputError_MissingSkeletonData",
					"value": "16"
				},
				{
					"name": "VRInputError_InvalidBoneIndex",
					"value": "17"
				},
				{
					"name": "VRInputError_InvalidPriority",
					"value": "18"
				},
				{
					"name": "VRInputError_PermissionDenied",
					"value": "19"
				},
				{
					"name": "VRInputError_InvalidRenderModel",
					"value": "20"
				}
			]
		},
		{
			"enumname": "vr::EVRSpatialAnchorError",
			"values": [
				{
					"name": "VRSpatialAnchorError_Success",
					"value": "0"
				},
				{
					"name": "VRSpatialAnchorError_Internal",
					"value": "1"
				},
				{
					"name": "VRSpatialAnchorError_UnknownHandle",
					"value": "2"
				},
				{
					"name": "VRSpatialAnchorError_ArrayTooSmall",
					"value": "3"
				},
				{
					"name": "VRSpatialAnchorError_InvalidDescriptorChar",
					"value": "4"
				},
				{
					"name": "VRSpatialAnchorError_NotYetAvailable",
					"value": "5"
				},
				{
					"name": "VRSpatialAnchorError_NotAvailableInThisUniverse",
					"value": "6"
				},
				{
					"name": "VRSpatialAnchorError_PermanentlyUnavailable",
					"value": "7"
				},
				{
					"name": "VRSpatialAnchorError_WrongDriver",
					"value": "8"
				},
				{
					"name": "VRSpatialAnchorError_DescriptorTooLong",
					"value": "9"
				},
				{
					"name": "VRSpatialAnchorError_Unknown",
					"value": "10"
				},
				{
					"name": "VRSpatialAnchorError_NoRoomCalibration",
					"value": "11"
				},
				{
					"name": "VRSpatialAnchorError_InvalidArgument",
					"value": "12"
				},
				{
					"name": "VRSpatialAnchorError_UnknownDriver",
					"value": "13"
				}
			]
		},
		{
			"enumname": "vr::EHiddenAreaMeshType",
			"values": [
				{
					"name": "k_eHiddenAreaMesh_Standard",
					"value": "0"
				},
				{
					"name": "k_eHiddenAreaMesh_Inverse",
					"value": "1"
				},
				{
					"name": "k_eHiddenAreaMesh_LineLoop",
					"value": "2"
				},
				{
					"name": "k_eHiddenAreaMesh_Max",
					"value": "3"
				}
			]
		},
		{
			"doc": "Identifies what kind of axis is on the controller at index n. Read this type with pVRSystem->Get( nControllerDeviceIndex, Prop_Axis0Type_Int32 + n );",
			"enumname": "vr::EVRControllerAxisType",
			"values": [
				{
					"name": "k_eControllerAxis_None",
					"value": "0"
				},
				{
					"name": "k_eControllerAxis_TrackPad",
					"value": "1"
				},
				{
					"name": "k_eControllerAxis_Joystick",
					"value": "2"
				},
				{
					"doc": "Analog trigger data is in the X axis",
					"name": "k_eControllerAxis_Trigger",
					"value": "3"
				}
			]
		},
		{
			"doc": "determines how to provide output to the application of various event processing functions.",
			"enumname": "vr::EVRControllerEventOutputType",
			"values": [
				{
					"name": "ControllerEventOutput_OSEvents",
					"value": "0"
				},
				{
					"name": "ControllerEventOutput_VREvents",
					"value": "1"
				}
			]
		},
		{
			"doc": "Collision Bounds Style",
			"enumname": "vr::ECollisionBoundsStyle",
			"values": [
				{
					"name": "COLLISION_BOUNDS_STYLE_BEGINNER",
					"value": "0"
				},
				{
					"name": "COLLISION_BOUNDS_STYLE_INTERMEDIATE",
					"value": "1"
				},
				{
					"name": "COLLISION_BOUNDS_STYLE_SQUARES",
					"value": "2"
				},
				{
					"name": "COLLISION_BOUNDS_STYLE_ADVANCED",
					"value": "3"
				},
				{
					"name": "COLLISION_BOUNDS_STYLE_NONE",
					"value": "4"
				},
				{
					"name": "COLLISION_BOUNDS_STYLE_COUNT",
					"value": "5"
				}
			]
		},
		{
			"doc": "Errors that can occur around VR overlays",
			"enumname": "vr::EVROverlayError",
			"values": [
				{
					"name": "VROverlayError_None",
					"value": "0"
				},
				{
					"name": "VROverlayError_UnknownOverlay",
					"value": "10"
				},
				{
					"name": "VROverlayError_InvalidHandle",
					"value": "11"
				},
				{
					"name": "VROverlayError_PermissionDenied",
					"value": "12"
				},
				{
					"doc": "No more overlays could be created because the maximum number already exist",
					"name": "VROverlayError_OverlayLimitExceeded",
					"value": "13"
				},
				{
					"name": "VROverlayError_WrongVisibilityType",
					"value": "14"
				},
				{
					"name": "VROverlayError_KeyTooLong",
					"value": "15"
				},
				{
					"name": "VROverlayError_NameTooLong",
					"value": "16"
				},
				{
					"name": "VROverlayError_KeyInUse",
					"value": "17"
				},
				{
					"name": "VROverlayError_WrongTransformType",
					"value": "18"
				},
				{
					"name": "VROverlayError_InvalidTrackedDevice",
					"value": "19"
				},
				{
					"name": "VROverlayError_InvalidParameter",
					"value": "20"
				},
				{
					"name": "VROverlayError_ThumbnailCantBeDestroyed",
					"value": "21"
				},
				{
					"name": "VROverlayError_ArrayTooSmall",
					"value": "22"
				},
				{
					"name": "VROverlayError_RequestFailed",
					"value": "23"
				},
				{
					"name": "VROverlayError_InvalidTexture",
					"value": "24"
				},
				{
					"name": "VROverlayError_UnableToLoadFile",
					"value": "25"
				},
				{
					"name": "VROverlayError_KeyboardAlreadyInUse",
					"value": "26"
				},
				{
					"name": "VROverlayError_NoNeighbor",
					"value": "27"
				},
				{
					"name": "VROverlayError_TooManyMaskPrimitives",
					"value": "29"
				},
				{
					"name": "VROverlayError_BadMaskPrimitive",
					"value": "30"
				},
				{
					"name": "VROverlayError_TextureAlreadyLocked",
					"value": "31"
				},
				{
					"name": "VROverlayError_TextureLockCapacityReached",
					"value": "32"
				},
				{
					"name": "VROverlayError_TextureNotLocked",
					"value": "33"
				}
			]
		},
		{
			"doc": "enum values to pass in to VR_Init to identify whether the application will draw a 3D scene.",
			"enumname": "vr::EVRApplicationType",
			"values": [
				{
					"doc": "Some other kind of application that isn't covered by the other entries ",
					"name": "VRApplication_Other",
					"value": "0"
				},
				{
					"doc": "Application will submit 3D frames ",
					"name": "VRApplication_Scene",
					"value": "1"
				},
				{
					"doc": "Application only interacts with overlays",
					"name": "VRApplication_Overlay",
					"value": "2"
				},
				{
					"doc": "Application should not start SteamVR if it's not already running, and should not keep it running if everything else quits.",
					"name": "VRApplication_Background",
					"value": "3"
				},
				{
					"doc": "Init should not try to load any drivers. The application needs access to utility interfaces (like IVRSettings and IVRApplications) but not hardware.",
					"name": "VRApplication_Utility",
					"value": "4"
				},
				{
					"doc": "Reserved for vrmonitor",
					"name": "VRApplication_VRMonitor",
					"value": "5"
				},
				{
					"doc": "Reserved for Steam",
					"name": "VRApplication_SteamWatchdog",
					"value": "6"
				},
				{
					"doc": "reserved for vrstartup",
					"name": "VRApplication_Bootstrapper",
					"value": "7"
				},
				{
					"doc": "reserved for vrwebhelper",
					"name": "VRApplication_WebHelper",
					"value": "8"
				},
				{
					"name": "VRApplication_Max",
					"value": "9"
				}
			]
		},
		{
			"doc": "error codes for firmware",
			"enumname": "vr::EVRFirmwareError",
			"values": [
				{
					"name": "VRFirmwareError_None",
					"value": "0"
				},
				{
					"name": "VRFirmwareError_Success",
					"value": "1"
				},
				{
					"name": "VRFirmwareError_Fail",
					"value": "2"
				}
			]
		},
		{
			"doc": "error codes for notifications",
			"enumname": "vr::EVRNotificationError",
			"values": [
				{
					"name": "VRNotificationError_OK",
					"value": "0"
				},
				{
					"name": "VRNotificationError_InvalidNotificationId",
					"value": "100"
				},
				{
					"name": "VRNotificationError_NotificationQueueFull",
					"value": "101"
				},
				{
					"name": "VRNotificationError_InvalidOverlayHandle",
					"value": "102"
				},
				{
					"name": "VRNotificationError_SystemWithUserValueAlreadyExists",
					"value": "103"
				}
			]
		},
		{
			"enumname": "vr::EVRSkeletalMotionRange",
			"values": [
				{
					"doc": "The range of motion of the skeleton takes into account any physical limits imposed by the controller itself.  This will tend to be the most accurate pose compared to the user's actual hand pose, but might not allow a closed fist for example",
					"name": "VRSkeletalMotionRange_WithController",
					"value": "0"
				},
				{
					"doc": "Retarget the range of motion provided by the input device to make the hand appear to move as if it was not holding a controller.  eg: map \"hand grasping controller\" to \"closed fist\"",
					"name": "VRSkeletalMotionRange_WithoutController",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::EVRSkeletalTrackingLevel",
			"values": [
				{
					"doc": "body part location can't be directly determined by the device. Any skeletal pose provided by the device is estimated by assuming the position required to active buttons, triggers, joysticks, or other input sensors. E.g. Vive Controller, Gamepad",
					"name": "VRSkeletalTracking_Estimated",
					"value": "0"
				},
				{
					"doc": "body part location can be measured directly but with fewer degrees of freedom than the actual body part. Certain body part positions may be unmeasured by the device and estimated from other input data. E.g. Index Controllers, gloves that only measure finger curl",
					"name": "VRSkeletalTracking_Partial",
					"value": "1"
				},
				{
					"doc": "Body part location can be measured directly throughout the entire range of motion of the body part. E.g. Mocap suit for the full body, gloves that measure rotation of each finger segment",
					"name": "VRSkeletalTracking_Full",
					"value": "2"
				},
				{
					"name": "VRSkeletalTrackingLevel_Count",
					"value": "3"
				},
				{
					"name": "VRSkeletalTrackingLevel_Max",
					"value": "2"
				}
			]
		},
		{
			"doc": "error codes returned by Vr_Init\nPlease add adequate error description to https://developer.valvesoftware.com/w/index.php?title=Category:SteamVRHelp",
			"enumname": "vr::EVRInitError",
			"values": [
				{
					"name": "VRInitError_None",
					"value": "0"
				},
				{
					"name": "VRInitError_Unknown",
					"value": "1"
				},
				{
					"name": "VRInitError_Init_InstallationNotFound",
					"value": "100"
				},
				{
					"name": "VRInitError_Init_InstallationCorrupt",
					"value": "101"
				},
				{
					"name": "VRInitError_Init_VRClientDLLNotFound",
					"value": "102"
				},
				{
					"name": "VRInitError_Init_FileNotFound",
					"value": "103"
				},
				{
					"name": "VRInitError_Init_FactoryNotFound",
					"value": "104"
				},
				{
					"name": "VRInitError_Init_InterfaceNotFound",
					"value": "105"
				},
				{
					"name": "VRInitError_Init_InvalidInterface",
					"value": "106"
				},
				{
					"name": "VRInitError_Init_UserConfigDirectoryInvalid",
					"value": "107"
				},
				{
					"name": "VRInitError_Init_HmdNotFound",
					"value": "108"
				},
				{
					"name": "VRInitError_Init_NotInitialized",
					"value": "109"
				},
				{
					"name": "VRInitError_Init_PathRegistryNotFound",
					"value": "110"
				},
				{
					"name": "VRInitError_Init_NoConfigPath",
					"value": "111"
				},
				{
					"name": "VRInitError_Init_NoLogPath",
					"value": "112"
				},
				{
					"name": "VRInitError_Init_PathRegistryNotWritable",
					"value": "113"
				},
				{
					"name": "VRInitError_Init_AppInfoInitFailed",
					"value": "114"
				},
				{
					"doc": "Used internally to cause retries to vrserver",
					"name": "VRInitError_Init_Retry",
					"value": "115"
				},
				{
					"doc": "The calling application should silently exit. The user canceled app startup",
					"name": "VRInitError_Init_InitCanceledByUser",
					"value": "116"
				},
				{
					"name": "VRInitError_Init_AnotherAppLaunching",
					"value": "117"
				},
				{
					"name": "VRInitError_Init_SettingsInitFailed",
					"value": "118"
				},
				{
					"name": "VRInitError_Init_ShuttingDown",
					"value": "119"
				},
				{
					"name": "VRInitError_Init_TooManyObjects",
					"value": "120"
				},
				{
					"name": "VRInitError_Init_NoServerForBackgroundApp",
					"value": "121"
				},
				{
					"name": "VRInitError_Init_NotSupportedWithCompositor",
					"value": "122"
				},
				{
					"name": "VRInitError_Init_NotAvailableToUtilityApps",
					"value": "123"
				},
				{
					"name": "VRInitError_Init_Internal",
					"value": "124"
				},
				{
					"name": "VRInitError_Init_HmdDriverIdIsNone",
					"value": "125"
				},
				{
					"name": "VRInitError_Init_HmdNotFoundPresenceFailed",
					"value": "126"
				},
				{
					"name": "VRInitError_Init_VRMonitorNotFound",
					"value": "127"
				},
				{
					"name": "VRInitError_Init_VRMonitorStartupFailed",
					"value": "128"
				},
				{
					"name": "VRInitError_Init_LowPowerWatchdogNotSupported",
					"value": "129"
				},
				{
					"name": "VRInitError_Init_InvalidApplicationType",
					"value": "130"
				},
				{
					"name": "VRInitError_Init_NotAvailableToWatchdogApps",
					"value": "131"
				},
				{
					"name": "VRInitError_Init_WatchdogDisabledInSettings",
					"value": "132"
				},
				{
					"name": "VRInitError_Init_VRDashboardNotFound",
					"value": "133"
				},
				{
					"name": "VRInitError_Init_VRDashboardStartupFailed",
					"value": "134"
				},
				{
					"name": "VRInitError_Init_VRHomeNotFound",
					"value": "135"
				},
				{
					"name": "VRInitError_Init_VRHomeStartupFailed",
					"value": "136"
				},
				{
					"name": "VRInitError_Init_RebootingBusy",
					"value": "137"
				},
				{
					"name": "VRInitError_Init_FirmwareUpdateBusy",
					"value": "138"
				},
				{
					"name": "VRInitError_Init_FirmwareRecoveryBusy",
					"value": "139"
				},
				{
					"name": "VRInitError_Init_USBServiceBusy",
					"value": "140"
				},
				{
					"name": "VRInitError_Init_VRWebHelperStartupFailed",
					"value": "141"
				},
				{
					"name": "VRInitError_Init_TrackerManagerInitFailed",
					"value": "142"
				},
				{
					"name": "VRInitError_Init_AlreadyRunning",
					"value": "143"
				},
				{
					"name": "VRInitError_Init_FailedForVrMonitor",
					"value": "144"
				},
				{
					"name": "VRInitError_Init_PropertyManagerInitFailed",
					"value": "145"
				},
				{
					"name": "VRInitError_Init_WebServerFailed",
					"value": "146"
				},
				{
					"name": "VRInitError_Driver_Failed",
					"value": "200"
				},
				{
					"name": "VRInitError_Driver_Unknown",
					"value": "201"
				},
				{
					"name": "VRInitError_Driver_HmdUnknown",
					"value": "202"
				},
				{
					"name": "VRInitError_Driver_NotLoaded",
					"value": "203"
				},
				{
					"name": "VRInitError_Driver_RuntimeOutOfDate",
					"value": "204"
				},
				{
					"name": "VRInitError_Driver_HmdInUse",
					"value": "205"
				},
				{
					"name": "VRInitError_Driver_NotCalibrated",
					"value": "206"
				},
				{
					"name": "VRInitError_Driver_CalibrationInvalid",
					"value": "207"
				},
				{
					"name": "VRInitError_Driver_HmdDisplayNotFound",
					"value": "208"
				},
				{
					"name": "VRInitError_Driver_TrackedDeviceInterfaceUnknown",
					"value": "209"
				},
				{
					"name": "VRInitError_Driver_HmdDriverIdOutOfBounds",
					"value": "211"
				},
				{
					"name": "VRInitError_Driver_HmdDisplayMirrored",
					"value": "212"
				},
				{
					"name": "VRInitError_Driver_HmdDisplayNotFoundLaptop",
					"value": "213"
				},
				{
					"name": "VRInitError_IPC_ServerInitFailed",
					"value": "300"
				},
				{
					"name": "VRInitError_IPC_ConnectFailed",
					"value": "301"
				},
				{
					"name": "VRInitError_IPC_SharedStateInitFailed",
					"value": "302"
				},
				{
					"name": "VRInitError_IPC_CompositorInitFailed",
					"value": "303"
				},
				{
					"name": "VRInitError_IPC_MutexInitFailed",
					"value": "304"
				},
				{
					"name": "VRInitError_IPC_Failed",
					"value": "305"
				},
				{
					"name": "VRInitError_IPC_CompositorConnectFailed",
					"value": "306"
				},
				{
					"name": "VRInitError_IPC_CompositorInvalidConnectResponse",
					"value": "307"
				},
				{
					"name": "VRInitError_IPC_ConnectFailedAfterMultipleAttempts",
					"value": "308"
				},
				{
					"name": "VRInitError_IPC_ConnectFailedAfterTargetExited",
					"value": "309"
				},
				{
					"name": "VRInitError_IPC_NamespaceUnavailable",
					"value": "310"
				},
				{
					"name": "VRInitError_Compositor_Failed",
					"value": "400"
				},
				{
					"name": "VRInitError_Compositor_D3D11HardwareRequired",
					"value": "401"
				},
				{
					"name": "VRInitError_Compositor_FirmwareRequiresUpdate",
					"value": "402"
				},
				{
					"name": "VRInitError_Compositor_OverlayInitFailed",
					"value": "403"
				},
				{
					"name": "VRInitError_Compositor_ScreenshotsInitFailed",
					"value": "404"
				},
				{
					"name": "VRInitError_Compositor_UnableToCreateDevice",
					"value": "405"
				},
				{
					"name": "VRInitError_Compositor_SharedStateIsNull",
					"value": "406"
				},
				{
					"name": "VRInitError_Compositor_NotificationManagerIsNull",
					"value": "407"
				},
				{
					"name": "VRInitError_Compositor_ResourceManagerClientIsNull",
					"value": "408"
				},
				{
					"name": "VRInitError_Compositor_MessageOverlaySharedStateInitFailure",
					"value": "409"
				},
				{
					"name": "VRInitError_Compositor_PropertiesInterfaceIsNull",
					"value": "410"
				},
				{
					"name": "VRInitError_Compositor_CreateFullscreenWindowFailed",
					"value": "411"
				},
				{
					"name": "VRInitError_Compositor_SettingsInterfaceIsNull",
					"value": "412"
				},
				{
					"name": "VRInitError_Compositor_FailedToShowWindow",
					"value": "413"
				},
				{
					"name": "VRInitError_Compositor_DistortInterfaceIsNull",
					"value": "414"
				},
				{
					"name": "VRInitError_Compositor_DisplayFrequencyFailure",
					"value": "415"
				},
				{
					"name": "VRInitError_Compositor_RendererInitializationFailed",
					"value": "416"
				},
				{
					"name": "VRInitError_Compositor_DXGIFactoryInterfaceIsNull",
					"value": "417"
				},
				{
					"name": "VRInitError_Compositor_DXGIFactoryCreateFailed",
					"value": "418"
				},
				{
					"name": "VRInitError_Compositor_DXGIFactoryQueryFailed",
					"value": "419"
				},
				{
					"name": "VRInitError_Compositor_InvalidAdapterDesktop",
					"value": "420"
				},
				{
					"name": "VRInitError_Compositor_InvalidHmdAttachment",
					"value": "421"
				},
				{
					"name": "VRInitError_Compositor_InvalidOutputDesktop",
					"value": "422"
				},
				{
					"name": "VRInitError_Compositor_InvalidDeviceProvided",
					"value": "423"
				},
				{
					"name": "VRInitError_Compositor_D3D11RendererInitializationFailed",
					"value": "424"
				},
				{
					"name": "VRInitError_Compositor_FailedToFindDisplayMode",
					"value": "425"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateSwapChain",
					"value": "426"
				},
				{
					"name": "VRInitError_Compositor_FailedToGetBackBuffer",
					"value": "427"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateRenderTarget",
					"value": "428"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateDXGI2SwapChain",
					"value": "429"
				},
				{
					"name": "VRInitError_Compositor_FailedtoGetDXGI2BackBuffer",
					"value": "430"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateDXGI2RenderTarget",
					"value": "431"
				},
				{
					"name": "VRInitError_Compositor_FailedToGetDXGIDeviceInterface",
					"value": "432"
				},
				{
					"name": "VRInitError_Compositor_SelectDisplayMode",
					"value": "433"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateNvAPIRenderTargets",
					"value": "434"
				},
				{
					"name": "VRInitError_Compositor_NvAPISetDisplayMode",
					"value": "435"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateDirectModeDisplay",
					"value": "436"
				},
				{
					"name": "VRInitError_Compositor_InvalidHmdPropertyContainer",
					"value": "437"
				},
				{
					"name": "VRInitError_Compositor_UpdateDisplayFrequency",
					"value": "438"
				},
				{
					"name": "VRInitError_Compositor_CreateRasterizerState",
					"value": "439"
				},
				{
					"name": "VRInitError_Compositor_CreateWireframeRasterizerState",
					"value": "440"
				},
				{
					"name": "VRInitError_Compositor_CreateSamplerState",
					"value": "441"
				},
				{
					"name": "VRInitError_Compositor_CreateClampToBorderSamplerState",
					"value": "442"
				},
				{
					"name": "VRInitError_Compositor_CreateAnisoSamplerState",
					"value": "443"
				},
				{
					"name": "VRInitError_Compositor_CreateOverlaySamplerState",
					"value": "444"
				},
				{
					"name": "VRInitError_Compositor_CreatePanoramaSamplerState",
					"value": "445"
				},
				{
					"name": "VRInitError_Compositor_CreateFontSamplerState",
					"value": "446"
				},
				{
					"name": "VRInitError_Compositor_CreateNoBlendState",
					"value": "447"
				},
				{
					"name": "VRInitError_Compositor_CreateBlendState",
					"value": "448"
				},
				{
					"name": "VRInitError_Compositor_CreateAlphaBlendState",
					"value": "449"
				},
				{
					"name": "VRInitError_Compositor_CreateBlendStateMaskR",
					"value": "450"
				},
				{
					"name": "VRInitError_Compositor_CreateBlendStateMaskG",
					"value": "451"
				},
				{
					"name": "VRInitError_Compositor_CreateBlendStateMaskB",
					"value": "452"
				},
				{
					"name": "VRInitError_Compositor_CreateDepthStencilState",
					"value": "453"
				},
				{
					"name": "VRInitError_Compositor_CreateDepthStencilStateNoWrite",
					"value": "454"
				},
				{
					"name": "VRInitError_Compositor_CreateDepthStencilStateNoDepth",
					"value": "455"
				},
				{
					"name": "VRInitError_Compositor_CreateFlushTexture",
					"value": "456"
				},
				{
					"name": "VRInitError_Compositor_CreateDistortionSurfaces",
					"value": "457"
				},
				{
					"name": "VRInitError_Compositor_CreateConstantBuffer",
					"value": "458"
				},
				{
					"name": "VRInitError_Compositor_CreateHmdPoseConstantBuffer",
					"value": "459"
				},
				{
					"name": "VRInitError_Compositor_CreateHmdPoseStagingConstantBuffer",
					"value": "460"
				},
				{
					"name": "VRInitError_Compositor_CreateSharedFrameInfoConstantBuffer",
					"value": "461"
				},
				{
					"name": "VRInitError_Compositor_CreateOverlayConstantBuffer",
					"value": "462"
				},
				{
					"name": "VRInitError_Compositor_CreateSceneTextureIndexConstantBuffer",
					"value": "463"
				},
				{
					"name": "VRInitError_Compositor_CreateReadableSceneTextureIndexConstantBuffer",
					"value": "464"
				},
				{
					"name": "VRInitError_Compositor_CreateLayerGraphicsTextureIndexConstantBuffer",
					"value": "465"
				},
				{
					"name": "VRInitError_Compositor_CreateLayerComputeTextureIndexConstantBuffer",
					"value": "466"
				},
				{
					"name": "VRInitError_Compositor_CreateLayerComputeSceneTextureIndexConstantBuffer",
					"value": "467"
				},
				{
					"name": "VRInitError_Compositor_CreateComputeHmdPoseConstantBuffer",
					"value": "468"
				},
				{
					"name": "VRInitError_Compositor_CreateGeomConstantBuffer",
					"value": "469"
				},
				{
					"name": "VRInitError_Compositor_CreatePanelMaskConstantBuffer",
					"value": "470"
				},
				{
					"name": "VRInitError_Compositor_CreatePixelSimUBO",
					"value": "471"
				},
				{
					"name": "VRInitError_Compositor_CreateMSAARenderTextures",
					"value": "472"
				},
				{
					"name": "VRInitError_Compositor_CreateResolveRenderTextures",
					"value": "473"
				},
				{
					"name": "VRInitError_Compositor_CreateComputeResolveRenderTextures",
					"value": "474"
				},
				{
					"name": "VRInitError_Compositor_CreateDriverDirectModeResolveTextures",
					"value": "475"
				},
				{
					"name": "VRInitError_Compositor_OpenDriverDirectModeResolveTextures",
					"value": "476"
				},
				{
					"name": "VRInitError_Compositor_CreateFallbackSyncTexture",
					"value": "477"
				},
				{
					"name": "VRInitError_Compositor_ShareFallbackSyncTexture",
					"value": "478"
				},
				{
					"name": "VRInitError_Compositor_CreateOverlayIndexBuffer",
					"value": "479"
				},
				{
					"name": "VRInitError_Compositor_CreateOverlayVertexBuffer",
					"value": "480"
				},
				{
					"name": "VRInitError_Compositor_CreateTextVertexBuffer",
					"value": "481"
				},
				{
					"name": "VRInitError_Compositor_CreateTextIndexBuffer",
					"value": "482"
				},
				{
					"name": "VRInitError_Compositor_CreateMirrorTextures",
					"value": "483"
				},
				{
					"name": "VRInitError_Compositor_CreateLastFrameRenderTexture",
					"value": "484"
				},
				{
					"name": "VRInitError_Compositor_CreateMirrorOverlay",
					"value": "485"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateVirtualDisplayBackbuffer",
					"value": "486"
				},
				{
					"name": "VRInitError_Compositor_DisplayModeNotSupported",
					"value": "487"
				},
				{
					"name": "VRInitError_Compositor_CreateOverlayInvalidCall",
					"value": "488"
				},
				{
					"name": "VRInitError_Compositor_CreateOverlayAlreadyInitialized",
					"value": "489"
				},
				{
					"name": "VRInitError_Compositor_FailedToCreateMailbox",
					"value": "490"
				},
				{
					"name": "VRInitError_VendorSpecific_UnableToConnectToOculusRuntime",
					"value": "1000"
				},
				{
					"name": "VRInitError_VendorSpecific_WindowsNotInDevMode",
					"value": "1001"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_CantOpenDevice",
					"value": "1101"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_UnableToRequestConfigStart",
					"value": "1102"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_NoStoredConfig",
					"value": "1103"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_ConfigTooBig",
					"value": "1104"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_ConfigTooSmall",
					"value": "1105"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_UnableToInitZLib",
					"value": "1106"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_CantReadFirmwareVersion",
					"value": "1107"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_UnableToSendUserDataStart",
					"value": "1108"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataStart",
					"value": "1109"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataNext",
					"value": "1110"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_UserDataAddressRange",
					"value": "1111"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_UserDataError",
					"value": "1112"
				},
				{
					"name": "VRInitError_VendorSpecific_HmdFound_ConfigFailedSanityCheck",
					"value": "1113"
				},
				{
					"name": "VRInitError_VendorSpecific_OculusRuntimeBadInstall",
					"value": "1114"
				},
				{
					"name": "VRInitError_Steam_SteamInstallationNotFound",
					"value": "2000"
				},
				{
					"name": "VRInitError_LastError",
					"value": "2001"
				}
			]
		},
		{
			"enumname": "vr::EVRScreenshotType",
			"values": [
				{
					"name": "VRScreenshotType_None",
					"value": "0"
				},
				{
					"doc": "left eye only",
					"name": "VRScreenshotType_Mono",
					"value": "1"
				},
				{
					"name": "VRScreenshotType_Stereo",
					"value": "2"
				},
				{
					"name": "VRScreenshotType_Cubemap",
					"value": "3"
				},
				{
					"name": "VRScreenshotType_MonoPanorama",
					"value": "4"
				},
				{
					"name": "VRScreenshotType_StereoPanorama",
					"value": "5"
				}
			]
		},
		{
			"enumname": "vr::EVRScreenshotPropertyFilenames",
			"values": [
				{
					"name": "VRScreenshotPropertyFilenames_Preview",
					"value": "0"
				},
				{
					"name": "VRScreenshotPropertyFilenames_VR",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::EVRTrackedCameraError",
			"values": [
				{
					"name": "VRTrackedCameraError_None",
					"value": "0"
				},
				{
					"name": "VRTrackedCameraError_OperationFailed",
					"value": "100"
				},
				{
					"name": "VRTrackedCameraError_InvalidHandle",
					"value": "101"
				},
				{
					"name": "VRTrackedCameraError_InvalidFrameHeaderVersion",
					"value": "102"
				},
				{
					"name": "VRTrackedCameraError_OutOfHandles",
					"value": "103"
				},
				{
					"name": "VRTrackedCameraError_IPCFailure",
					"value": "104"
				},
				{
					"name": "VRTrackedCameraError_NotSupportedForThisDevice",
					"value": "105"
				},
				{
					"name": "VRTrackedCameraError_SharedMemoryFailure",
					"value": "106"
				},
				{
					"name": "VRTrackedCameraError_FrameBufferingFailure",
					"value": "107"
				},
				{
					"name": "VRTrackedCameraError_StreamSetupFailure",
					"value": "108"
				},
				{
					"name": "VRTrackedCameraError_InvalidGLTextureId",
					"value": "109"
				},
				{
					"name": "VRTrackedCameraError_InvalidSharedTextureHandle",
					"value": "110"
				},
				{
					"name": "VRTrackedCameraError_FailedToGetGLTextureId",
					"value": "111"
				},
				{
					"name": "VRTrackedCameraError_SharedTextureFailure",
					"value": "112"
				},
				{
					"name": "VRTrackedCameraError_NoFrameAvailable",
					"value": "113"
				},
				{
					"name": "VRTrackedCameraError_InvalidArgument",
					"value": "114"
				},
				{
					"name": "VRTrackedCameraError_InvalidFrameBufferSize",
					"value": "115"
				}
			]
		},
		{
			"enumname": "vr::EVRTrackedCameraFrameLayout",
			"values": [
				{
					"name": "EVRTrackedCameraFrameLayout_Mono",
					"value": "1"
				},
				{
					"name": "EVRTrackedCameraFrameLayout_Stereo",
					"value": "2"
				},
				{
					"doc": "Stereo frames are Top/Bottom (left/right)",
					"name": "EVRTrackedCameraFrameLayout_VerticalLayout",
					"value": "16"
				},
				{
					"doc": "Stereo frames are Left/Right",
					"name": "EVRTrackedCameraFrameLayout_HorizontalLayout",
					"value": "32"
				}
			]
		},
		{
			"enumname": "vr::EVRTrackedCameraFrameType",
			"values": [
				{
					"doc": "This is the camera video frame size in pixels, still distorted.",
					"name": "VRTrackedCameraFrameType_Distorted",
					"value": "0"
				},
				{
					"doc": "In pixels, an undistorted inscribed rectangle region without invalid regions. This size is subject to changes shortly.",
					"name": "VRTrackedCameraFrameType_Undistorted",
					"value": "1"
				},
				{
					"doc": "In pixels, maximum undistorted with invalid regions. Non zero alpha component identifies valid regions.",
					"name": "VRTrackedCameraFrameType_MaximumUndistorted",
					"value": "2"
				},
				{
					"name": "MAX_CAMERA_FRAME_TYPES",
					"value": "3"
				}
			]
		},
		{
			"enumname": "vr::EVRDistortionFunctionType",
			"values": [
				{
					"name": "VRDistortionFunctionType_None",
					"value": "0"
				},
				{
					"name": "VRDistortionFunctionType_FTheta",
					"value": "1"
				},
				{
					"name": "VRDistortionFunctionType_Extended_FTheta",
					"value": "2"
				},
				{
					"name": "MAX_DISTORTION_FUNCTION_TYPES",
					"value": "3"
				}
			]
		},
		{
			"enumname": "vr::EVSync",
			"values": [
				{
					"name": "VSync_None",
					"value": "0"
				},
				{
					"doc": "block following render work until vsync",
					"name": "VSync_WaitRender",
					"value": "1"
				},
				{
					"doc": "do not block following render work (allow to get started early)",
					"name": "VSync_NoWaitRender",
					"value": "2"
				}
			]
		},
		{
			"enumname": "vr::EVRMuraCorrectionMode",
			"values": [
				{
					"name": "EVRMuraCorrectionMode_Default",
					"value": "0"
				},
				{
					"name": "EVRMuraCorrectionMode_NoCorrection",
					"value": "1"
				}
			]
		},
		{
			"doc": "raw IMU data provided by IVRIOBuffer from paths to tracked devices with IMUs",
			"enumname": "vr::Imu_OffScaleFlags",
			"values": [
				{
					"name": "OffScale_AccelX",
					"value": "1"
				},
				{
					"name": "OffScale_AccelY",
					"value": "2"
				},
				{
					"name": "OffScale_AccelZ",
					"value": "4"
				},
				{
					"name": "OffScale_GyroX",
					"value": "8"
				},
				{
					"name": "OffScale_GyroY",
					"value": "16"
				},
				{
					"name": "OffScale_GyroZ",
					"value": "32"
				}
			]
		},
		{
			"doc": "Used for all errors reported by the IVRApplications interface",
			"enumname": "vr::EVRApplicationError",
			"values": [
				{
					"name": "VRApplicationError_None",
					"value": "0"
				},
				{
					"doc": "Only one application can use any given key",
					"name": "VRApplicationError_AppKeyAlreadyExists",
					"value": "100"
				},
				{
					"doc": "the running application does not have a manifest",
					"name": "VRApplicationError_NoManifest",
					"value": "101"
				},
				{
					"doc": "No application is running",
					"name": "VRApplicationError_NoApplication",
					"value": "102"
				},
				{
					"name": "VRApplicationError_InvalidIndex",
					"value": "103"
				},
				{
					"doc": "the application could not be found",
					"name": "VRApplicationError_UnknownApplication",
					"value": "104"
				},
				{
					"doc": "An IPC failure caused the request to fail",
					"name": "VRApplicationError_IPCFailed",
					"value": "105"
				},
				{
					"name": "VRApplicationError_ApplicationAlreadyRunning",
					"value": "106"
				},
				{
					"name": "VRApplicationError_InvalidManifest",
					"value": "107"
				},
				{
					"name": "VRApplicationError_InvalidApplication",
					"value": "108"
				},
				{
					"doc": "the process didn't start",
					"name": "VRApplicationError_LaunchFailed",
					"value": "109"
				},
				{
					"doc": "the system was already starting the same application",
					"name": "VRApplicationError_ApplicationAlreadyStarting",
					"value": "110"
				},
				{
					"doc": "The system was already starting a different application",
					"name": "VRApplicationError_LaunchInProgress",
					"value": "111"
				},
				{
					"name": "VRApplicationError_OldApplicationQuitting",
					"value": "112"
				},
				{
					"name": "VRApplicationError_TransitionAborted",
					"value": "113"
				},
				{
					"doc": "error when you try to call LaunchApplication() on a template type app (use LaunchTemplateApplication)",
					"name": "VRApplicationError_IsTemplate",
					"value": "114"
				},
				{
					"name": "VRApplicationError_SteamVRIsExiting",
					"value": "115"
				},
				{
					"doc": "The provided buffer was too small to fit the requested data",
					"name": "VRApplicationError_BufferTooSmall",
					"value": "200"
				},
				{
					"doc": "The requested property was not set",
					"name": "VRApplicationError_PropertyNotSet",
					"value": "201"
				},
				{
					"name": "VRApplicationError_UnknownProperty",
					"value": "202"
				},
				{
					"name": "VRApplicationError_InvalidParameter",
					"value": "203"
				}
			]
		},
		{
			"enumname": "vr::EVRApplicationProperty",
			"values": [
				{
					"name": "VRApplicationProperty_Name_String",
					"value": "0"
				},
				{
					"name": "VRApplicationProperty_LaunchType_String",
					"value": "11"
				},
				{
					"name": "VRApplicationProperty_WorkingDirectory_String",
					"value": "12"
				},
				{
					"name": "VRApplicationProperty_BinaryPath_String",
					"value": "13"
				},
				{
					"name": "VRApplicationProperty_Arguments_String",
					"value": "14"
				},
				{
					"name": "VRApplicationProperty_URL_String",
					"value": "15"
				},
				{
					"name": "VRApplicationProperty_Description_String",
					"value": "50"
				},
				{
					"name": "VRApplicationProperty_NewsURL_String",
					"value": "51"
				},
				{
					"name": "VRApplicationProperty_ImagePath_String",
					"value": "52"
				},
				{
					"name": "VRApplicationProperty_Source_String",
					"value": "53"
				},
				{
					"name": "VRApplicationProperty_ActionManifestURL_String",
					"value": "54"
				},
				{
					"name": "VRApplicationProperty_IsDashboardOverlay_Bool",
					"value": "60"
				},
				{
					"name": "VRApplicationProperty_IsTemplate_Bool",
					"value": "61"
				},
				{
					"name": "VRApplicationProperty_IsInstanced_Bool",
					"value": "62"
				},
				{
					"name": "VRApplicationProperty_IsInternal_Bool",
					"value": "63"
				},
				{
					"name": "VRApplicationProperty_WantsCompositorPauseInStandby_Bool",
					"value": "64"
				},
				{
					"name": "VRApplicationProperty_IsHidden_Bool",
					"value": "65"
				},
				{
					"name": "VRApplicationProperty_LastLaunchTime_Uint64",
					"value": "70"
				}
			]
		},
		{
			"enumname": "vr::EVRSceneApplicationState",
			"values": [
				{
					"doc": "Scene Application is not running",
					"name": "EVRSceneApplicationState_None",
					"value": "0"
				},
				{
					"doc": "Scene Application is starting",
					"name": "EVRSceneApplicationState_Starting",
					"value": "1"
				},
				{
					"doc": "Scene Application is quitting",
					"name": "EVRSceneApplicationState_Quitting",
					"value": "2"
				},
				{
					"doc": "Scene Application is running, and submitting frames, a custom skybox, or a visible overlay",
					"name": "EVRSceneApplicationState_Running",
					"value": "3"
				},
				{
					"doc": "Scene Application is running, but not drawing anything",
					"name": "EVRSceneApplicationState_Waiting",
					"value": "4"
				}
			]
		},
		{
			"enumname": "vr::ChaperoneCalibrationState",
			"values": [
				{
					"doc": "Chaperone is fully calibrated and working correctly",
					"name": "ChaperoneCalibrationState_OK",
					"value": "1"
				},
				{
					"name": "ChaperoneCalibrationState_Warning",
					"value": "100"
				},
				{
					"doc": "A base station thinks that it might have moved",
					"name": "ChaperoneCalibrationState_Warning_BaseStationMayHaveMoved",
					"value": "101"
				},
				{
					"doc": "There are less base stations than when calibrated",
					"name": "ChaperoneCalibrationState_Warning_BaseStationRemoved",
					"value": "102"
				},
				{
					"doc": "Seated bounds haven't been calibrated for the current tracking center",
					"name": "ChaperoneCalibrationState_Warning_SeatedBoundsInvalid",
					"value": "103"
				},
				{
					"doc": "The UniverseID is invalid",
					"name": "ChaperoneCalibrationState_Error",
					"value": "200"
				},
				{
					"doc": "Tracking center hasn't be calibrated for at least one of the base stations",
					"name": "ChaperoneCalibrationState_Error_BaseStationUninitialized",
					"value": "201"
				},
				{
					"doc": "Tracking center is calibrated, but base stations disagree on the tracking space",
					"name": "ChaperoneCalibrationState_Error_BaseStationConflict",
					"value": "202"
				},
				{
					"doc": "Play Area hasn't been calibrated for the current tracking center",
					"name": "ChaperoneCalibrationState_Error_PlayAreaInvalid",
					"value": "203"
				},
				{
					"doc": "Collision Bounds haven't been calibrated for the current tracking center",
					"name": "ChaperoneCalibrationState_Error_CollisionBoundsInvalid",
					"value": "204"
				}
			]
		},
		{
			"enumname": "vr::EChaperoneConfigFile",
			"values": [
				{
					"doc": "The live chaperone config, used by most applications and games",
					"name": "EChaperoneConfigFile_Live",
					"value": "1"
				},
				{
					"doc": "The temporary chaperone config, used to live-preview collision bounds in room setup",
					"name": "EChaperoneConfigFile_Temp",
					"value": "2"
				}
			]
		},
		{
			"enumname": "vr::EChaperoneImportFlags",
			"values": [
				{
					"name": "EChaperoneImport_BoundsOnly",
					"value": "1"
				}
			]
		},
		{
			"doc": "Errors that can occur with the VR compositor",
			"enumname": "vr::EVRCompositorError",
			"values": [
				{
					"name": "VRCompositorError_None",
					"value": "0"
				},
				{
					"name": "VRCompositorError_RequestFailed",
					"value": "1"
				},
				{
					"name": "VRCompositorError_IncompatibleVersion",
					"value": "100"
				},
				{
					"name": "VRCompositorError_DoNotHaveFocus",
					"value": "101"
				},
				{
					"name": "VRCompositorError_InvalidTexture",
					"value": "102"
				},
				{
					"name": "VRCompositorError_IsNotSceneApplication",
					"value": "103"
				},
				{
					"name": "VRCompositorError_TextureIsOnWrongDevice",
					"value": "104"
				},
				{
					"name": "VRCompositorError_TextureUsesUnsupportedFormat",
					"value": "105"
				},
				{
					"name": "VRCompositorError_SharedTexturesNotSupported",
					"value": "106"
				},
				{
					"name": "VRCompositorError_IndexOutOfRange",
					"value": "107"
				},
				{
					"name": "VRCompositorError_AlreadySubmitted",
					"value": "108"
				},
				{
					"name": "VRCompositorError_InvalidBounds",
					"value": "109"
				},
				{
					"name": "VRCompositorError_AlreadySet",
					"value": "110"
				}
			]
		},
		{
			"doc": "Timing mode passed to SetExplicitTimingMode(); see that function for documentation",
			"enumname": "vr::EVRCompositorTimingMode",
			"values": [
				{
					"name": "VRCompositorTimingMode_Implicit",
					"value": "0"
				},
				{
					"name": "VRCompositorTimingMode_Explicit_RuntimePerformsPostPresentHandoff",
					"value": "1"
				},
				{
					"name": "VRCompositorTimingMode_Explicit_ApplicationPerformsPostPresentHandoff",
					"value": "2"
				}
			]
		},
		{
			"doc": "Types of input supported by VR Overlays",
			"enumname": "vr::VROverlayInputMethod",
			"values": [
				{
					"doc": "No input events will be generated automatically for this overlay",
					"name": "VROverlayInputMethod_None",
					"value": "0"
				},
				{
					"doc": "Tracked controllers will get mouse events automatically",
					"name": "VROverlayInputMethod_Mouse",
					"value": "1"
				}
			]
		},
		{
			"doc": "Allows the caller to figure out which overlay transform getter to call.",
			"enumname": "vr::VROverlayTransformType",
			"values": [
				{
					"name": "VROverlayTransform_Invalid",
					"value": "-1"
				},
				{
					"name": "VROverlayTransform_Absolute",
					"value": "0"
				},
				{
					"name": "VROverlayTransform_TrackedDeviceRelative",
					"value": "1"
				},
				{
					"name": "VROverlayTransform_SystemOverlay",
					"value": "2"
				},
				{
					"name": "VROverlayTransform_TrackedComponent",
					"value": "3"
				},
				{
					"name": "VROverlayTransform_Cursor",
					"value": "4"
				},
				{
					"name": "VROverlayTransform_DashboardTab",
					"value": "5"
				},
				{
					"name": "VROverlayTransform_DashboardThumb",
					"value": "6"
				},
				{
					"name": "VROverlayTransform_Mountable",
					"value": "7"
				}
			]
		},
		{
			"doc": "Overlay control settings",
			"enumname": "vr::VROverlayFlags",
			"values": [
				{
					"doc": "Set this flag on a dashboard overlay to prevent a tab from showing up for that overlay",
					"name": "VROverlayFlags_NoDashboardTab",
					"value": "8"
				},
				{
					"doc": "When this is set the overlay will receive VREvent_ScrollDiscrete events like a mouse wheel.\nRequires mouse input mode.",
					"name": "VROverlayFlags_SendVRDiscreteScrollEvents",
					"value": "64"
				},
				{
					"doc": "Indicates that the overlay would like to receive",
					"name": "VROverlayFlags_SendVRTouchpadEvents",
					"value": "128"
				},
				{
					"doc": "If set this will render a vertical scroll wheel on the primary controller, only needed if not using VROverlayFlags_SendVRScrollEvents but you still want to represent a scroll wheel",
					"name": "VROverlayFlags_ShowTouchPadScrollWheel",
					"value": "256"
				},
				{
					"doc": "If this is set ownership and render access to the overlay are transferred to the new scene process on a call to IVRApplications::LaunchInternalProcess",
					"name": "VROverlayFlags_TransferOwnershipToInternalProcess",
					"value": "512"
				},
				{
					"doc": "If set, renders 50% of the texture in each eye, side by side\nTexture is left/right",
					"name": "VROverlayFlags_SideBySide_Parallel",
					"value": "1024"
				},
				{
					"doc": "Texture is crossed and right/left",
					"name": "VROverlayFlags_SideBySide_Crossed",
					"value": "2048"
				},
				{
					"doc": "Texture is a panorama",
					"name": "VROverlayFlags_Panorama",
					"value": "4096"
				},
				{
					"doc": "Texture is a stereo panorama",
					"name": "VROverlayFlags_StereoPanorama",
					"value": "8192"
				},
				{
					"doc": "If this is set on an overlay owned by the scene application that overlay will be sorted with the \"Other\" overlays on top of all other scene overlays",
					"name": "VROverlayFlags_SortWithNonSceneOverlays",
					"value": "16384"
				},
				{
					"doc": "If set, the overlay will be shown in the dashboard, otherwise it will be hidden.",
					"name": "VROverlayFlags_VisibleInDashboard",
					"value": "32768"
				},
				{
					"doc": "If this is set and the overlay's input method is not none, the system-wide laser mouse mode will be activated whenever this overlay is visible.",
					"name": "VROverlayFlags_MakeOverlaysInteractiveIfVisible",
					"value": "65536"
				},
				{
					"doc": "If this is set the overlay will receive smooth VREvent_ScrollSmooth that emulate trackpad scrolling.\nRequires mouse input mode.",
					"name": "VROverlayFlags_SendVRSmoothScrollEvents",
					"value": "131072"
				},
				{
					"doc": "If this is set, the overlay texture will be protected content, preventing unauthorized reads.",
					"name": "VROverlayFlags_ProtectedContent",
					"value": "262144"
				},
				{
					"doc": "If this is set, the laser mouse splat will not be drawn over this overlay. The overlay will be responsible for drawing its own \"cursor\".",
					"name": "VROverlayFlags_HideLaserIntersection",
					"value": "524288"
				},
				{
					"doc": "If this is set, clicking away from the overlay will cause it to receive a VREvent_Modal_Cancel event.\nThis is ignored for dashboard overlays.",
					"name": "VROverlayFlags_WantsModalBehavior",
					"value": "1048576"
				},
				{
					"doc": "If this is set, alpha composition assumes the texture is pre-multiplied",
					"name": "VROverlayFlags_IsPremultiplied",
					"value": "2097152"
				}
			]
		},
		{
			"enumname": "vr::VRMessageOverlayResponse",
			"values": [
				{
					"name": "VRMessageOverlayResponse_ButtonPress_0",
					"value": "0"
				},
				{
					"name": "VRMessageOverlayResponse_ButtonPress_1",
					"value": "1"
				},
				{
					"name": "VRMessageOverlayResponse_ButtonPress_2",
					"value": "2"
				},
				{
					"name": "VRMessageOverlayResponse_ButtonPress_3",
					"value": "3"
				},
				{
					"name": "VRMessageOverlayResponse_CouldntFindSystemOverlay",
					"value": "4"
				},
				{
					"name": "VRMessageOverlayResponse_CouldntFindOrCreateClientOverlay",
					"value": "5"
				},
				{
					"name": "VRMessageOverlayResponse_ApplicationQuit",
					"value": "6"
				}
			]
		},
		{
			"doc": "Input modes for the Big Picture gamepad text entry",
			"enumname": "vr::EGamepadTextInputMode",
			"values": [
				{
					"name": "k_EGamepadTextInputModeNormal",
					"value": "0"
				},
				{
					"name": "k_EGamepadTextInputModePassword",
					"value": "1"
				},
				{
					"name": "k_EGamepadTextInputModeSubmit",
					"value": "2"
				}
			]
		},
		{
			"doc": "Controls number of allowed lines for the Big Picture gamepad text entry",
			"enumname": "vr::EGamepadTextInputLineMode",
			"values": [
				{
					"name": "k_EGamepadTextInputLineModeSingleLine",
					"value": "0"
				},
				{
					"name": "k_EGamepadTextInputLineModeMultipleLines",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::EVROverlayIntersectionMaskPrimitiveType",
			"values": [
				{
					"name": "OverlayIntersectionPrimitiveType_Rectangle",
					"value": "0"
				},
				{
					"name": "OverlayIntersectionPrimitiveType_Circle",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::EKeyboardFlags",
			"values": [
				{
					"doc": "makes the keyboard send key events immediately instead of accumulating a buffer",
					"name": "KeyboardFlag_Minimal",
					"value": "1"
				},
				{
					"doc": "makes the keyboard take all focus and dismiss when clicking off the panel",
					"name": "KeyboardFlag_Modal",
					"value": "2"
				}
			]
		},
		{
			"enumname": "vr::EDeviceType",
			"values": [
				{
					"doc": "Invalid handle",
					"name": "DeviceType_Invalid",
					"value": "-1"
				},
				{
					"doc": "Handle is an ID3D11Device",
					"name": "DeviceType_DirectX11",
					"value": "0"
				},
				{
					"doc": "Handle is a pointer to a VRVulkanDevice_t structure",
					"name": "DeviceType_Vulkan",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::HeadsetViewMode_t",
			"values": [
				{
					"name": "HeadsetViewMode_Left",
					"value": "0"
				},
				{
					"name": "HeadsetViewMode_Right",
					"value": "1"
				},
				{
					"name": "HeadsetViewMode_Both",
					"value": "2"
				}
			]
		},
		{
			"doc": "Errors that can occur with the VR compositor",
			"enumname": "vr::EVRRenderModelError",
			"values": [
				{
					"name": "VRRenderModelError_None",
					"value": "0"
				},
				{
					"name": "VRRenderModelError_Loading",
					"value": "100"
				},
				{
					"name": "VRRenderModelError_NotSupported",
					"value": "200"
				},
				{
					"name": "VRRenderModelError_InvalidArg",
					"value": "300"
				},
				{
					"name": "VRRenderModelError_InvalidModel",
					"value": "301"
				},
				{
					"name": "VRRenderModelError_NoShapes",
					"value": "302"
				},
				{
					"name": "VRRenderModelError_MultipleShapes",
					"value": "303"
				},
				{
					"name": "VRRenderModelError_TooManyVertices",
					"value": "304"
				},
				{
					"name": "VRRenderModelError_MultipleTextures",
					"value": "305"
				},
				{
					"name": "VRRenderModelError_BufferTooSmall",
					"value": "306"
				},
				{
					"name": "VRRenderModelError_NotEnoughNormals",
					"value": "307"
				},
				{
					"name": "VRRenderModelError_NotEnoughTexCoords",
					"value": "308"
				},
				{
					"name": "VRRenderModelError_InvalidTexture",
					"value": "400"
				}
			]
		},
		{
			"enumname": "vr::EVRRenderModelTextureFormat",
			"values": [
				{
					"doc": "RGBA with 8 bits per channel per pixel. Data size is width * height * 4ub",
					"name": "VRRenderModelTextureFormat_RGBA8_SRGB",
					"value": "0"
				},
				{
					"name": "VRRenderModelTextureFormat_BC2",
					"value": "1"
				},
				{
					"name": "VRRenderModelTextureFormat_BC4",
					"value": "2"
				},
				{
					"name": "VRRenderModelTextureFormat_BC7",
					"value": "3"
				},
				{
					"name": "VRRenderModelTextureFormat_BC7_SRGB",
					"value": "4"
				}
			]
		},
		{
			"doc": "Be aware that the notification type is used as 'priority' to pick the next notification",
			"enumname": "vr::EVRNotificationType",
			"values": [
				{
					"doc": "Transient notifications are automatically hidden after a period of time set by the user.\nThey are used for things like information and chat messages that do not require user interaction.",
					"name": "EVRNotificationType_Transient",
					"value": "0"
				},
				{
					"doc": "Persistent notifications are shown to the user until they are hidden by calling RemoveNotification().\nThey are used for things like phone calls and alarms that require user interaction.",
					"name": "EVRNotificationType_Persistent",
					"value": "1"
				},
				{
					"doc": "System notifications are shown no matter what. It is expected, that the ulUserValue is used as ID.\nIf there is already a system notification in the queue with that ID it is not accepted into the queue to prevent spamming with system notification",
					"name": "EVRNotificationType_Transient_SystemWithUserValue",
					"value": "2"
				}
			]
		},
		{
			"enumname": "vr::EVRNotificationStyle",
			"values": [
				{
					"doc": "Creates a notification with minimal external styling.",
					"name": "EVRNotificationStyle_None",
					"value": "0"
				},
				{
					"doc": "Used for notifications about overlay-level status. In Steam this is used for events like downloads completing.",
					"name": "EVRNotificationStyle_Application",
					"value": "100"
				},
				{
					"doc": "Used for notifications about contacts that are unknown or not available. In Steam this is used for friend invitations and offline friends.",
					"name": "EVRNotificationStyle_Contact_Disabled",
					"value": "200"
				},
				{
					"doc": "Used for notifications about contacts that are available but inactive. In Steam this is used for friends that are online but not playing a game.",
					"name": "EVRNotificationStyle_Contact_Enabled",
					"value": "201"
				},
				{
					"doc": "Used for notifications about contacts that are available and active. In Steam this is used for friends that are online and currently running a game.",
					"name": "EVRNotificationStyle_Contact_Active",
					"value": "202"
				}
			]
		},
		{
			"enumname": "vr::EVRSettingsError",
			"values": [
				{
					"name": "VRSettingsError_None",
					"value": "0"
				},
				{
					"name": "VRSettingsError_IPCFailed",
					"value": "1"
				},
				{
					"name": "VRSettingsError_WriteFailed",
					"value": "2"
				},
				{
					"name": "VRSettingsError_ReadFailed",
					"value": "3"
				},
				{
					"name": "VRSettingsError_JsonParseFailed",
					"value": "4"
				},
				{
					"doc": "This will be returned if the setting does not appear in the appropriate default file and has not been set",
					"name": "VRSettingsError_UnsetSettingHasNoDefault",
					"value": "5"
				}
			]
		},
		{
			"doc": "Errors that can occur with the VR compositor",
			"enumname": "vr::EVRScreenshotError",
			"values": [
				{
					"name": "VRScreenshotError_None",
					"value": "0"
				},
				{
					"name": "VRScreenshotError_RequestFailed",
					"value": "1"
				},
				{
					"name": "VRScreenshotError_IncompatibleVersion",
					"value": "100"
				},
				{
					"name": "VRScreenshotError_NotFound",
					"value": "101"
				},
				{
					"name": "VRScreenshotError_BufferTooSmall",
					"value": "102"
				},
				{
					"name": "VRScreenshotError_ScreenshotAlreadyInProgress",
					"value": "108"
				}
			]
		},
		{
			"enumname": "vr::EVRSkeletalTransformSpace",
			"values": [
				{
					"name": "VRSkeletalTransformSpace_Model",
					"value": "0"
				},
				{
					"name": "VRSkeletalTransformSpace_Parent",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::EVRSkeletalReferencePose",
			"values": [
				{
					"name": "VRSkeletalReferencePose_BindPose",
					"value": "0"
				},
				{
					"name": "VRSkeletalReferencePose_OpenHand",
					"value": "1"
				},
				{
					"name": "VRSkeletalReferencePose_Fist",
					"value": "2"
				},
				{
					"name": "VRSkeletalReferencePose_GripLimit",
					"value": "3"
				}
			]
		},
		{
			"enumname": "vr::EVRFinger",
			"values": [
				{
					"name": "VRFinger_Thumb",
					"value": "0"
				},
				{
					"name": "VRFinger_Index",
					"value": "1"
				},
				{
					"name": "VRFinger_Middle",
					"value": "2"
				},
				{
					"name": "VRFinger_Ring",
					"value": "3"
				},
				{
					"name": "VRFinger_Pinky",
					"value": "4"
				},
				{
					"name": "VRFinger_Count",
					"value": "5"
				}
			]
		},
		{
			"enumname": "vr::EVRFingerSplay",
			"values": [
				{
					"name": "VRFingerSplay_Thumb_Index",
					"value": "0"
				},
				{
					"name": "VRFingerSplay_Index_Middle",
					"value": "1"
				},
				{
					"name": "VRFingerSplay_Middle_Ring",
					"value": "2"
				},
				{
					"name": "VRFingerSplay_Ring_Pinky",
					"value": "3"
				},
				{
					"name": "VRFingerSplay_Count",
					"value": "4"
				}
			]
		},
		{
			"enumname": "vr::EVRSummaryType",
			"values": [
				{
					"doc": "The skeletal summary data will match the animated bone transforms for the action.",
					"name": "VRSummaryType_FromAnimation",
					"value": "0"
				},
				{
					"doc": "The skeletal summary data will include unprocessed data directly from the device when available.\nThis data is generally less latent than the data that is computed from the animations.",
					"name": "VRSummaryType_FromDevice",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::EVRInputFilterCancelType",
			"values": [
				{
					"name": "VRInputFilterCancel_Timers",
					"value": "0"
				},
				{
					"name": "VRInputFilterCancel_Momentum",
					"value": "1"
				}
			]
		},
		{
			"enumname": "vr::EVRInputStringBits",
			"values": [
				{
					"name": "VRInputString_Hand",
					"value": "1"
				},
				{
					"name": "VRInputString_ControllerType",
					"value": "2"
				},
				{
					"name": "VRInputString_InputSource",
					"value": "4"
				},
				{
					"name": "VRInputString_All",
					"value": "-1"
				}
			]
		},
		{
			"enumname": "vr::EIOBufferError",
			"values": [
				{
					"name": "IOBuffer_Success",
					"value": "0"
				},
				{
					"name": "IOBuffer_OperationFailed",
					"value": "100"
				},
				{
					"name": "IOBuffer_InvalidHandle",
					"value": "101"
				},
				{
					"name": "IOBuffer_InvalidArgument",
					"value": "102"
				},
				{
					"name": "IOBuffer_PathExists",
					"value": "103"
				},
				{
					"name": "IOBuffer_PathDoesNotExist",
					"value": "104"
				},
				{
					"name": "IOBuffer_Permission",
					"value": "105"
				}
			]
		},
		{
			"enumname": "vr::EIOBufferMode",
			"values": [
				{
					"name": "IOBufferMode_Read",
					"value": "1"
				},
				{
					"name": "IOBufferMode_Write",
					"value": "2"
				},
				{
					"name": "IOBufferMode_Create",
					"value": "512"
				}
			]
		},
		{
			"enumname": "vr::EVRDebugError",
			"values": [
				{
					"name": "VRDebugError_Success",
					"value": "0"
				},
				{
					"name": "VRDebugError_BadParameter",
					"value": "1"
				}
			]
		}
	],
	"consts": [
		{
			"constname": "k_nDriverNone",
			"consttype": "const uint32_t",
			"constval": "4294967295"
		},
		{
			"constname": "k_unMaxDriverDebugResponseSize",
			"consttype": "const uint32_t",
			"constval": "32768"
		},
		{
			"constname": "k_unTrackedDeviceIndex_Hmd",
			"consttype": "const uint32_t",
			"constval": "0"
		},
		{
			"constname": "k_unMaxTrackedDeviceCount",
			"consttype": "const uint32_t",
			"constval": "64"
		},
		{
			"constname": "k_unTrackedDeviceIndexOther",
			"consttype": "const uint32_t",
			"constval": "4294967294"
		},
		{
			"constname": "k_unTrackedDeviceIndexInvalid",
			"consttype": "const uint32_t",
			"constval": "4294967295"
		},
		{
			"constname": "k_ulInvalidPropertyContainer",
			"consttype": "const PropertyContainerHandle_t",
			"constval": "0"
		},
		{
			"constname": "k_unInvalidPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "0"
		},
		{
			"constname": "k_ulInvalidDriverHandle",
			"consttype": "const PropertyContainerHandle_t",
			"constval": "0"
		},
		{
			"constname": "k_unFloatPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "1"
		},
		{
			"constname": "k_unInt32PropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "2"
		},
		{
			"constname": "k_unUint64PropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "3"
		},
		{
			"constname": "k_unBoolPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "4"
		},
		{
			"constname": "k_unStringPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "5"
		},
		{
			"constname": "k_unErrorPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "6"
		},
		{
			"constname": "k_unDoublePropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "7"
		},
		{
			"constname": "k_unHmdMatrix34PropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "20"
		},
		{
			"constname": "k_unHmdMatrix44PropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "21"
		},
		{
			"constname": "k_unHmdVector3PropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "22"
		},
		{
			"constname": "k_unHmdVector4PropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "23"
		},
		{
			"constname": "k_unHmdVector2PropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "24"
		},
		{
			"constname": "k_unHmdQuadPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "25"
		},
		{
			"constname": "k_unHiddenAreaPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "30"
		},
		{
			"constname": "k_unPathHandleInfoTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "31"
		},
		{
			"constname": "k_unActionPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "32"
		},
		{
			"constname": "k_unInputValuePropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "33"
		},
		{
			"constname": "k_unWildcardPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "34"
		},
		{
			"constname": "k_unHapticVibrationPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "35"
		},
		{
			"constname": "k_unSkeletonPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "36"
		},
		{
			"constname": "k_unSpatialAnchorPosePropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "40"
		},
		{
			"constname": "k_unJsonPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "41"
		},
		{
			"constname": "k_unActiveActionSetPropertyTag",
			"consttype": "const PropertyTypeTag_t",
			"constval": "42"
		},
		{
			"constname": "k_unOpenVRInternalReserved_Start",
			"consttype": "const PropertyTypeTag_t",
			"constval": "1000"
		},
		{
			"constname": "k_unOpenVRInternalReserved_End",
			"consttype": "const PropertyTypeTag_t",
			"constval": "10000"
		},
		{
			"doc": "No string property will ever be longer than this length",
			"constname": "k_unMaxPropertyStringSize",
			"consttype": "const uint32_t",
			"constval": "32768"
		},
		{
			"constname": "k_ulInvalidActionHandle",
			"consttype": "const VRActionHandle_t",
			"constval": "0"
		},
		{
			"constname": "k_ulInvalidActionSetHandle",
			"consttype": "const VRActionSetHandle_t",
			"constval": "0"
		},
		{
			"constname": "k_ulInvalidInputValueHandle",
			"consttype": "const VRInputValueHandle_t",
			"constval": "0"
		},
		{
			"doc": "the number of axes in the controller state",
			"constname": "k_unControllerStateAxisCount",
			"consttype": "const uint32_t",
			"constval": "5"
		},
		{
			"constname": "k_ulOverlayHandleInvalid",
			"consttype": "const VROverlayHandle_t",
			"constval": "0"
		},
		{
			"constname": "k_unMaxDistortionFunctionParameters",
			"consttype": "const uint32_t",
			"constval": "8"
		},
		{
			"constname": "k_unScreenshotHandleInvalid",
			"consttype": "const uint32_t",
			"constval": "0"
		},
		{
			"constname": "IVRSystem_Version",
			"consttype": "const char *const",
			"constval": "IVRSystem_021"
		},
		{
			"constname": "IVRExtendedDisplay_Version",
			"consttype": "const char *const",
			"constval": "IVRExtendedDisplay_001"
		},
		{
			"constname": "IVRTrackedCamera_Version",
			"consttype": "const char *const",
			"constval": "IVRTrackedCamera_006"
		},
		{
			"doc": "The maximum length of an application key",
			"constname": "k_unMaxApplicationKeyLength",
			"consttype": "const uint32_t",
			"constval": "128"
		},
		{
			"doc": "Currently recognized mime types",
			"constname": "k_pch_MimeType_HomeApp",
			"consttype": "const char *const",
			"constval": "vr/home"
		},
		{
			"constname": "k_pch_MimeType_GameTheater",
			"consttype": "const char *const",
			"constval": "vr/game_theater"
		},
		{
			"constname": "IVRApplications_Version",
			"consttype": "const char *const",
			"constval": "IVRApplications_007"
		},
		{
			"constname": "IVRChaperone_Version",
			"consttype": "const char *const",
			"constval": "IVRChaperone_003"
		},
		{
			"constname": "IVRChaperoneSetup_Version",
			"consttype": "const char *const",
			"constval": "IVRChaperoneSetup_006"
		},
		{
			"constname": "IVRCompositor_Version",
			"consttype": "const char *const",
			"constval": "IVRCompositor_026"
		},
		{
			"doc": "The maximum length of an overlay key in bytes, counting the terminating null character.",
			"constname": "k_unVROverlayMaxKeyLength",
			"consttype": "const uint32_t",
			"constval": "128"
		},
		{
			"doc": "The maximum length of an overlay name in bytes, counting the terminating null character.",
			"constname": "k_unVROverlayMaxNameLength",
			"consttype": "const uint32_t",
			"constval": "128"
		},
		{
			"doc": "The maximum number of overlays that can exist in the system at one time.",
			"constname": "k_unMaxOverlayCount",
			"consttype": "const uint32_t",
			"constval": "128"
		},
		{
			"doc": "The maximum number of overlay intersection mask primitives per overlay",
			"constname": "k_unMaxOverlayIntersectionMaskPrimitivesCount",
			"consttype": "const uint32_t",
			"constval": "32"
		},
		{
			"constname": "IVROverlay_Version",
			"consttype": "const char *const",
			"constval": "IVROverlay_024"
		},
		{
			"constname": "IVROverlayView_Version",
			"consttype": "const char *const",
			"constval": "IVROverlayView_003"
		},
		{
			"constname": "k_unHeadsetViewMaxWidth",
			"consttype": "const uint32_t",
			"constval": "3840"
		},
		{
			"constname": "k_unHeadsetViewMaxHeight",
			"consttype": "const uint32_t",
			"constval": "2160"
		},
		{
			"constname": "k_pchHeadsetViewOverlayKey",
			"consttype": "const char *const",
			"constval": "system.HeadsetView"
		},
		{
			"constname": "IVRHeadsetView_Version",
			"consttype": "const char *const",
			"constval": "IVRHeadsetView_001"
		},
		{
			"doc": "Canonical coordinate system of the gdc 2015 wired controller, provided for backwards compatibility",
			"constname": "k_pch_Controller_Component_GDC2015",
			"consttype": "const char *const",
			"constval": "gdc2015"
		},
		{
			"doc": "For controllers with an unambiguous 'base'.",
			"constname": "k_pch_Controller_Component_Base",
			"consttype": "const char *const",
			"constval": "base"
		},
		{
			"doc": "For controllers with an unambiguous 'tip' (used for 'laser-pointing')",
			"constname": "k_pch_Controller_Component_Tip",
			"consttype": "const char *const",
			"constval": "tip"
		},
		{
			"doc": "Neutral, ambidextrous hand-pose when holding controller. On plane between neutrally posed index finger and thumb",
			"constname": "k_pch_Controller_Component_HandGrip",
			"consttype": "const char *const",
			"constval": "handgrip"
		},
		{
			"doc": "1:1 aspect ratio status area, with canonical [0,1] uv mapping",
			"constname": "k_pch_Controller_Component_Status",
			"consttype": "const char *const",
			"constval": "status"
		},
		{
			"constname": "IVRRenderModels_Version",
			"consttype": "const char *const",
			"constval": "IVRRenderModels_006"
		},
		{
			"constname": "k_unNotificationTextMaxSize",
			"consttype": "const uint32_t",
			"constval": "256"
		},
		{
			"constname": "IVRNotifications_Version",
			"consttype": "const char *const",
			"constval": "IVRNotifications_002"
		},
		{
			"constname": "k_unMaxSettingsKeyLength",
			"doc": "The maximum length of a settings key",
			"consttype": "const uint32_t",
			"constval": "128"
		},
		{
			"constname": "IVRSettings_Version",
			"consttype": "const char *const",
			"constval": "IVRSettings_003"
		},
		{
			"constname": "k_pch_SteamVR_Section",
			"consttype": "const char *const",
			"constval": "steamvr"
		},
		{
			"constname": "k_pch_SteamVR_RequireHmd_String",
			"consttype": "const char *const",
			"constval": "requireHmd"
		},
		{
			"constname": "k_pch_SteamVR_ForcedDriverKey_String",
			"consttype": "const char *const",
			"constval": "forcedDriver"
		},
		{
			"constname": "k_pch_SteamVR_ForcedHmdKey_String",
			"consttype": "const char *const",
			"constval": "forcedHmd"
		},
		{
			"constname": "k_pch_SteamVR_DisplayDebug_Bool",
			"consttype": "const char *const",
			"constval": "displayDebug"
		},
		{
			"constname": "k_pch_SteamVR_DebugProcessPipe_String",
			"consttype": "const char *const",
			"constval": "debugProcessPipe"
		},
		{
			"constname": "k_pch_SteamVR_DisplayDebugX_Int32",
			"consttype": "const char *const",
			"constval": "displayDebugX"
		},
		{
			"constname": "k_pch_SteamVR_DisplayDebugY_Int32",
			"consttype": "const char *const",
			"constval": "displayDebugY"
		},
		{
			"constname": "k_pch_SteamVR_SendSystemButtonToAllApps_Bool",
			"consttype": "const char *const",
			"constval": "sendSystemButtonToAllApps"
		},
		{
			"constname": "k_pch_SteamVR_LogLevel_Int32",
			"consttype": "const char *const",
			"constval": "loglevel"
		},
		{
			"constname": "k_pch_SteamVR_IPD_Float",
			"consttype": "const char *const",
			"constval": "ipd"
		},
		{
			"constname": "k_pch_SteamVR_Background_String",
			"consttype": "const char *const",
			"constval": "background"
		},
		{
			"constname": "k_pch_SteamVR_BackgroundUseDomeProjection_Bool",
			"consttype": "const char *const",
			"constval": "backgroundUseDomeProjection"
		},
		{
			"constname": "k_pch_SteamVR_BackgroundCameraHeight_Float",
			"consttype": "const char *const",
			"constval": "backgroundCameraHeight"
		},
		{
			"constname": "k_pch_SteamVR_BackgroundDomeRadius_Float",
			"consttype": "const char *const",
			"constval": "backgroundDomeRadius"
		},
		{
			"constname": "k_pch_SteamVR_GridColor_String",
			"consttype": "const char *const",
			"constval": "gridColor"
		},
		{
			"constname": "k_pch_SteamVR_PlayAreaColor_String",
			"consttype": "const char *const",
			"constval": "playAreaColor"
		},
		{
			"constname": "k_pch_SteamVR_TrackingLossColor_String",
			"consttype": "const char *const",
			"constval": "trackingLossColor"
		},
		{
			"constname": "k_pch_SteamVR_ShowStage_Bool",
			"consttype": "const char *const",
			"constval": "showStage"
		},
		{
			"constname": "k_pch_SteamVR_ActivateMultipleDrivers_Bool",
			"consttype": "const char *const",
			"constval": "activateMultipleDrivers"
		},
		{
			"constname": "k_pch_SteamVR_UsingSpeakers_Bool",
			"consttype": "const char *const",
			"constval": "usingSpeakers"
		},
		{
			"constname": "k_pch_SteamVR_SpeakersForwardYawOffsetDegrees_Float",
			"consttype": "const char *const",
			"constval": "speakersForwardYawOffsetDegrees"
		},
		{
			"constname": "k_pch_SteamVR_BaseStationPowerManagement_Int32",
			"consttype": "const char *const",
			"constval": "basestationPowerManagement"
		},
		{
			"constname": "k_pch_SteamVR_ShowBaseStationPowerManagementTip_Int32",
			"consttype": "const char *const",
			"constval": "ShowBaseStationPowerManagementTip"
		},
		{
			"constname": "k_pch_SteamVR_NeverKillProcesses_Bool",
			"consttype": "const char *const",
			"constval": "neverKillProcesses"
		},
		{
			"constname": "k_pch_SteamVR_SupersampleScale_Float",
			"consttype": "const char *const",
			"constval": "supersampleScale"
		},
		{
			"constname": "k_pch_SteamVR_MaxRecommendedResolution_Int32",
			"consttype": "const char *const",
			"constval": "maxRecommendedResolution"
		},
		{
			"constname": "k_pch_SteamVR_MotionSmoothing_Bool",
			"consttype": "const char *const",
			"constval": "motionSmoothing"
		},
		{
			"constname": "k_pch_SteamVR_MotionSmoothingOverride_Int32",
			"consttype": "const char *const",
			"constval": "motionSmoothingOverride"
		},
		{
			"constname": "k_pch_SteamVR_DisableAsyncReprojection_Bool",
			"consttype": "const char *const",
			"constval": "disableAsync"
		},
		{
			"constname": "k_pch_SteamVR_ForceFadeOnBadTracking_Bool",
			"consttype": "const char *const",
			"constval": "forceFadeOnBadTracking"
		},
		{
			"constname": "k_pch_SteamVR_DefaultMirrorView_Int32",
			"consttype": "const char *const",
			"constval": "mirrorView"
		},
		{
			"constname": "k_pch_SteamVR_ShowLegacyMirrorView_Bool",
			"consttype": "const char *const",
			"constval": "showLegacyMirrorView"
		},
		{
			"constname": "k_pch_SteamVR_MirrorViewVisibility_Bool",
			"consttype": "const char *const",
			"constval": "showMirrorView"
		},
		{
			"constname": "k_pch_SteamVR_MirrorViewDisplayMode_Int32",
			"consttype": "const char *const",
			"constval": "mirrorViewDisplayMode"
		},
		{
			"constname": "k_pch_SteamVR_MirrorViewEye_Int32",
			"consttype": "const char *const",
			"constval": "mirrorViewEye"
		},
		{
			"constname": "k_pch_SteamVR_MirrorViewGeometry_String",
			"consttype": "const char *const",
			"constval": "mirrorViewGeometry"
		},
		{
			"constname": "k_pch_SteamVR_MirrorViewGeometryMaximized_String",
			"consttype": "const char *const",
			"constval": "mirrorViewGeometryMaximized"
		},
		{
			"constname": "k_pch_SteamVR_PerfGraphVisibility_Bool",
			"consttype": "const char *const",
			"constval": "showPerfGraph"
		},
		{
			"constname": "k_pch_SteamVR_StartMonitorFromAppLaunch",
			"consttype": "const char *const",
			"constval": "startMonitorFromAppLaunch"
		},
		{
			"constname": "k_pch_SteamVR_StartCompositorFromAppLaunch_Bool",
			"consttype": "const char *const",
			"constval": "startCompositorFromAppLaunch"
		},
		{
			"constname": "k_pch_SteamVR_StartDashboardFromAppLaunch_Bool",
			"consttype": "const char *const",
			"constval": "startDashboardFromAppLaunch"
		},
		{
			"constname": "k_pch_SteamVR_StartOverlayAppsFromDashboard_Bool",
			"consttype": "const char *const",
			"constval": "startOverlayAppsFromDashboard"
		},
		{
			"constname": "k_pch_SteamVR_EnableHomeApp",
			"consttype": "const char *const",
			"constval": "enableHomeApp"
		},
		{
			"constname": "k_pch_SteamVR_CycleBackgroundImageTimeSec_Int32",
			"consttype": "const char *const",
			"constval": "CycleBackgroundImageTimeSec"
		},
		{
			"constname": "k_pch_SteamVR_RetailDemo_Bool",
			"consttype": "const char *const",
			"constval": "retailDemo"
		},
		{
			"constname": "k_pch_SteamVR_IpdOffset_Float",
			"consttype": "const char *const",
			"constval": "ipdOffset"
		},
		{
			"constname": "k_pch_SteamVR_AllowSupersampleFiltering_Bool",
			"consttype": "const char *const",
			"constval": "allowSupersampleFiltering"
		},
		{
			"constname": "k_pch_SteamVR_SupersampleManualOverride_Bool",
			"consttype": "const char *const",
			"constval": "supersampleManualOverride"
		},
		{
			"constname": "k_pch_SteamVR_EnableLinuxVulkanAsync_Bool",
			"consttype": "const char *const",
			"constval": "enableLinuxVulkanAsync"
		},
		{
			"constname": "k_pch_SteamVR_AllowDisplayLockedMode_Bool",
			"consttype": "const char *const",
			"constval": "allowDisplayLockedMode"
		},
		{
			"constname": "k_pch_SteamVR_HaveStartedTutorialForNativeChaperoneDriver_Bool",
			"consttype": "const char *const",
			"constval": "haveStartedTutorialForNativeChaperoneDriver"
		},
		{
			"constname": "k_pch_SteamVR_ForceWindows32bitVRMonitor",
			"consttype": "const char *const",
			"constval": "forceWindows32BitVRMonitor"
		},
		{
			"constname": "k_pch_SteamVR_DebugInputBinding",
			"consttype": "const char *const",
			"constval": "debugInputBinding"
		},
		{
			"constname": "k_pch_SteamVR_DoNotFadeToGrid",
			"consttype": "const char *const",
			"constval": "doNotFadeToGrid"
		},
		{
			"constname": "k_pch_SteamVR_RenderCameraMode",
			"consttype": "const char *const",
			"constval": "renderCameraMode"
		},
		{
			"constname": "k_pch_SteamVR_EnableSharedResourceJournaling",
			"consttype": "const char *const",
			"constval": "enableSharedResourceJournaling"
		},
		{
			"constname": "k_pch_SteamVR_EnableSafeMode",
			"consttype": "const char *const",
			"constval": "enableSafeMode"
		},
		{
			"constname": "k_pch_SteamVR_PreferredRefreshRate",
			"consttype": "const char *const",
			"constval": "preferredRefreshRate"
		},
		{
			"constname": "k_pch_SteamVR_LastVersionNotice",
			"consttype": "const char *const",
			"constval": "lastVersionNotice"
		},
		{
			"constname": "k_pch_SteamVR_LastVersionNoticeDate",
			"consttype": "const char *const",
			"constval": "lastVersionNoticeDate"
		},
		{
			"constname": "k_pch_SteamVR_HmdDisplayColorGainR_Float",
			"consttype": "const char *const",
			"constval": "hmdDisplayColorGainR"
		},
		{
			"constname": "k_pch_SteamVR_HmdDisplayColorGainG_Float",
			"consttype": "const char *const",
			"constval": "hmdDisplayColorGainG"
		},
		{
			"constname": "k_pch_SteamVR_HmdDisplayColorGainB_Float",
			"consttype": "const char *const",
			"constval": "hmdDisplayColorGainB"
		},
		{
			"constname": "k_pch_SteamVR_CustomIconStyle_String",
			"consttype": "const char *const",
			"constval": "customIconStyle"
		},
		{
			"constname": "k_pch_SteamVR_CustomOffIconStyle_String",
			"consttype": "const char *const",
			"constval": "customOffIconStyle"
		},
		{
			"constname": "k_pch_SteamVR_CustomIconForceUpdate_String",
			"consttype": "const char *const",
			"constval": "customIconForceUpdate"
		},
		{
			"constname": "k_pch_SteamVR_AllowGlobalActionSetPriority",
			"consttype": "const char *const",
			"constval": "globalActionSetPriority"
		},
		{
			"constname": "k_pch_SteamVR_OverlayRenderQuality",
			"consttype": "const char *const",
			"constval": "overlayRenderQuality_2"
		},
		{
			"constname": "k_pch_DirectMode_Section",
			"consttype": "const char *const",
			"constval": "direct_mode"
		},
		{
			"constname": "k_pch_DirectMode_Enable_Bool",
			"consttype": "const char *const",
			"constval": "enable"
		},
		{
			"constname": "k_pch_DirectMode_Count_Int32",
			"consttype": "const char *const",
			"constval": "count"
		},
		{
			"constname": "k_pch_DirectMode_EdidVid_Int32",
			"consttype": "const char *const",
			"constval": "edidVid"
		},
		{
			"constname": "k_pch_DirectMode_EdidPid_Int32",
			"consttype": "const char *const",
			"constval": "edidPid"
		},
		{
			"constname": "k_pch_Lighthouse_Section",
			"consttype": "const char *const",
			"constval": "driver_lighthouse"
		},
		{
			"constname": "k_pch_Lighthouse_DisableIMU_Bool",
			"consttype": "const char *const",
			"constval": "disableimu"
		},
		{
			"constname": "k_pch_Lighthouse_DisableIMUExceptHMD_Bool",
			"consttype": "const char *const",
			"constval": "disableimuexcepthmd"
		},
		{
			"constname": "k_pch_Lighthouse_UseDisambiguation_String",
			"consttype": "const char *const",
			"constval": "usedisambiguation"
		},
		{
			"constname": "k_pch_Lighthouse_DisambiguationDebug_Int32",
			"consttype": "const char *const",
			"constval": "disambiguationdebug"
		},
		{
			"constname": "k_pch_Lighthouse_PrimaryBasestation_Int32",
			"consttype": "const char *const",
			"constval": "primarybasestation"
		},
		{
			"constname": "k_pch_Lighthouse_DBHistory_Bool",
			"consttype": "const char *const",
			"constval": "dbhistory"
		},
		{
			"constname": "k_pch_Lighthouse_EnableBluetooth_Bool",
			"consttype": "const char *const",
			"constval": "enableBluetooth"
		},
		{
			"constname": "k_pch_Lighthouse_PowerManagedBaseStations_String",
			"consttype": "const char *const",
			"constval": "PowerManagedBaseStations"
		},
		{
			"constname": "k_pch_Lighthouse_PowerManagedBaseStations2_String",
			"consttype": "const char *const",
			"constval": "PowerManagedBaseStations2"
		},
		{
			"constname": "k_pch_Lighthouse_InactivityTimeoutForBaseStations_Int32",
			"consttype": "const char *const",
			"constval": "InactivityTimeoutForBaseStations"
		},
		{
			"constname": "k_pch_Lighthouse_EnableImuFallback_Bool",
			"consttype": "const char *const",
			"constval": "enableImuFallback"
		},
		{
			"constname": "k_pch_Null_Section",
			"consttype": "const char *const",
			"constval": "driver_null"
		},
		{
			"constname": "k_pch_Null_SerialNumber_String",
			"consttype": "const char *const",
			"constval": "serialNumber"
		},
		{
			"constname": "k_pch_Null_ModelNumber_String",
			"consttype": "const char *const",
			"constval": "modelNumber"
		},
		{
			"constname": "k_pch_Null_WindowX_Int32",
			"consttype": "const char *const",
			"constval": "windowX"
		},
		{
			"constname": "k_pch_Null_WindowY_Int32",
			"consttype": "const char *const",
			"constval": "windowY"
		},
		{
			"constname": "k_pch_Null_WindowWidth_Int32",
			"consttype": "const char *const",
			"constval": "windowWidth"
		},
		{
			"constname": "k_pch_Null_WindowHeight_Int32",
			"consttype": "const char *const",
			"constval": "windowHeight"
		},
		{
			"constname": "k_pch_Null_RenderWidth_Int32",
			"consttype": "const char *const",
			"constval": "renderWidth"
		},
		{
			"constname": "k_pch_Null_RenderHeight_Int32",
			"consttype": "const char *const",
			"constval": "renderHeight"
		},
		{
			"constname": "k_pch_Null_SecondsFromVsyncToPhotons_Float",
			"consttype": "const char *const",
			"constval": "secondsFromVsyncToPhotons"
		},
		{
			"constname": "k_pch_Null_DisplayFrequency_Float",
			"consttype": "const char *const",
			"constval": "displayFrequency"
		},
		{
			"constname": "k_pch_WindowsMR_Section",
			"consttype": "const char *const",
			"constval": "driver_holographic"
		},
		{
			"constname": "k_pch_UserInterface_Section",
			"consttype": "const char *const",
			"constval": "userinterface"
		},
		{
			"constname": "k_pch_UserInterface_StatusAlwaysOnTop_Bool",
			"consttype": "const char *const",
			"constval": "StatusAlwaysOnTop"
		},
		{
			"constname": "k_pch_UserInterface_MinimizeToTray_Bool",
			"consttype": "const char *const",
			"constval": "MinimizeToTray"
		},
		{
			"constname": "k_pch_UserInterface_HidePopupsWhenStatusMinimized_Bool",
			"consttype": "const char *const",
			"constval": "HidePopupsWhenStatusMinimized"
		},
		{
			"constname": "k_pch_UserInterface_Screenshots_Bool",
			"consttype": "const char *const",
			"constval": "screenshots"
		},
		{
			"constname": "k_pch_UserInterface_ScreenshotType_Int",
			"consttype": "const char *const",
			"constval": "screenshotType"
		},
		{
			"constname": "k_pch_Notifications_Section",
			"consttype": "const char *const",
			"constval": "notifications"
		},
		{
			"constname": "k_pch_Notifications_DoNotDisturb_Bool",
			"consttype": "const char *const",
			"constval": "DoNotDisturb"
		},
		{
			"constname": "k_pch_Keyboard_Section",
			"consttype": "const char *const",
			"constval": "keyboard"
		},
		{
			"constname": "k_pch_Keyboard_TutorialCompletions",
			"consttype": "const char *const",
			"constval": "TutorialCompletions"
		},
		{
			"constname": "k_pch_Keyboard_ScaleX",
			"consttype": "const char *const",
			"constval": "ScaleX"
		},
		{
			"constname": "k_pch_Keyboard_ScaleY",
			"consttype": "const char *const",
			"constval": "ScaleY"
		},
		{
			"constname": "k_pch_Keyboard_OffsetLeftX",
			"consttype": "const char *const",
			"constval": "OffsetLeftX"
		},
		{
			"constname": "k_pch_Keyboard_OffsetRightX",
			"consttype": "const char *const",
			"constval": "OffsetRightX"
		},
		{
			"constname": "k_pch_Keyboard_OffsetY",
			"consttype": "const char *const",
			"constval": "OffsetY"
		},
		{
			"constname": "k_pch_Keyboard_Smoothing",
			"consttype": "const char *const",
			"constval": "Smoothing"
		},
		{
			"constname": "k_pch_Perf_Section",
			"consttype": "const char *const",
			"constval": "perfcheck"
		},
		{
			"constname": "k_pch_Perf_PerfGraphInHMD_Bool",
			"consttype": "const char *const",
			"constval": "perfGraphInHMD"
		},
		{
			"constname": "k_pch_Perf_AllowTimingStore_Bool",
			"consttype": "const char *const",
			"constval": "allowTimingStore"
		},
		{
			"constname": "k_pch_Perf_SaveTimingsOnExit_Bool",
			"consttype": "const char *const",
			"constval": "saveTimingsOnExit"
		},
		{
			"constname": "k_pch_Perf_TestData_Float",
			"consttype": "const char *const",
			"constval": "perfTestData"
		},
		{
			"constname": "k_pch_Perf_GPUProfiling_Bool",
			"consttype": "const char *const",
			"constval": "GPUProfiling"
		},
		{
			"constname": "k_pch_CollisionBounds_Section",
			"consttype": "const char *const",
			"constval": "collisionBounds"
		},
		{
			"constname": "k_pch_CollisionBounds_Style_Int32",
			"consttype": "const char *const",
			"constval": "CollisionBoundsStyle"
		},
		{
			"constname": "k_pch_CollisionBounds_GroundPerimeterOn_Bool",
			"consttype": "const char *const",
			"constval": "CollisionBoundsGroundPerimeterOn"
		},
		{
			"constname": "k_pch_CollisionBounds_CenterMarkerOn_Bool",
			"consttype": "const char *const",
			"constval": "CollisionBoundsCenterMarkerOn"
		},
		{
			"constname": "k_pch_CollisionBounds_PlaySpaceOn_Bool",
			"consttype": "const char *const",
			"constval": "CollisionBoundsPlaySpaceOn"
		},
		{
			"constname": "k_pch_CollisionBounds_FadeDistance_Float",
			"consttype": "const char *const",
			"constval": "CollisionBoundsFadeDistance"
		},
		{
			"constname": "k_pch_CollisionBounds_WallHeight_Float",
			"consttype": "const char *const",
			"constval": "CollisionBoundsWallHeight"
		},
		{
			"constname": "k_pch_CollisionBounds_ColorGammaR_Int32",
			"consttype": "const char *const",
			"constval": "CollisionBoundsColorGammaR"
		},
		{
			"constname": "k_pch_CollisionBounds_ColorGammaG_Int32",
			"consttype": "const char *const",
			"constval": "CollisionBoundsColorGammaG"
		},
		{
			"constname": "k_pch_CollisionBounds_ColorGammaB_Int32",
			"consttype": "const char *const",
			"constval": "CollisionBoundsColorGammaB"
		},
		{
			"constname": "k_pch_CollisionBounds_ColorGammaA_Int32",
			"consttype": "const char *const",
			"constval": "CollisionBoundsColorGammaA"
		},
		{
			"constname": "k_pch_CollisionBounds_EnableDriverImport",
			"consttype": "const char *const",
			"constval": "enableDriverBoundsImport"
		},
		{
			"constname": "k_pch_Camera_Section",
			"consttype": "const char *const",
			"constval": "camera"
		},
		{
			"constname": "k_pch_Camera_EnableCamera_Bool",
			"consttype": "const char *const",
			"constval": "enableCamera"
		},
		{
			"constname": "k_pch_Camera_EnableCameraInDashboard_Bool",
			"consttype": "const char *const",
			"constval": "enableCameraInDashboard"
		},
		{
			"constname": "k_pch_Camera_EnableCameraForCollisionBounds_Bool",
			"consttype": "const char *const",
			"constval": "enableCameraForCollisionBounds"
		},
		{
			"constname": "k_pch_Camera_EnableCameraForRoomView_Bool",
			"consttype": "const char *const",
			"constval": "enableCameraForRoomView"
		},
		{
			"constname": "k_pch_Camera_BoundsColorGammaR_Int32",
			"consttype": "const char *const",
			"constval": "cameraBoundsColorGammaR"
		},
		{
			"constname": "k_pch_Camera_BoundsColorGammaG_Int32",
			"consttype": "const char *const",
			"constval": "cameraBoundsColorGammaG"
		},
		{
			"constname": "k_pch_Camera_BoundsColorGammaB_Int32",
			"consttype": "const char *const",
			"constval": "cameraBoundsColorGammaB"
		},
		{
			"constname": "k_pch_Camera_BoundsColorGammaA_Int32",
			"consttype": "const char *const",
			"constval": "cameraBoundsColorGammaA"
		},
		{
			"constname": "k_pch_Camera_BoundsStrength_Int32",
			"consttype": "const char *const",
			"constval": "cameraBoundsStrength"
		},
		{
			"constname": "k_pch_Camera_RoomViewMode_Int32",
			"consttype": "const char *const",
			"constval": "cameraRoomViewMode"
		},
		{
			"constname": "k_pch_audio_Section",
			"consttype": "const char *const",
			"constval": "audio"
		},
		{
			"constname": "k_pch_audio_SetOsDefaultPlaybackDevice_Bool",
			"consttype": "const char *const",
			"constval": "setOsDefaultPlaybackDevice"
		},
		{
			"constname": "k_pch_audio_EnablePlaybackDeviceOverride_Bool",
			"consttype": "const char *const",
			"constval": "enablePlaybackDeviceOverride"
		},
		{
			"constname": "k_pch_audio_PlaybackDeviceOverride_String",
			"consttype": "const char *const",
			"constval": "playbackDeviceOverride"
		},
		{
			"constname": "k_pch_audio_PlaybackDeviceOverrideName_String",
			"consttype": "const char *const",
			"constval": "playbackDeviceOverrideName"
		},
		{
			"constname": "k_pch_audio_SetOsDefaultRecordingDevice_Bool",
			"consttype": "const char *const",
			"constval": "setOsDefaultRecordingDevice"
		},
		{
			"constname": "k_pch_audio_EnableRecordingDeviceOverride_Bool",
			"consttype": "const char *const",
			"constval": "enableRecordingDeviceOverride"
		},
		{
			"constname": "k_pch_audio_RecordingDeviceOverride_String",
			"consttype": "const char *const",
			"constval": "recordingDeviceOverride"
		},
		{
			"constname": "k_pch_audio_RecordingDeviceOverrideName_String",
			"consttype": "const char *const",
			"constval": "recordingDeviceOverrideName"
		},
		{
			"constname": "k_pch_audio_EnablePlaybackMirror_Bool",
			"consttype": "const char *const",
			"constval": "enablePlaybackMirror"
		},
		{
			"constname": "k_pch_audio_PlaybackMirrorDevice_String",
			"consttype": "const char *const",
			"constval": "playbackMirrorDevice"
		},
		{
			"constname": "k_pch_audio_PlaybackMirrorDeviceName_String",
			"consttype": "const char *const",
			"constval": "playbackMirrorDeviceName"
		},
		{
			"constname": "k_pch_audio_OldPlaybackMirrorDevice_String",
			"consttype": "const char *const",
			"constval": "onPlaybackMirrorDevice"
		},
		{
			"constname": "k_pch_audio_ActiveMirrorDevice_String",
			"consttype": "const char *const",
			"constval": "activePlaybackMirrorDevice"
		},
		{
			"constname": "k_pch_audio_EnablePlaybackMirrorIndependentVolume_Bool",
			"consttype": "const char *const",
			"constval": "enablePlaybackMirrorIndependentVolume"
		},
		{
			"constname": "k_pch_audio_LastHmdPlaybackDeviceId_String",
			"consttype": "const char *const",
			"constval": "lastHmdPlaybackDeviceId"
		},
		{
			"constname": "k_pch_audio_VIVEHDMIGain",
			"consttype": "const char *const",
			"constval": "viveHDMIGain"
		},
		{
			"constname": "k_pch_Power_Section",
			"consttype": "const char *const",
			"constval": "power"
		},
		{
			"constname": "k_pch_Power_PowerOffOnExit_Bool",
			"consttype": "const char *const",
			"constval": "powerOffOnExit"
		},
		{
			"constname": "k_pch_Power_TurnOffScreensTimeout_Float",
			"consttype": "const char *const",
			"constval": "turnOffScreensTimeout"
		},
		{
			"constname": "k_pch_Power_TurnOffControllersTimeout_Float",
			"consttype": "const char *const",
			"constval": "turnOffControllersTimeout"
		},
		{
			"constname": "k_pch_Power_ReturnToWatchdogTimeout_Float",
			"consttype": "const char *const",
			"constval": "returnToWatchdogTimeout"
		},
		{
			"constname": "k_pch_Power_AutoLaunchSteamVROnButtonPress",
			"consttype": "const char *const",
			"constval": "autoLaunchSteamVROnButtonPress"
		},
		{
			"constname": "k_pch_Power_PauseCompositorOnStandby_Bool",
			"consttype": "const char *const",
			"constval": "pauseCompositorOnStandby"
		},
		{
			"constname": "k_pch_Dashboard_Section",
			"consttype": "const char *const",
			"constval": "dashboard"
		},
		{
			"constname": "k_pch_Dashboard_EnableDashboard_Bool",
			"consttype": "const char *const",
			"constval": "enableDashboard"
		},
		{
			"constname": "k_pch_Dashboard_ArcadeMode_Bool",
			"consttype": "const char *const",
			"constval": "arcadeMode"
		},
		{
			"constname": "k_pch_Dashboard_Position",
			"consttype": "const char *const",
			"constval": "position"
		},
		{
			"constname": "k_pch_Dashboard_DesktopScale",
			"consttype": "const char *const",
			"constval": "desktopScale"
		},
		{
			"constname": "k_pch_Dashboard_DashboardScale",
			"consttype": "const char *const",
			"constval": "dashboardScale"
		},
		{
			"constname": "k_pch_modelskin_Section",
			"consttype": "const char *const",
			"constval": "modelskins"
		},
		{
			"constname": "k_pch_Driver_Enable_Bool",
			"consttype": "const char *const",
			"constval": "enable"
		},
		{
			"constname": "k_pch_Driver_BlockedBySafemode_Bool",
			"consttype": "const char *const",
			"constval": "blocked_by_safe_mode"
		},
		{
			"constname": "k_pch_Driver_LoadPriority_Int32",
			"consttype": "const char *const",
			"constval": "loadPriority"
		},
		{
			"constname": "k_pch_WebInterface_Section",
			"consttype": "const char *const",
			"constval": "WebInterface"
		},
		{
			"constname": "k_pch_VRWebHelper_Section",
			"consttype": "const char *const",
			"constval": "VRWebHelper"
		},
		{
			"constname": "k_pch_VRWebHelper_DebuggerEnabled_Bool",
			"consttype": "const char *const",
			"constval": "DebuggerEnabled"
		},
		{
			"constname": "k_pch_VRWebHelper_DebuggerPort_Int32",
			"consttype": "const char *const",
			"constval": "DebuggerPort"
		},
		{
			"constname": "k_pch_TrackingOverride_Section",
			"consttype": "const char *const",
			"constval": "TrackingOverrides"
		},
		{
			"constname": "k_pch_App_BindingAutosaveURLSuffix_String",
			"consttype": "const char *const",
			"constval": "AutosaveURL"
		},
		{
			"constname": "k_pch_App_BindingLegacyAPISuffix_String",
			"consttype": "const char *const",
			"constval": "_legacy"
		},
		{
			"constname": "k_pch_App_BindingSteamVRInputAPISuffix_String",
			"consttype": "const char *const",
			"constval": "_steamvrinput"
		},
		{
			"constname": "k_pch_App_BindingCurrentURLSuffix_String",
			"consttype": "const char *const",
			"constval": "CurrentURL"
		},
		{
			"constname": "k_pch_App_BindingPreviousURLSuffix_String",
			"consttype": "const char *const",
			"constval": "PreviousURL"
		},
		{
			"constname": "k_pch_App_NeedToUpdateAutosaveSuffix_Bool",
			"consttype": "const char *const",
			"constval": "NeedToUpdateAutosave"
		},
		{
			"constname": "k_pch_App_DominantHand_Int32",
			"consttype": "const char *const",
			"constval": "DominantHand"
		},
		{
			"constname": "k_pch_Trackers_Section",
			"consttype": "const char *const",
			"constval": "trackers"
		},
		{
			"constname": "k_pch_DesktopUI_Section",
			"consttype": "const char *const",
			"constval": "DesktopUI"
		},
		{
			"constname": "k_pch_LastKnown_Section",
			"consttype": "const char *const",
			"constval": "LastKnown"
		},
		{
			"constname": "k_pch_LastKnown_HMDManufacturer_String",
			"consttype": "const char *const",
			"constval": "HMDManufacturer"
		},
		{
			"constname": "k_pch_LastKnown_HMDModel_String",
			"consttype": "const char *const",
			"constval": "HMDModel"
		},
		{
			"constname": "k_pch_DismissedWarnings_Section",
			"consttype": "const char *const",
			"constval": "DismissedWarnings"
		},
		{
			"constname": "k_pch_Input_Section",
			"consttype": "const char *const",
			"constval": "input"
		},
		{
			"constname": "k_pch_Input_LeftThumbstickRotation_Float",
			"consttype": "const char *const",
			"constval": "leftThumbstickRotation"
		},
		{
			"constname": "k_pch_Input_RightThumbstickRotation_Float",
			"consttype": "const char *const",
			"constval": "rightThumbstickRotation"
		},
		{
			"constname": "k_pch_Input_ThumbstickDeadzone_Float",
			"consttype": "const char *const",
			"constval": "thumbstickDeadzone"
		},
		{
			"constname": "k_pch_GpuSpeed_Section",
			"consttype": "const char *const",
			"constval": "GpuSpeed"
		},
		{
			"constname": "IVRScreenshots_Version",
			"consttype": "const char *const",
			"constval": "IVRScreenshots_001"
		},
		{
			"constname": "IVRResources_Version",
			"consttype": "const char *const",
			"constval": "IVRResources_001"
		},
		{
			"constname": "IVRDriverManager_Version",
			"consttype": "const char *const",
			"constval": "IVRDriverManager_001"
		},
		{
			"doc": "Maximum number of characters in an action name, including the trailing null",
			"constname": "k_unMaxActionNameLength",
			"consttype": "const uint32_t",
			"constval": "64"
		},
		{
			"doc": "Maximum number of characters in an action set name, including the trailing null",
			"constname": "k_unMaxActionSetNameLength",
			"consttype": "const uint32_t",
			"constval": "64"
		},
		{
			"doc": "Maximum number of origins for an action",
			"constname": "k_unMaxActionOriginCount",
			"consttype": "const uint32_t",
			"constval": "16"
		},
		{
			"doc": "Maximum number of characters in a bone name, including the trailing null",
			"constname": "k_unMaxBoneNameLength",
			"consttype": "const uint32_t",
			"constval": "32"
		},
		{
			"doc": "* Experimental global action set priority *\n These constants are part of the experimental support in SteamVR for overlay apps selectively overriding input in the base scene application. This may be useful for overlay applications that need to use part or all of a controller without taking away all input to the game. This system must be enabled by the  \"Experimental overlay input overrides\" setting in the developer section of  SteamVR settings.\n\nTo use this system, set the nPriority field of an action set to any number in this range. ",
			"constname": "k_nActionSetOverlayGlobalPriorityMin",
			"consttype": "const int32_t",
			"constval": "16777216"
		},
		{
			"constname": "k_nActionSetOverlayGlobalPriorityMax",
			"consttype": "const int32_t",
			"constval": "33554431"
		},
		{
			"constname": "k_nActionSetPriorityReservedMin",
			"consttype": "const int32_t",
			"constval": "33554432"
		},
		{
			"constname": "IVRInput_Version",
			"consttype": "const char *const",
			"constval": "IVRInput_010"
		},
		{
			"constname": "k_ulInvalidIOBufferHandle",
			"consttype": "const uint64_t",
			"constval": "0"
		},
		{
			"constname": "IVRIOBuffer_Version",
			"consttype": "const char *",
			"constval": "IVRIOBuffer_002"
		},
		{
			"constname": "k_ulInvalidSpatialAnchorHandle",
			"consttype": "const SpatialAnchorHandle_t",
			"constval": "0"
		},
		{
			"constname": "IVRSpatialAnchors_Version",
			"consttype": "const char *const",
			"constval": "IVRSpatialAnchors_001"
		},
		{
			"constname": "IVRDebug_Version",
			"consttype": "const char *const",
			"constval": "IVRDebug_001"
		}
	],
	"structs": [
		{
			"doc": "right-handed system\n+y is up\n+x is to the right\n-z is forward\nDistance unit is  meters",
			"align": 8,
			"struct": "vr::HmdMatrix34_t",
			"fields": [
				{
					"fieldname": "m",
					"fieldtype": "float [3][4]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdMatrix33_t",
			"fields": [
				{
					"fieldname": "m",
					"fieldtype": "float [3][3]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdMatrix44_t",
			"fields": [
				{
					"fieldname": "m",
					"fieldtype": "float [4][4]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdVector3_t",
			"fields": [
				{
					"fieldname": "v",
					"fieldtype": "float [3]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdVector4_t",
			"fields": [
				{
					"fieldname": "v",
					"fieldtype": "float [4]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdVector3d_t",
			"fields": [
				{
					"fieldname": "v",
					"fieldtype": "double [3]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdVector2_t",
			"fields": [
				{
					"fieldname": "v",
					"fieldtype": "float [2]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdQuaternion_t",
			"fields": [
				{
					"fieldname": "w",
					"fieldtype": "double"
				},
				{
					"fieldname": "x",
					"fieldtype": "double"
				},
				{
					"fieldname": "y",
					"fieldtype": "double"
				},
				{
					"fieldname": "z",
					"fieldtype": "double"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdQuaternionf_t",
			"fields": [
				{
					"fieldname": "w",
					"fieldtype": "float"
				},
				{
					"fieldname": "x",
					"fieldtype": "float"
				},
				{
					"fieldname": "y",
					"fieldtype": "float"
				},
				{
					"fieldname": "z",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdColor_t",
			"fields": [
				{
					"fieldname": "r",
					"fieldtype": "float"
				},
				{
					"fieldname": "g",
					"fieldtype": "float"
				},
				{
					"fieldname": "b",
					"fieldtype": "float"
				},
				{
					"fieldname": "a",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdQuad_t",
			"fields": [
				{
					"fieldname": "vCorners",
					"fieldtype": "struct vr::HmdVector3_t [4]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::HmdRect2_t",
			"fields": [
				{
					"fieldname": "vTopLeft",
					"fieldtype": "struct vr::HmdVector2_t"
				},
				{
					"fieldname": "vBottomRight",
					"fieldtype": "struct vr::HmdVector2_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Used to return the post-distortion UVs for each color channel.\nUVs range from 0 to 1 with 0,0 in the upper left corner of the source render target. The 0,0 to 1,1 range covers a single eye.",
			"struct": "vr::DistortionCoordinates_t",
			"fields": [
				{
					"fieldname": "rfRed",
					"fieldtype": "float [2]"
				},
				{
					"fieldname": "rfGreen",
					"fieldtype": "float [2]"
				},
				{
					"fieldname": "rfBlue",
					"fieldtype": "float [2]"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::Texture_t",
			"fields": [
				{
					"fieldname": "handle",
					"fieldtype": "void *"
				},
				{
					"fieldname": "eType",
					"fieldtype": "enum vr::ETextureType"
				},
				{
					"fieldname": "eColorSpace",
					"fieldtype": "enum vr::EColorSpace"
				}
			]
		},
		{
			"align": 8,
			"doc": "describes a single pose for a tracked object",
			"struct": "vr::TrackedDevicePose_t",
			"fields": [
				{
					"fieldname": "mDeviceToAbsoluteTracking",
					"fieldtype": "struct vr::HmdMatrix34_t"
				},
				{
					"doc": "velocity in tracker space in m/s",
					"fieldname": "vVelocity",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"doc": "angular velocity in radians/s (?)",
					"fieldname": "vAngularVelocity",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"fieldname": "eTrackingResult",
					"fieldtype": "enum vr::ETrackingResult"
				},
				{
					"fieldname": "bPoseIsValid",
					"fieldtype": "_Bool"
				},
				{
					"doc": "This indicates that there is a device connected for this spot in the pose array.\nIt could go from true to false if the user unplugs the device.",
					"fieldname": "bDeviceIsConnected",
					"fieldtype": "_Bool"
				}
			]
		},
		{
			"align": 8,
			"doc": "Allows the application to control what part of the provided texture will be used in the frame buffer.",
			"struct": "vr::VRTextureBounds_t",
			"fields": [
				{
					"fieldname": "uMin",
					"fieldtype": "float"
				},
				{
					"fieldname": "vMin",
					"fieldtype": "float"
				},
				{
					"fieldname": "uMax",
					"fieldtype": "float"
				},
				{
					"fieldname": "vMax",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"doc": "Allows specifying pose used to render provided scene texture (if different from value returned by WaitGetPoses).",
			"extends": "vr::Texture_t",
			"struct": "vr::VRTextureWithPose_t",
			"fields": [
				{
					"doc": "Actual pose used to render scene textures.",
					"fieldname": "mDeviceToAbsoluteTracking",
					"fieldtype": "struct vr::HmdMatrix34_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VRTextureDepthInfo_t",
			"fields": [
				{
					"fieldname": "handle",
					"fieldtype": "void *"
				},
				{
					"fieldname": "mProjection",
					"fieldtype": "struct vr::HmdMatrix44_t"
				},
				{
					"doc": "0..1",
					"fieldname": "vRange",
					"fieldtype": "struct vr::HmdVector2_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VRTextureWithDepth_t",
			"extends": "vr::Texture_t",
			"fields": [
				{
					"fieldname": "depth",
					"fieldtype": "struct vr::VRTextureDepthInfo_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VRTextureWithPoseAndDepth_t",
			"extends": "vr::VRTextureWithPose_t",
			"fields": [
				{
					"fieldname": "depth",
					"fieldtype": "struct vr::VRTextureDepthInfo_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Data required for passing Vulkan textures to IVRCompositor::Submit.\nBe sure to call OpenVR_Shutdown before destroying these resources.\nPlease see https://github.com/ValveSoftware/openvr/wiki/Vulkan for Vulkan-specific documentation",
			"struct": "vr::VRVulkanTextureData_t",
			"fields": [
				{
					"doc": "VkImage",
					"fieldname": "m_nImage",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "m_pDevice",
					"fieldtype": "struct VkDevice_T *"
				},
				{
					"fieldname": "m_pPhysicalDevice",
					"fieldtype": "struct VkPhysicalDevice_T *"
				},
				{
					"fieldname": "m_pInstance",
					"fieldtype": "struct VkInstance_T *"
				},
				{
					"fieldname": "m_pQueue",
					"fieldtype": "struct VkQueue_T *"
				},
				{
					"fieldname": "m_nQueueFamilyIndex",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nWidth",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nHeight",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nFormat",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nSampleCount",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Data required for passing D3D12 textures to IVRCompositor::Submit.\nBe sure to call OpenVR_Shutdown before destroying these resources.",
			"struct": "vr::D3D12TextureData_t",
			"fields": [
				{
					"fieldname": "m_pResource",
					"fieldtype": "struct ID3D12Resource *"
				},
				{
					"fieldname": "m_pCommandQueue",
					"fieldtype": "struct ID3D12CommandQueue *"
				},
				{
					"fieldname": "m_nNodeMask",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "used for controller button events",
			"struct": "vr::VREvent_Controller_t",
			"fields": [
				{
					"doc": "EVRButtonId enum",
					"fieldname": "button",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "used for simulated mouse events in overlay space",
			"struct": "vr::VREvent_Mouse_t",
			"fields": [
				{
					"doc": "co-ords are in GL space, bottom left of the texture is 0,0",
					"fieldname": "x",
					"fieldtype": "float"
				},
				{
					"doc": "co-ords are in GL space, bottom left of the texture is 0,0",
					"fieldname": "y",
					"fieldtype": "float"
				},
				{
					"doc": "EVRMouseButton enum",
					"fieldname": "button",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "used for simulated mouse wheel scroll",
			"struct": "vr::VREvent_Scroll_t",
			"fields": [
				{
					"fieldname": "xdelta",
					"fieldtype": "float"
				},
				{
					"fieldname": "ydelta",
					"fieldtype": "float"
				},
				{
					"fieldname": "unused",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "For scrolling on an overlay with laser mouse, this is the overlay's vertical size relative to the overlay height. Range: [0,1]",
					"fieldname": "viewportscale",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"doc": "when in mouse input mode you can receive data from the touchpad, these events are only sent if the users finger is on the touchpad (or just released from it). These events are sent to overlays with the VROverlayFlags_SendVRTouchpadEvents flag set.",
			"struct": "vr::VREvent_TouchPadMove_t",
			"fields": [
				{
					"doc": "true if the users finger is detected on the touch pad",
					"fieldname": "bFingerDown",
					"fieldtype": "_Bool"
				},
				{
					"doc": "How long the finger has been down in seconds",
					"fieldname": "flSecondsFingerDown",
					"fieldtype": "float"
				},
				{
					"doc": "These values indicate the starting finger position (so you can do some basic swipe stuff)",
					"fieldname": "fValueXFirst",
					"fieldtype": "float"
				},
				{
					"doc": "These values indicate the starting finger position (so you can do some basic swipe stuff)",
					"fieldname": "fValueYFirst",
					"fieldtype": "float"
				},
				{
					"doc": "This is the raw sampled coordinate without deadzoning",
					"fieldname": "fValueXRaw",
					"fieldtype": "float"
				},
				{
					"doc": "This is the raw sampled coordinate without deadzoning",
					"fieldname": "fValueYRaw",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"doc": "notification related events. Details will still change at this point",
			"struct": "vr::VREvent_Notification_t",
			"fields": [
				{
					"fieldname": "ulUserValue",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "notificationId",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Used for events about processes",
			"struct": "vr::VREvent_Process_t",
			"fields": [
				{
					"fieldname": "pid",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "oldPid",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "bForced",
					"fieldtype": "_Bool"
				},
				{
					"doc": "If the associated event was triggered by a connection loss",
					"fieldname": "bConnectionLost",
					"fieldtype": "_Bool"
				}
			]
		},
		{
			"align": 8,
			"doc": "Used for a few events about overlays",
			"struct": "vr::VREvent_Overlay_t",
			"fields": [
				{
					"fieldname": "overlayHandle",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "devicePath",
					"fieldtype": "uint64_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Used for a few events about overlays",
			"struct": "vr::VREvent_Status_t",
			"fields": [
				{
					"doc": "EVRState enum",
					"fieldname": "statusState",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Used for keyboard events",
			"struct": "vr::VREvent_Keyboard_t",
			"fields": [
				{
					"doc": "Up to 11 bytes of new input",
					"fieldname": "cNewInput",
					"fieldtype": "char [8]"
				},
				{
					"doc": "Possible flags about the new input",
					"fieldname": "uUserValue",
					"fieldtype": "uint64_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_Ipd_t",
			"fields": [
				{
					"fieldname": "ipdMeters",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_Chaperone_t",
			"fields": [
				{
					"fieldname": "m_nPreviousUniverse",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "m_nCurrentUniverse",
					"fieldtype": "uint64_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Not actually used for any events",
			"struct": "vr::VREvent_Reserved_t",
			"fields": [
				{
					"fieldname": "reserved0",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "reserved1",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "reserved2",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "reserved3",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "reserved4",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "reserved5",
					"fieldtype": "uint64_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_PerformanceTest_t",
			"fields": [
				{
					"fieldname": "m_nFidelityLevel",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_SeatedZeroPoseReset_t",
			"fields": [
				{
					"fieldname": "bResetBySystemMenu",
					"fieldtype": "_Bool"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_Screenshot_t",
			"fields": [
				{
					"fieldname": "handle",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "type",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_ScreenshotProgress_t",
			"fields": [
				{
					"fieldname": "progress",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_ApplicationLaunch_t",
			"fields": [
				{
					"fieldname": "pid",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "unArgsHandle",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_EditingCameraSurface_t",
			"fields": [
				{
					"fieldname": "overlayHandle",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "nVisualMode",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_MessageOverlay_t",
			"fields": [
				{
					"doc": "vr::VRMessageOverlayResponse enum",
					"fieldname": "unVRMessageOverlayResponse",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_Property_t",
			"fields": [
				{
					"fieldname": "container",
					"fieldtype": "PropertyContainerHandle_t"
				},
				{
					"fieldname": "prop",
					"fieldtype": "enum vr::ETrackedDeviceProperty"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_HapticVibration_t",
			"fields": [
				{
					"doc": "property container handle of the device with the haptic component",
					"fieldname": "containerHandle",
					"fieldtype": "uint64_t"
				},
				{
					"doc": "Which haptic component needs to vibrate",
					"fieldname": "componentHandle",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "fDurationSeconds",
					"fieldtype": "float"
				},
				{
					"fieldname": "fFrequency",
					"fieldtype": "float"
				},
				{
					"fieldname": "fAmplitude",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_WebConsole_t",
			"fields": [
				{
					"fieldname": "webConsoleHandle",
					"fieldtype": "WebConsoleHandle_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_InputBindingLoad_t",
			"fields": [
				{
					"fieldname": "ulAppContainer",
					"fieldtype": "vr::PropertyContainerHandle_t"
				},
				{
					"fieldname": "pathMessage",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathUrl",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathControllerType",
					"fieldtype": "uint64_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_InputActionManifestLoad_t",
			"fields": [
				{
					"fieldname": "pathAppKey",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathMessage",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathMessageParam",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathManifestPath",
					"fieldtype": "uint64_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_SpatialAnchor_t",
			"fields": [
				{
					"fieldname": "unHandle",
					"fieldtype": "SpatialAnchorHandle_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_ProgressUpdate_t",
			"fields": [
				{
					"fieldname": "ulApplicationPropertyContainer",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathDevice",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathInputSource",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathProgressAction",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "pathIcon",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "fProgress",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_ShowUI_t",
			"fields": [
				{
					"fieldname": "eType",
					"fieldtype": "enum vr::EShowUIType"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_ShowDevTools_t",
			"fields": [
				{
					"fieldname": "nBrowserIdentifier",
					"fieldtype": "int32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::VREvent_HDCPError_t",
			"fields": [
				{
					"fieldname": "eCode",
					"fieldtype": "enum vr::EHDCPError"
				}
			]
		},
		{
			"struct": "vr::(anonymous)",
			"fields": [
				{
					"fieldname": "reserved",
					"fieldtype": "struct vr::VREvent_Reserved_t"
				},
				{
					"fieldname": "controller",
					"fieldtype": "struct vr::VREvent_Controller_t"
				},
				{
					"fieldname": "mouse",
					"fieldtype": "struct vr::VREvent_Mouse_t"
				},
				{
					"fieldname": "scroll",
					"fieldtype": "struct vr::VREvent_Scroll_t"
				},
				{
					"fieldname": "process",
					"fieldtype": "struct vr::VREvent_Process_t"
				},
				{
					"fieldname": "notification",
					"fieldtype": "struct vr::VREvent_Notification_t"
				},
				{
					"fieldname": "overlay",
					"fieldtype": "struct vr::VREvent_Overlay_t"
				},
				{
					"fieldname": "status",
					"fieldtype": "struct vr::VREvent_Status_t"
				},
				{
					"fieldname": "keyboard",
					"fieldtype": "struct vr::VREvent_Keyboard_t"
				},
				{
					"fieldname": "ipd",
					"fieldtype": "struct vr::VREvent_Ipd_t"
				},
				{
					"fieldname": "chaperone",
					"fieldtype": "struct vr::VREvent_Chaperone_t"
				},
				{
					"fieldname": "performanceTest",
					"fieldtype": "struct vr::VREvent_PerformanceTest_t"
				},
				{
					"fieldname": "touchPadMove",
					"fieldtype": "struct vr::VREvent_TouchPadMove_t"
				},
				{
					"fieldname": "seatedZeroPoseReset",
					"fieldtype": "struct vr::VREvent_SeatedZeroPoseReset_t"
				},
				{
					"fieldname": "screenshot",
					"fieldtype": "struct vr::VREvent_Screenshot_t"
				},
				{
					"fieldname": "screenshotProgress",
					"fieldtype": "struct vr::VREvent_ScreenshotProgress_t"
				},
				{
					"fieldname": "applicationLaunch",
					"fieldtype": "struct vr::VREvent_ApplicationLaunch_t"
				},
				{
					"fieldname": "cameraSurface",
					"fieldtype": "struct vr::VREvent_EditingCameraSurface_t"
				},
				{
					"fieldname": "messageOverlay",
					"fieldtype": "struct vr::VREvent_MessageOverlay_t"
				},
				{
					"fieldname": "property",
					"fieldtype": "struct vr::VREvent_Property_t"
				},
				{
					"fieldname": "hapticVibration",
					"fieldtype": "struct vr::VREvent_HapticVibration_t"
				},
				{
					"fieldname": "webConsole",
					"fieldtype": "struct vr::VREvent_WebConsole_t"
				},
				{
					"fieldname": "inputBinding",
					"fieldtype": "struct vr::VREvent_InputBindingLoad_t"
				},
				{
					"fieldname": "actionManifest",
					"fieldtype": "struct vr::VREvent_InputActionManifestLoad_t"
				},
				{
					"fieldname": "spatialAnchor",
					"fieldtype": "struct vr::VREvent_SpatialAnchor_t"
				},
				{
					"fieldname": "progressUpdate",
					"fieldtype": "struct vr::VREvent_ProgressUpdate_t"
				},
				{
					"fieldname": "showUi",
					"fieldtype": "struct vr::VREvent_ShowUI_t"
				},
				{
					"fieldname": "showDevTools",
					"fieldtype": "struct vr::VREvent_ShowDevTools_t"
				},
				{
					"fieldname": "hdcpError",
					"fieldtype": "struct vr::VREvent_HDCPError_t"
				}
			]
		},
		{
			"_hack_doc": "This structure was originally defined mis-packed on Linux, preserved for compatibility.",
			"_hack": "pack(4) on linux and apple, otherwise pack(8)",
			"align": "hack",
			"doc": "An event posted by the server to all running applications",
			"struct": "vr::VREvent_t",
			"fields": [
				{
					"doc": "EVREventType enum",
					"fieldname": "eventType",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "trackedDeviceIndex",
					"fieldtype": "TrackedDeviceIndex_t"
				},
				{
					"fieldname": "eventAgeSeconds",
					"fieldtype": "float"
				},
				{
					"doc": "event data must be the end of the struct as its size is variable",
					"fieldname": "data",
					"fieldtype": "VREvent_Data_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Describes state information about a render-model component, including transforms and other dynamic properties",
			"struct": "vr::RenderModel_ComponentState_t",
			"fields": [
				{
					"doc": "Transform required when drawing the component render model",
					"fieldname": "mTrackingToComponentRenderModel",
					"fieldtype": "struct vr::HmdMatrix34_t"
				},
				{
					"doc": "Transform available for attaching to a local component coordinate system (-Z out from surface )",
					"fieldname": "mTrackingToComponentLocal",
					"fieldtype": "struct vr::HmdMatrix34_t"
				},
				{
					"fieldname": "uProperties",
					"fieldtype": "VRComponentProperties"
				}
			]
		},
		{
			"align": 8,
			"doc": "The mesh to draw into the stencil (or depth) buffer to perform early stencil (or depth) kills of pixels that will never appear on the HMD. This mesh draws on all the pixels that will be hidden after distortion.\n\nIf the HMD does not provide a visible area mesh pVertexData will be NULL and unTriangleCount will be 0.",
			"struct": "vr::HiddenAreaMesh_t",
			"fields": [
				{
					"fieldname": "pVertexData",
					"fieldtype": "const struct vr::HmdVector2_t *"
				},
				{
					"fieldname": "unTriangleCount",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "contains information about one axis on the controller",
			"struct": "vr::VRControllerAxis_t",
			"fields": [
				{
					"doc": "Ranges from -1.0 to 1.0 for joysticks and track pads. Ranges from 0.0 to 1.0 for triggers were 0 is fully released.",
					"fieldname": "x",
					"fieldtype": "float"
				},
				{
					"doc": "Ranges from -1.0 to 1.0 for joysticks and track pads. Is always 0.0 for triggers.",
					"fieldname": "y",
					"fieldtype": "float"
				}
			]
		},
		{
			"_hack_doc": "This structure was originally defined mis-packed on Linux, preserved for compatibility.",
			"_hack": "pack(4) on linux and apple, otherwise pack(8)",
			"align": "hack",
			"doc": "Holds all the state of a controller at one moment in time.",
			"struct": "vr::VRControllerState001_t",
			"fields": [
				{
					"doc": "If packet num matches that on your prior call, then the controller state hasn't been changed since your last call and there is no need to process it",
					"fieldname": "unPacketNum",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "bit flags for each of the buttons. Use ButtonMaskFromId to turn an ID into a mask",
					"fieldname": "ulButtonPressed",
					"fieldtype": "uint64_t"
				},
				{
					"fieldname": "ulButtonTouched",
					"fieldtype": "uint64_t"
				},
				{
					"doc": "Axis data for the controller's analog inputs",
					"fieldname": "rAxis",
					"fieldtype": "struct vr::VRControllerAxis_t [5]"
				}
			]
		},
		{
			"align": 8,
			"doc": "Holds the transform for a single bone",
			"struct": "vr::VRBoneTransform_t",
			"fields": [
				{
					"fieldname": "position",
					"fieldtype": "struct vr::HmdVector4_t"
				},
				{
					"fieldname": "orientation",
					"fieldtype": "struct vr::HmdQuaternionf_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::CameraVideoStreamFrameHeader_t",
			"fields": [
				{
					"fieldname": "eFrameType",
					"fieldtype": "enum vr::EVRTrackedCameraFrameType"
				},
				{
					"fieldname": "nWidth",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "nHeight",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "nBytesPerPixel",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "nFrameSequence",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "trackedDevicePose",
					"fieldtype": "struct vr::TrackedDevicePose_t"
				},
				{
					"doc": "mid-point of the exposure of the image in host system ticks",
					"fieldname": "ulFrameExposureTime",
					"fieldtype": "uint64_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Provides a single frame's timing information to the app",
			"struct": "vr::Compositor_FrameTiming",
			"fields": [
				{
					"doc": "Set to sizeof( Compositor_FrameTiming )",
					"fieldname": "m_nSize",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nFrameIndex",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "number of times this frame was presented",
					"fieldname": "m_nNumFramePresents",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "number of times this frame was presented on a vsync other than it was originally predicted to",
					"fieldname": "m_nNumMisPresented",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "number of additional times previous frame was scanned out",
					"fieldname": "m_nNumDroppedFrames",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nReprojectionFlags",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "Absolute time reference for comparing frames.  This aligns with the vsync that running start is relative to.",
					"fieldname": "m_flSystemTimeInSeconds",
					"fieldtype": "double"
				},
				{
					"doc": "These times may include work from other processes due to OS scheduling.\nThe fewer packets of work these are broken up into, the less likely this will happen.\nGPU work can be broken up by calling Flush.  This can sometimes be useful to get the GPU started processing that work earlier in the frame.\ntime spent rendering the scene (gpu work submitted between WaitGetPoses and second Submit)",
					"fieldname": "m_flPreSubmitGpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "additional time spent rendering by application (e.g. companion window)",
					"fieldname": "m_flPostSubmitGpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "time between work submitted immediately after present (ideally vsync) until the end of compositor submitted work",
					"fieldname": "m_flTotalRenderGpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "time spend performing distortion correction, rendering chaperone, overlays, etc.",
					"fieldname": "m_flCompositorRenderGpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "time spent on cpu submitting the above work for this frame",
					"fieldname": "m_flCompositorRenderCpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "time spent waiting for running start (application could have used this much more time)",
					"fieldname": "m_flCompositorIdleCpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "time between calls to WaitGetPoses",
					"fieldname": "m_flClientFrameIntervalMs",
					"fieldtype": "float"
				},
				{
					"doc": "time blocked on call to present (usually 0.0, but can go long)",
					"fieldname": "m_flPresentCallCpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "time spent spin-waiting for frame index to change (not near-zero indicates wait object failure)",
					"fieldname": "m_flWaitForPresentCpuMs",
					"fieldtype": "float"
				},
				{
					"doc": "time spent in IVRCompositor::Submit (not near-zero indicates driver issue)",
					"fieldname": "m_flSubmitFrameMs",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flWaitGetPosesCalledMs",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flNewPosesReadyMs",
					"fieldtype": "float"
				},
				{
					"doc": "second call to IVRCompositor::Submit",
					"fieldname": "m_flNewFrameReadyMs",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flCompositorUpdateStartMs",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flCompositorUpdateEndMs",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flCompositorRenderStartMs",
					"fieldtype": "float"
				},
				{
					"doc": "pose used by app to render this frame",
					"fieldname": "m_HmdPose",
					"fieldtype": "vr::TrackedDevicePose_t"
				},
				{
					"fieldname": "m_nNumVSyncsReadyForUse",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumVSyncsToFirstView",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"doc": "Provides compositor benchmark results to the app",
			"struct": "vr::Compositor_BenchmarkResults",
			"fields": [
				{
					"doc": "Measurement of GPU MP/s performed by compositor benchmark",
					"fieldname": "m_flMegaPixelsPerSecond",
					"fieldtype": "float"
				},
				{
					"doc": "Recommended default MP/s given the HMD resolution, refresh, and panel mask.",
					"fieldname": "m_flHmdRecommendedMegaPixelsPerSecond",
					"fieldtype": "float"
				}
			]
		},
		{
			"align": 8,
			"doc": "Frame timing data provided by direct mode drivers.",
			"struct": "vr::DriverDirectMode_FrameTiming",
			"fields": [
				{
					"doc": "Set to sizeof( DriverDirectMode_FrameTiming )",
					"fieldname": "m_nSize",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "number of times frame was presented",
					"fieldname": "m_nNumFramePresents",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "number of times frame was presented on a vsync other than it was originally predicted to",
					"fieldname": "m_nNumMisPresented",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "number of additional times previous frame was scanned out (i.e. compositor missed vsync)",
					"fieldname": "m_nNumDroppedFrames",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nReprojectionFlags",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::ImuSample_t",
			"fields": [
				{
					"fieldname": "fSampleTime",
					"fieldtype": "double"
				},
				{
					"fieldname": "vAccel",
					"fieldtype": "struct vr::HmdVector3d_t"
				},
				{
					"fieldname": "vGyro",
					"fieldtype": "struct vr::HmdVector3d_t"
				},
				{
					"fieldname": "unOffScaleFlags",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"struct": "vr::AppOverrideKeys_t",
			"fields": [
				{
					"fieldname": "pchKey",
					"fieldtype": "const char *"
				},
				{
					"fieldname": "pchValue",
					"fieldtype": "const char *"
				}
			]
		},
		{
			"align": 8,
			"doc": "Cumulative stats for current application.  These are not cleared until a new app connects, but they do stop accumulating once the associated app disconnects.",
			"struct": "vr::Compositor_CumulativeStats",
			"fields": [
				{
					"doc": "Process id associated with these stats (may no longer be running).",
					"fieldname": "m_nPid",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "total number of times we called present (includes reprojected frames)",
					"fieldname": "m_nNumFramePresents",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "total number of times an old frame was re-scanned out (without reprojection)",
					"fieldname": "m_nNumDroppedFrames",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "total number of times a frame was scanned out a second time (with reprojection)",
					"fieldname": "m_nNumReprojectedFrames",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumFramePresentsOnStartup",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumDroppedFramesOnStartup",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumReprojectedFramesOnStartup",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumLoading",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumFramePresentsLoading",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumDroppedFramesLoading",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumReprojectedFramesLoading",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumTimedOut",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumFramePresentsTimedOut",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumDroppedFramesTimedOut",
					"fieldtype": "uint32_t"
				},
				{
					"fieldname": "m_nNumReprojectedFramesTimedOut",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"align": 8,
			"struct": "vr::Compositor_StageRenderSettings",
			"fields": [
				{
					"doc": "Primary color is applied as a tint to (i.e. multiplied with) the model's texture",
					"fieldname": "m_PrimaryColor",
					"fieldtype": "struct vr::HmdColor_t"
				},
				{
					"fieldname": "m_SecondaryColor",
					"fieldtype": "struct vr::HmdColor_t"
				},
				{
					"doc": "Vignette radius is in meters and is used to fade to the specified secondary solid color over that 3D distance from the origin of the playspace.",
					"fieldname": "m_flVignetteInnerRadius",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flVignetteOuterRadius",
					"fieldtype": "float"
				},
				{
					"doc": "Fades to the secondary color based on view incidence.  This variable controls the linearity of the effect.  It is mutually exclusive with vignette.  Additionally, it treats the mesh as faceted.",
					"fieldname": "m_flFresnelStrength",
					"fieldtype": "float"
				},
				{
					"doc": "Controls backface culling.",
					"fieldname": "m_bBackfaceCulling",
					"fieldtype": "_Bool"
				},
				{
					"doc": "Converts the render model's texture to luma and applies to rgb equally.  This is useful to combat compression artifacts that can occur on desaturated source material.",
					"fieldname": "m_bGreyscale",
					"fieldtype": "_Bool"
				},
				{
					"doc": "Renders mesh as a wireframe.",
					"fieldname": "m_bWireframe",
					"fieldtype": "_Bool"
				}
			]
		},
		{
			"struct": "vr::VROverlayIntersectionParams_t",
			"fields": [
				{
					"fieldname": "vSource",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"fieldname": "vDirection",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"fieldname": "eOrigin",
					"fieldtype": "enum vr::ETrackingUniverseOrigin"
				}
			]
		},
		{
			"struct": "vr::VROverlayIntersectionResults_t",
			"fields": [
				{
					"fieldname": "vPoint",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"fieldname": "vNormal",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"fieldname": "vUVs",
					"fieldtype": "struct vr::HmdVector2_t"
				},
				{
					"fieldname": "fDistance",
					"fieldtype": "float"
				}
			]
		},
		{
			"struct": "vr::IntersectionMaskRectangle_t",
			"fields": [
				{
					"fieldname": "m_flTopLeftX",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flTopLeftY",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flWidth",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flHeight",
					"fieldtype": "float"
				}
			]
		},
		{
			"struct": "vr::IntersectionMaskCircle_t",
			"fields": [
				{
					"fieldname": "m_flCenterX",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flCenterY",
					"fieldtype": "float"
				},
				{
					"fieldname": "m_flRadius",
					"fieldtype": "float"
				}
			]
		},
		{
			"struct": "vr::(anonymous)",
			"fields": [
				{
					"fieldname": "m_Rectangle",
					"fieldtype": "struct vr::IntersectionMaskRectangle_t"
				},
				{
					"fieldname": "m_Circle",
					"fieldtype": "struct vr::IntersectionMaskCircle_t"
				}
			]
		},
		{
			"struct": "vr::VROverlayIntersectionMaskPrimitive_t",
			"fields": [
				{
					"fieldname": "m_nPrimitiveType",
					"fieldtype": "enum vr::EVROverlayIntersectionMaskPrimitiveType"
				},
				{
					"fieldname": "m_Primitive",
					"fieldtype": "VROverlayIntersectionMaskPrimitive_Data_t"
				}
			]
		},
		{
			"struct": "vr::VROverlayView_t",
			"fields": [
				{
					"fieldname": "overlayHandle",
					"fieldtype": "VROverlayHandle_t"
				},
				{
					"fieldname": "texture",
					"fieldtype": "struct vr::Texture_t"
				},
				{
					"fieldname": "textureBounds",
					"fieldtype": "struct vr::VRTextureBounds_t"
				}
			]
		},
		{
			"struct": "vr::VRVulkanDevice_t",
			"fields": [
				{
					"fieldname": "m_pInstance",
					"fieldtype": "struct VkInstance_T *"
				},
				{
					"fieldname": "m_pDevice",
					"fieldtype": "struct VkDevice_T *"
				},
				{
					"fieldname": "m_pPhysicalDevice",
					"fieldtype": "struct VkPhysicalDevice_T *"
				},
				{
					"fieldname": "m_pQueue",
					"fieldtype": "struct VkQueue_T *"
				},
				{
					"fieldname": "m_uQueueFamilyIndex",
					"fieldtype": "uint32_t"
				}
			]
		},
		{
			"struct": "vr::VRNativeDevice_t",
			"fields": [
				{
					"doc": "See EDeviceType definition above",
					"fieldname": "handle",
					"fieldtype": "void *"
				},
				{
					"fieldname": "eType",
					"fieldtype": "enum vr::EDeviceType"
				}
			]
		},
		{
			"align": 8,
			"doc": "single vertex in a render model",
			"struct": "vr::RenderModel_Vertex_t",
			"fields": [
				{
					"doc": "position in meters in device space",
					"fieldname": "vPosition",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"fieldname": "vNormal",
					"fieldtype": "struct vr::HmdVector3_t"
				},
				{
					"fieldname": "rfTextureCoord",
					"fieldtype": "float [2]"
				}
			]
		},
		{
			"_hack_doc": "This structure was originally defined mis-packed on Linux, preserved for compatibility.",
			"_hack": "pack(4) on linux and apple, otherwise pack(8)",
			"align": "hack",
			"struct": "vr::RenderModel_TextureMap_t",
			"fields": [
				{
					"doc": "width and height of the texture map in pixels",
					"fieldname": "unWidth",
					"fieldtype": "uint16_t"
				},
				{
					"doc": "width and height of the texture map in pixels",
					"fieldname": "unHeight",
					"fieldtype": "uint16_t"
				},
				{
					"doc": "Map texture data.",
					"fieldname": "rubTextureMapData",
					"fieldtype": "const uint8_t *"
				},
				{
					"doc": "Refer to EVRRenderModelTextureFormat",
					"fieldname": "format",
					"fieldtype": "enum vr::EVRRenderModelTextureFormat"
				}
			]
		},
		{
			"_hack_doc": "This structure was originally defined mis-packed on Linux, preserved for compatibility.",
			"_hack": "pack(4) on linux and apple, otherwise pack(8)",
			"align": "hack",
			"struct": "vr::RenderModel_t",
			"fields": [
				{
					"doc": "Vertex data for the mesh",
					"fieldname": "rVertexData",
					"fieldtype": "const struct vr::RenderModel_Vertex_t *"
				},
				{
					"doc": "Number of vertices in the vertex data",
					"fieldname": "unVertexCount",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "Indices into the vertex data for each triangle",
					"fieldname": "rIndexData",
					"fieldtype": "const uint16_t *"
				},
				{
					"doc": "Number of triangles in the mesh. Index count is 3 * TriangleCount",
					"fieldname": "unTriangleCount",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "Session unique texture identifier. Rendermodels which share the same texture will have the same id. <0 == texture not present",
					"fieldname": "diffuseTextureId",
					"fieldtype": "TextureID_t"
				}
			]
		},
		{
			"struct": "vr::RenderModel_ControllerMode_State_t",
			"fields": [
				{
					"doc": "is this controller currently set to be in a scroll wheel mode",
					"fieldname": "bScrollWheelVisible",
					"fieldtype": "_Bool"
				}
			]
		},
		{
			"align": 8,
			"doc": "Used for passing graphic data",
			"struct": "vr::NotificationBitmap_t",
			"fields": [
				{
					"fieldname": "m_pImageData",
					"fieldtype": "void *"
				},
				{
					"fieldname": "m_nWidth",
					"fieldtype": "int32_t"
				},
				{
					"fieldname": "m_nHeight",
					"fieldtype": "int32_t"
				},
				{
					"fieldname": "m_nBytesPerPixel",
					"fieldtype": "int32_t"
				}
			]
		},
		{
			"struct": "vr::CVRSettingHelper",
			"fields": [
				{
					"fieldname": "m_pSettings",
					"fieldtype": "class vr::IVRSettings *"
				}
			]
		},
		{
			"struct": "vr::InputAnalogActionData_t",
			"fields": [
				{
					"doc": "Whether or not this action is currently available to be bound in the active action set",
					"fieldname": "bActive",
					"fieldtype": "_Bool"
				},
				{
					"doc": "The origin that caused this action's current state",
					"fieldname": "activeOrigin",
					"fieldtype": "VRInputValueHandle_t"
				},
				{
					"doc": "The current state of this action; will be delta updates for mouse actions",
					"fieldname": "x",
					"fieldtype": "float"
				},
				{
					"doc": "The current state of this action; will be delta updates for mouse actions",
					"fieldname": "y",
					"fieldtype": "float"
				},
				{
					"doc": "The current state of this action; will be delta updates for mouse actions",
					"fieldname": "z",
					"fieldtype": "float"
				},
				{
					"doc": "Deltas since the previous call to UpdateActionState()",
					"fieldname": "deltaX",
					"fieldtype": "float"
				},
				{
					"doc": "Deltas since the previous call to UpdateActionState()",
					"fieldname": "deltaY",
					"fieldtype": "float"
				},
				{
					"doc": "Deltas since the previous call to UpdateActionState()",
					"fieldname": "deltaZ",
					"fieldtype": "float"
				},
				{
					"doc": "Time relative to now when this event happened. Will be negative to indicate a past time.",
					"fieldname": "fUpdateTime",
					"fieldtype": "float"
				}
			]
		},
		{
			"struct": "vr::InputDigitalActionData_t",
			"fields": [
				{
					"doc": "Whether or not this action is currently available to be bound in the active action set",
					"fieldname": "bActive",
					"fieldtype": "_Bool"
				},
				{
					"doc": "The origin that caused this action's current state",
					"fieldname": "activeOrigin",
					"fieldtype": "VRInputValueHandle_t"
				},
				{
					"doc": "The current state of this action; will be true if currently pressed",
					"fieldname": "bState",
					"fieldtype": "_Bool"
				},
				{
					"doc": "This is true if the state has changed since the last frame",
					"fieldname": "bChanged",
					"fieldtype": "_Bool"
				},
				{
					"doc": "Time relative to now when this event happened. Will be negative to indicate a past time.",
					"fieldname": "fUpdateTime",
					"fieldtype": "float"
				}
			]
		},
		{
			"struct": "vr::InputPoseActionData_t",
			"fields": [
				{
					"doc": "Whether or not this action is currently available to be bound in the active action set",
					"fieldname": "bActive",
					"fieldtype": "_Bool"
				},
				{
					"doc": "The origin that caused this action's current state",
					"fieldname": "activeOrigin",
					"fieldtype": "VRInputValueHandle_t"
				},
				{
					"doc": "The current state of this action",
					"fieldname": "pose",
					"fieldtype": "struct vr::TrackedDevicePose_t"
				}
			]
		},
		{
			"struct": "vr::InputSkeletalActionData_t",
			"fields": [
				{
					"doc": "Whether or not this action is currently available to be bound in the active action set",
					"fieldname": "bActive",
					"fieldtype": "_Bool"
				},
				{
					"doc": "The origin that caused this action's current state",
					"fieldname": "activeOrigin",
					"fieldtype": "VRInputValueHandle_t"
				}
			]
		},
		{
			"struct": "vr::InputOriginInfo_t",
			"fields": [
				{
					"fieldname": "devicePath",
					"fieldtype": "VRInputValueHandle_t"
				},
				{
					"fieldname": "trackedDeviceIndex",
					"fieldtype": "TrackedDeviceIndex_t"
				},
				{
					"fieldname": "rchRenderModelComponentName",
					"fieldtype": "char [128]"
				}
			]
		},
		{
			"struct": "vr::InputBindingInfo_t",
			"fields": [
				{
					"fieldname": "rchDevicePathName",
					"fieldtype": "char [128]"
				},
				{
					"fieldname": "rchInputPathName",
					"fieldtype": "char [128]"
				},
				{
					"fieldname": "rchModeName",
					"fieldtype": "char [128]"
				},
				{
					"fieldname": "rchSlotName",
					"fieldtype": "char [128]"
				},
				{
					"fieldname": "rchInputSourceType",
					"fieldtype": "char [32]"
				}
			]
		},
		{
			"struct": "vr::VRActiveActionSet_t",
			"fields": [
				{
					"doc": "This is the handle of the action set to activate for this frame.",
					"fieldname": "ulActionSet",
					"fieldtype": "VRActionSetHandle_t"
				},
				{
					"doc": "This is the handle of a device path that this action set should be active for. To activate for all devices, set this to k_ulInvalidInputValueHandle.",
					"fieldname": "ulRestrictedToDevice",
					"fieldtype": "VRInputValueHandle_t"
				},
				{
					"doc": "The action set to activate for all devices other than ulRestrictedDevice. If ulRestrictedToDevice is set to k_ulInvalidInputValueHandle, this parameter is  ignored.",
					"fieldname": "ulSecondaryActionSet",
					"fieldtype": "VRActionSetHandle_t"
				},
				{
					"fieldname": "unPadding",
					"fieldtype": "uint32_t"
				},
				{
					"doc": "The priority of this action set relative to other action sets. Any inputs bound to a source (e.g. trackpad, joystick, trigger) will disable bindings in other active action sets with a smaller priority. \nOverlay applications (i.e. ApplicationType_Overlay) may set their action set priority  to a value between k_nActionSetOverlayGlobalPriorityMin and k_nActionSetOverlayGlobalPriorityMax to cause any inputs bound to a source used by that action set to be disabled in scene applications.\nNo action set priority may value may be larger than k_nActionSetPriorityReservedMin",
					"fieldname": "nPriority",
					"fieldtype": "int32_t"
				}
			]
		},
		{
			"doc": "Contains summary information about the current skeletal pose",
			"struct": "vr::VRSkeletalSummaryData_t",
			"fields": [
				{
					"doc": "The amount that each finger is 'curled' inwards towards the palm.  In the case of the thumb, this represents how much the thumb is wrapped around the fist. 0 means straight, 1 means fully curled",
					"fieldname": "flFingerCurl",
					"fieldtype": "float [5]"
				},
				{
					"doc": "The amount that each pair of adjacent fingers are separated. 0 means the digits are touching, 1 means they are fully separated.",
					"fieldname": "flFingerSplay",
					"fieldtype": "float [4]"
				}
			]
		},
		{
			"struct": "vr::SpatialAnchorPose_t",
			"fields": [
				{
					"fieldname": "mAnchorToAbsoluteTracking",
					"fieldtype": "struct vr::HmdMatrix34_t"
				}
			]
		},
		{
			"struct": "vr::COpenVRContext",
			"fields": [
				{
					"fieldname": "m_pVRSystem",
					"fieldtype": "class vr::IVRSystem *"
				},
				{
					"fieldname": "m_pVRChaperone",
					"fieldtype": "class vr::IVRChaperone *"
				},
				{
					"fieldname": "m_pVRChaperoneSetup",
					"fieldtype": "class vr::IVRChaperoneSetup *"
				},
				{
					"fieldname": "m_pVRCompositor",
					"fieldtype": "class vr::IVRCompositor *"
				},
				{
					"fieldname": "m_pVRHeadsetView",
					"fieldtype": "class vr::IVRHeadsetView *"
				},
				{
					"fieldname": "m_pVROverlay",
					"fieldtype": "class vr::IVROverlay *"
				},
				{
					"fieldname": "m_pVROverlayView",
					"fieldtype": "class vr::IVROverlayView *"
				},
				{
					"fieldname": "m_pVRResources",
					"fieldtype": "class vr::IVRResources *"
				},
				{
					"fieldname": "m_pVRRenderModels",
					"fieldtype": "class vr::IVRRenderModels *"
				},
				{
					"fieldname": "m_pVRExtendedDisplay",
					"fieldtype": "class vr::IVRExtendedDisplay *"
				},
				{
					"fieldname": "m_pVRSettings",
					"fieldtype": "class vr::IVRSettings *"
				},
				{
					"fieldname": "m_pVRApplications",
					"fieldtype": "class vr::IVRApplications *"
				},
				{
					"fieldname": "m_pVRTrackedCamera",
					"fieldtype": "class vr::IVRTrackedCamera *"
				},
				{
					"fieldname": "m_pVRScreenshots",
					"fieldtype": "class vr::IVRScreenshots *"
				},
				{
					"fieldname": "m_pVRDriverManager",
					"fieldtype": "class vr::IVRDriverManager *"
				},
				{
					"fieldname": "m_pVRInput",
					"fieldtype": "class vr::IVRInput *"
				},
				{
					"fieldname": "m_pVRIOBuffer",
					"fieldtype": "class vr::IVRIOBuffer *"
				},
				{
					"fieldname": "m_pVRSpatialAnchors",
					"fieldtype": "class vr::IVRSpatialAnchors *"
				},
				{
					"fieldname": "m_pVRDebug",
					"fieldtype": "class vr::IVRDebug *"
				},
				{
					"fieldname": "m_pVRNotifications",
					"fieldtype": "class vr::IVRNotifications *"
				}
			]
		}
	],
	"methods": [
		{
			"classname": "vr::IVRSystem",
			"doc": "Suggested size for the intermediate render target that the distortion pulls from.",
			"methodname": "GetRecommendedRenderTargetSize",
			"returntype": "void",
			"params": [
				{
					"paramname": "pnWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnHeight",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "The projection matrix for the specified eye",
			"methodname": "GetProjectionMatrix",
			"returntype": "struct vr::HmdMatrix44_t",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "fNearZ",
					"paramtype": "float"
				},
				{
					"paramname": "fFarZ",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "The components necessary to build your own projection matrix in case your application is doing something fancy like infinite Z",
			"methodname": "GetProjectionRaw",
			"returntype": "void",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "pfLeft",
					"paramtype": "float *"
				},
				{
					"paramname": "pfRight",
					"paramtype": "float *"
				},
				{
					"paramname": "pfTop",
					"paramtype": "float *"
				},
				{
					"paramname": "pfBottom",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Gets the result of the distortion function for the specified eye and input UVs. UVs go from 0,0 in the upper left of that eye's viewport and 1,1 in the lower right of that eye's viewport. Returns true for success. Otherwise, returns false, and distortion coordinates are not suitable.",
			"methodname": "ComputeDistortion",
			"returntype": "bool",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "fU",
					"paramtype": "float"
				},
				{
					"paramname": "fV",
					"paramtype": "float"
				},
				{
					"paramname": "pDistortionCoordinates",
					"paramtype": "struct vr::DistortionCoordinates_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the transform from eye space to the head space. Eye space is the per-eye flavor of head space that provides stereo disparity. Instead of Model * View * Projection the sequence is Model * View * Eye^-1 * Projection. Normally View and Eye^-1 will be multiplied together and treated as View in your application.",
			"methodname": "GetEyeToHeadTransform",
			"returntype": "struct vr::HmdMatrix34_t",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the number of elapsed seconds since the last recorded vsync event. This will come from a vsync timer event in the timer if possible or from the application-reported time if that is not available. If no vsync times are available the function will return zero for vsync time and frame counter and return false from the method.",
			"methodname": "GetTimeSinceLastVsync",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pfSecondsSinceLastVsync",
					"paramtype": "float *"
				},
				{
					"paramname": "pulFrameCounter",
					"paramtype": "uint64_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "[D3D9 Only]\nReturns the adapter index that the user should pass into CreateDevice to set up D3D9 in such a way that it can go full screen exclusive on the HMD. Returns -1 if there was an error.",
			"methodname": "GetD3D9AdapterIndex",
			"returntype": "int32_t"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "[D3D10/11 Only]\nReturns the adapter index that the user should pass into EnumAdapters to create the device and swap chain in DX10 and DX11. If an error occurs the index will be set to -1.",
			"methodname": "GetDXGIOutputInfo",
			"returntype": "void",
			"params": [
				{
					"paramname": "pnAdapterIndex",
					"paramtype": "int32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns platform- and texture-type specific adapter identification so that applications and the compositor are creating textures and swap chains on the same GPU. If an error occurs the device will be set to 0.\npInstance is an optional parameter that is required only when textureType is TextureType_Vulkan.\n[D3D10/11/12 Only (D3D9 Not Supported)]\n Returns the adapter LUID that identifies the GPU attached to the HMD. The user should  enumerate all adapters using IDXGIFactory::EnumAdapters and IDXGIAdapter::GetDesc to find  the adapter with the matching LUID, or use IDXGIFactory4::EnumAdapterByLuid.\n The discovered IDXGIAdapter should be used to create the device and swap chain.\n[Vulkan Only]\n Returns the VkPhysicalDevice that should be used by the application.\n pInstance must be the instance the application will use to query for the VkPhysicalDevice.  The application must create the VkInstance with extensions returned by IVRCompositor::GetVulkanInstanceExtensionsRequired enabled.\n[macOS Only]\n For TextureType_IOSurface returns the id<MTLDevice> that should be used by the application.\n On 10.13+ for TextureType_OpenGL returns the 'registryId' of the renderer which should be used   by the application. See Apple Technical Q&A QA1168 for information on enumerating GL Renderers, and the new kCGLRPRegistryIDLow and kCGLRPRegistryIDHigh CGLRendererProperty values in the 10.13 SDK.\n Pre 10.13 for TextureType_OpenGL returns 0, as there is no dependable way to correlate the HMDs MTLDevice with a GL Renderer.",
			"methodname": "GetOutputDevice",
			"returntype": "void",
			"params": [
				{
					"paramname": "pnDevice",
					"paramtype": "uint64_t *"
				},
				{
					"paramname": "textureType",
					"paramtype": "vr::ETextureType"
				},
				{
					"paramname": "pInstance",
					"paramtype": "struct VkInstance_T *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Use to determine if the headset display is part of the desktop (i.e. extended) or hidden (i.e. direct mode).",
			"methodname": "IsDisplayOnDesktop",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Set the display visibility (true = extended, false = direct mode).  Return value of true indicates that the change was successful.",
			"methodname": "SetDisplayVisibility",
			"returntype": "bool",
			"params": [
				{
					"paramname": "bIsVisibleOnDesktop",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "The pose that the tracker thinks that the HMD will be in at the specified number of seconds into the future. Pass 0 to get the state at the instant the method is called. Most of the time the application should calculate the time until the photons will be emitted from the display and pass that time into the method.\nThis is roughly analogous to the inverse of the view matrix in most applications, though many games will need to do some additional rotation or translation on top of the rotation and translation provided by the head pose.\nFor devices where bPoseIsValid is true the application can use the pose to position the device in question. The provided array can be any size up to k_unMaxTrackedDeviceCount. \nSeated experiences should call this method with TrackingUniverseSeated and receive poses relative to the seated zero pose. Standing experiences should call this method with TrackingUniverseStanding and receive poses relative to the Chaperone Play Area. TrackingUniverseRawAndUncalibrated should probably not be used unless the application is the Chaperone calibration tool itself, but will provide poses relative to the hardware-specific coordinate system in the driver.",
			"methodname": "GetDeviceToAbsoluteTrackingPose",
			"returntype": "void",
			"params": [
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "fPredictedSecondsToPhotonsFromNow",
					"paramtype": "float"
				},
				{
					"paramname": "pTrackedDevicePoseArray",
					"array_count": "unTrackedDevicePoseArrayCount",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "unTrackedDevicePoseArrayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Sets the zero pose for the seated tracker coordinate system to the current position and yaw of the HMD. After ResetSeatedZeroPose all GetDeviceToAbsoluteTrackingPose calls that pass TrackingUniverseSeated as the origin will be relative to this new zero pose. The new zero coordinate system will not change the fact that the Y axis is up in the real world, so the next pose returned from GetDeviceToAbsoluteTrackingPose after a call to ResetSeatedZeroPose may not be exactly an identity matrix.\nNOTE: This function overrides the user's previously saved seated zero pose and should only be called as the result of a user action. Users are also able to set their seated zero pose via the OpenVR Dashboard.",
			"methodname": "ResetSeatedZeroPose",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the transform from the seated zero pose to the standing absolute tracking system. This allows applications to represent the seated origin to used or transform object positions from one coordinate system to the other.\nThe seated origin may or may not be inside the Play Area or Collision Bounds returned by IVRChaperone. Its position depends on what the user has set from the Dashboard settings and previous calls to ResetSeatedZeroPose.",
			"methodname": "GetSeatedZeroPoseToStandingAbsoluteTrackingPose",
			"returntype": "struct vr::HmdMatrix34_t"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the transform from the tracking origin to the standing absolute tracking system. This allows applications to convert from raw tracking space to the calibrated standing coordinate system.",
			"methodname": "GetRawZeroPoseToStandingAbsoluteTrackingPose",
			"returntype": "struct vr::HmdMatrix34_t"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Get a sorted array of device indices of a given class of tracked devices (e.g. controllers).  Devices are sorted right to left relative to the specified tracked device (default: hmd -- pass in -1 for absolute tracking space).  Returns the number of devices in the list, or the size of the array needed if not large enough.",
			"methodname": "GetSortedTrackedDeviceIndicesOfClass",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "eTrackedDeviceClass",
					"paramtype": "vr::ETrackedDeviceClass"
				},
				{
					"paramname": "punTrackedDeviceIndexArray",
					"array_count": "unTrackedDeviceIndexArrayCount",
					"paramtype": "vr::TrackedDeviceIndex_t *"
				},
				{
					"paramname": "unTrackedDeviceIndexArrayCount",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unRelativeToTrackedDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the level of activity on the device.",
			"methodname": "GetTrackedDeviceActivityLevel",
			"returntype": "vr::EDeviceActivityLevel",
			"params": [
				{
					"paramname": "unDeviceId",
					"paramtype": "vr::TrackedDeviceIndex_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Convenience utility to apply the specified transform to the specified pose. This properly transforms all pose components, including velocity and angular velocity",
			"methodname": "ApplyTransform",
			"returntype": "void",
			"params": [
				{
					"paramname": "pOutputPose",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "pTrackedDevicePose",
					"paramtype": "const struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "pTransform",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the device index associated with a specific role, for example the left hand or the right hand. This function is deprecated in favor of the new IVRInput system.",
			"methodname": "GetTrackedDeviceIndexForControllerRole",
			"returntype": "vr::TrackedDeviceIndex_t",
			"params": [
				{
					"paramname": "unDeviceType",
					"paramtype": "vr::ETrackedControllerRole"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the controller type associated with a device index. This function is deprecated in favor of the new IVRInput system.",
			"methodname": "GetControllerRoleForTrackedDeviceIndex",
			"returntype": "vr::ETrackedControllerRole",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the device class of a tracked device. If there has not been a device connected in this slot\nsince the application started this function will return TrackedDevice_Invalid. For previous detected\ndevices the function will return the previously observed device class.\nTo determine which devices exist on the system, just loop from 0 to k_unMaxTrackedDeviceCount and check\nthe device class. Every device with something other than TrackedDevice_Invalid is associated with an \nactual tracked device.",
			"methodname": "GetTrackedDeviceClass",
			"returntype": "vr::ETrackedDeviceClass",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns true if there is a device connected in this slot.",
			"methodname": "IsTrackedDeviceConnected",
			"returntype": "bool",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns a bool property. If the device index is not valid or the property is not a bool type this function will return false.",
			"methodname": "GetBoolTrackedDeviceProperty",
			"returntype": "bool",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "prop",
					"paramtype": "vr::ETrackedDeviceProperty"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::ETrackedPropertyError *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns a float property. If the device index is not valid or the property is not a float type this function will return 0.",
			"methodname": "GetFloatTrackedDeviceProperty",
			"returntype": "float",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "prop",
					"paramtype": "vr::ETrackedDeviceProperty"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::ETrackedPropertyError *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns an int property. If the device index is not valid or the property is not a int type this function will return 0.",
			"methodname": "GetInt32TrackedDeviceProperty",
			"returntype": "int32_t",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "prop",
					"paramtype": "vr::ETrackedDeviceProperty"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::ETrackedPropertyError *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns a uint64 property. If the device index is not valid or the property is not a uint64 type this function will return 0.",
			"methodname": "GetUint64TrackedDeviceProperty",
			"returntype": "uint64_t",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "prop",
					"paramtype": "vr::ETrackedDeviceProperty"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::ETrackedPropertyError *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns a matrix property. If the device index is not valid or the property is not a matrix type, this function will return identity.",
			"methodname": "GetMatrix34TrackedDeviceProperty",
			"returntype": "struct vr::HmdMatrix34_t",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "prop",
					"paramtype": "vr::ETrackedDeviceProperty"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::ETrackedPropertyError *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns an array of one type of property. If the device index is not valid or the property is not a single value or an array of the specified type, this function will return 0. Otherwise it returns the number of bytes necessary to hold the array of properties. If unBufferSize is greater than the returned size and pBuffer is non-NULL, pBuffer is filled with the contents of array of properties.",
			"methodname": "GetArrayTrackedDeviceProperty",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "prop",
					"paramtype": "vr::ETrackedDeviceProperty"
				},
				{
					"paramname": "propType",
					"paramtype": "vr::PropertyTypeTag_t"
				},
				{
					"paramname": "pBuffer",
					"paramtype": "void *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::ETrackedPropertyError *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns a string property. If the device index is not valid or the property is not a string type this function will return 0. Otherwise it returns the length of the number of bytes necessary to hold this string including the trailing null. Strings will always fit in buffers of k_unMaxPropertyStringSize characters.",
			"methodname": "GetStringTrackedDeviceProperty",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "prop",
					"paramtype": "vr::ETrackedDeviceProperty"
				},
				{
					"paramname": "pchValue",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::ETrackedPropertyError *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "returns a string that corresponds with the specified property error. The string will be the name of the error enum value for all valid error codes",
			"methodname": "GetPropErrorNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "error",
					"paramtype": "vr::ETrackedPropertyError"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns true and fills the event with the next event on the queue if there is one. If there are no events this method returns false. uncbVREvent should be the size in bytes of the VREvent_t struct",
			"methodname": "PollNextEvent",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pEvent",
					"paramtype": "struct vr::VREvent_t *"
				},
				{
					"paramname": "uncbVREvent",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns true and fills the event with the next event on the queue if there is one. If there are no events this method returns false. Fills in the pose of the associated tracked device in the provided pose struct. This pose will always be older than the call to this function and should not be used to render the device.\nuncbVREvent should be the size in bytes of the VREvent_t struct",
			"methodname": "PollNextEventWithPose",
			"returntype": "bool",
			"params": [
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "pEvent",
					"paramtype": "struct vr::VREvent_t *"
				},
				{
					"paramname": "uncbVREvent",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pTrackedDevicePose",
					"paramtype": "vr::TrackedDevicePose_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "returns the name of an EVREvent enum value",
			"methodname": "GetEventTypeNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "eType",
					"paramtype": "vr::EVREventType"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the hidden area mesh for the current HMD. The pixels covered by this mesh will never be seen by the user after the lens distortion is applied based on visibility to the panels. If this HMD does not have a hidden area mesh, the vertex data and count will be NULL and 0 respectively. This mesh is meant to be rendered into the stencil buffer (or into the depth buffer setting nearz) before rendering each eye's view.  This will improve performance by letting the GPU early-reject pixels the user will never see before running the pixel shader. \nNOTE: Render this mesh with backface culling disabled since the winding order of the vertices can be different per-HMD or per-eye. Setting the bInverse argument to true will produce the visible area mesh that is commonly used in place of full-screen quads. The visible area mesh covers all of the pixels the hidden area mesh does not cover. Setting the bLineLoop argument will return a line loop of vertices in HiddenAreaMesh_t->pVertexData with HiddenAreaMesh_t->unTriangleCount set to the number of vertices.",
			"methodname": "GetHiddenAreaMesh",
			"returntype": "struct vr::HiddenAreaMesh_t",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "type",
					"paramtype": "vr::EHiddenAreaMeshType"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Fills the supplied struct with the current state of the controller. Returns false if the controller index is invalid. This function is deprecated in favor of the new IVRInput system.",
			"methodname": "GetControllerState",
			"returntype": "bool",
			"params": [
				{
					"paramname": "unControllerDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pControllerState",
					"paramtype": "vr::VRControllerState_t *"
				},
				{
					"paramname": "unControllerStateSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "fills the supplied struct with the current state of the controller and the provided pose with the pose of  the controller when the controller state was updated most recently. Use this form if you need a precise controller pose as input to your application when the user presses or releases a button. This function is deprecated in favor of the new IVRInput system.",
			"methodname": "GetControllerStateWithPose",
			"returntype": "bool",
			"params": [
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "unControllerDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pControllerState",
					"paramtype": "vr::VRControllerState_t *"
				},
				{
					"paramname": "unControllerStateSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pTrackedDevicePose",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Trigger a single haptic pulse on a controller. After this call the application may not trigger another haptic pulse on this controller and axis combination for 5ms. This function is deprecated in favor of the new IVRInput system.",
			"methodname": "TriggerHapticPulse",
			"returntype": "void",
			"params": [
				{
					"paramname": "unControllerDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "unAxisId",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "usDurationMicroSec",
					"paramtype": "unsigned short"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "returns the name of an EVRButtonId enum value. This function is deprecated in favor of the new IVRInput system.  ",
			"methodname": "GetButtonIdNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "eButtonId",
					"paramtype": "vr::EVRButtonId"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "returns the name of an EVRControllerAxisType enum value. This function is deprecated in favor of the new IVRInput system. ",
			"methodname": "GetControllerAxisTypeNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "eAxisType",
					"paramtype": "vr::EVRControllerAxisType"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns true if this application is receiving input from the system. This would return false if system-related functionality is consuming the input stream. ",
			"methodname": "IsInputAvailable",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns true SteamVR is drawing controllers on top of the application. Applications should consider not drawing anything attached to the user's hands in this case. ",
			"methodname": "IsSteamVRDrawingControllers",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns true if the user has put SteamVR into a mode that is distracting them from the application. For applications where this is appropriate, the application should pause ongoing activity. ",
			"methodname": "ShouldApplicationPause",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns true if SteamVR is doing significant rendering work and the game should do what it can to reduce its own workload. One common way to do this is to reduce the size of the render target provided for each eye. ",
			"methodname": "ShouldApplicationReduceRenderingWork",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Performs the actual firmware update if applicable.  The following events will be sent, if VRFirmwareError_None was returned: VREvent_FirmwareUpdateStarted, VREvent_FirmwareUpdateFinished  Use the properties Prop_Firmware_UpdateAvailable_Bool, Prop_Firmware_ManualUpdate_Bool, and Prop_Firmware_ManualUpdateURL_String to figure our whether a firmware update is available, and to figure out whether its a manual update  Prop_Firmware_ManualUpdateURL_String should point to an URL describing the manual update process ",
			"methodname": "PerformFirmwareUpdate",
			"returntype": "vr::EVRFirmwareError",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Call this to acknowledge to the system that VREvent_Quit has been received and that the process is exiting. This extends the timeout until the process is killed. ",
			"methodname": "AcknowledgeQuit_Exiting",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Retrieves a null-terminated, semicolon-delimited list of UTF8 file paths that an application  must have read access to when running inside of an app container. Returns the number of bytes needed to hold the list. ",
			"methodname": "GetAppContainerFilePaths",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRSystem",
			"doc": "Returns the current version of the SteamVR runtime. The returned string will remain valid until VR_Shutdown is called.\nNOTE: Is it not appropriate to use this version to test for the presence of any SteamVR feature. Only use this version number for logging or showing to a user, and not to try to detect anything at runtime. When appropriate, feature-specific presence information is provided by other APIs. ",
			"methodname": "GetRuntimeVersion",
			"returntype": "const char *"
		},
		{
			"classname": "vr::IVRExtendedDisplay",
			"doc": "Size and position that the window needs to be on the VR display.",
			"methodname": "GetWindowBounds",
			"returntype": "void",
			"params": [
				{
					"paramname": "pnX",
					"paramtype": "int32_t *"
				},
				{
					"paramname": "pnY",
					"paramtype": "int32_t *"
				},
				{
					"paramname": "pnWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnHeight",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRExtendedDisplay",
			"doc": "Gets the viewport in the frame buffer to draw the output of the distortion into",
			"methodname": "GetEyeOutputViewport",
			"returntype": "void",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "pnX",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnY",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnHeight",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRExtendedDisplay",
			"doc": "[D3D10/11 Only]\nReturns the adapter index and output index that the user should pass into EnumAdapters and EnumOutputs to create the device and swap chain in DX10 and DX11. If an error occurs both indices will be set to -1.",
			"methodname": "GetDXGIOutputInfo",
			"returntype": "void",
			"params": [
				{
					"paramname": "pnAdapterIndex",
					"paramtype": "int32_t *"
				},
				{
					"paramname": "pnAdapterOutputIndex",
					"paramtype": "int32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "Returns a string for an error",
			"methodname": "GetCameraErrorNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "eCameraError",
					"paramtype": "vr::EVRTrackedCameraError"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "For convenience, same as tracked property request Prop_HasCamera_Bool",
			"methodname": "HasCamera",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "nDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pHasCamera",
					"paramtype": "bool *"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "Gets size of the image frame.",
			"methodname": "GetCameraFrameSize",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "nDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "eFrameType",
					"paramtype": "vr::EVRTrackedCameraFrameType"
				},
				{
					"paramname": "pnWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnHeight",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnFrameBufferSize",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"methodname": "GetCameraIntrinsics",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "nDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "nCameraIndex",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "eFrameType",
					"paramtype": "vr::EVRTrackedCameraFrameType"
				},
				{
					"paramname": "pFocalLength",
					"paramtype": "vr::HmdVector2_t *"
				},
				{
					"paramname": "pCenter",
					"paramtype": "vr::HmdVector2_t *"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"methodname": "GetCameraProjection",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "nDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "nCameraIndex",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "eFrameType",
					"paramtype": "vr::EVRTrackedCameraFrameType"
				},
				{
					"paramname": "flZNear",
					"paramtype": "float"
				},
				{
					"paramname": "flZFar",
					"paramtype": "float"
				},
				{
					"paramname": "pProjection",
					"paramtype": "vr::HmdMatrix44_t *"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "Acquiring streaming service permits video streaming for the caller. Releasing hints the system that video services do not need to be maintained for this client.\nIf the camera has not already been activated, a one time spin up may incur some auto exposure as well as initial streaming frame delays.\nThe camera should be considered a global resource accessible for shared consumption but not exclusive to any caller.\nThe camera may go inactive due to lack of active consumers or headset idleness.",
			"methodname": "AcquireVideoStreamingService",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "nDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pHandle",
					"paramtype": "vr::TrackedCameraHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"methodname": "ReleaseVideoStreamingService",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "hTrackedCamera",
					"paramtype": "vr::TrackedCameraHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "Copies the image frame into a caller's provided buffer. The image data is currently provided as RGBA data, 4 bytes per pixel. \nA caller can provide null for the framebuffer or frameheader if not desired. Requesting the frame header first, followed by the frame buffer allows the caller to determine if the frame as advanced per the frame header sequence.  \nIf there is no frame available yet, due to initial camera spinup or re-activation, the error will be VRTrackedCameraError_NoFrameAvailable. \nIdeally a caller should be polling at ~16ms intervals",
			"methodname": "GetVideoStreamFrameBuffer",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "hTrackedCamera",
					"paramtype": "vr::TrackedCameraHandle_t"
				},
				{
					"paramname": "eFrameType",
					"paramtype": "vr::EVRTrackedCameraFrameType"
				},
				{
					"paramname": "pFrameBuffer",
					"paramtype": "void *"
				},
				{
					"paramname": "nFrameBufferSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pFrameHeader",
					"paramtype": "vr::CameraVideoStreamFrameHeader_t *"
				},
				{
					"paramname": "nFrameHeaderSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "Gets size of the image frame.",
			"methodname": "GetVideoStreamTextureSize",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "nDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "eFrameType",
					"paramtype": "vr::EVRTrackedCameraFrameType"
				},
				{
					"paramname": "pTextureBounds",
					"paramtype": "vr::VRTextureBounds_t *"
				},
				{
					"paramname": "pnWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnHeight",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "Access a shared D3D11 texture for the specified tracked camera stream. \nThe camera frame type VRTrackedCameraFrameType_Undistorted is not supported directly as a shared texture. It is an interior subregion of the shared texture VRTrackedCameraFrameType_MaximumUndistorted. \nInstead, use GetVideoStreamTextureSize() with VRTrackedCameraFrameType_Undistorted to determine the proper interior subregion bounds along with GetVideoStreamTextureD3D11() with VRTrackedCameraFrameType_MaximumUndistorted to provide the texture. The VRTrackedCameraFrameType_MaximumUndistorted will yield an image where the invalid regions are decoded by the alpha channel having a zero component. The valid regions all have a non-zero alpha component. The subregion as described by VRTrackedCameraFrameType_Undistorted  guarantees a rectangle where all pixels are valid.",
			"methodname": "GetVideoStreamTextureD3D11",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "hTrackedCamera",
					"paramtype": "vr::TrackedCameraHandle_t"
				},
				{
					"paramname": "eFrameType",
					"paramtype": "vr::EVRTrackedCameraFrameType"
				},
				{
					"paramname": "pD3D11DeviceOrResource",
					"paramtype": "void *"
				},
				{
					"paramname": "ppD3D11ShaderResourceView",
					"paramtype": "void **"
				},
				{
					"paramname": "pFrameHeader",
					"paramtype": "vr::CameraVideoStreamFrameHeader_t *"
				},
				{
					"paramname": "nFrameHeaderSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"doc": "Access a shared GL texture for the specified tracked camera stream",
			"methodname": "GetVideoStreamTextureGL",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "hTrackedCamera",
					"paramtype": "vr::TrackedCameraHandle_t"
				},
				{
					"paramname": "eFrameType",
					"paramtype": "vr::EVRTrackedCameraFrameType"
				},
				{
					"paramname": "pglTextureId",
					"paramtype": "vr::glUInt_t *"
				},
				{
					"paramname": "pFrameHeader",
					"paramtype": "vr::CameraVideoStreamFrameHeader_t *"
				},
				{
					"paramname": "nFrameHeaderSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"methodname": "ReleaseVideoStreamTextureGL",
			"returntype": "vr::EVRTrackedCameraError",
			"params": [
				{
					"paramname": "hTrackedCamera",
					"paramtype": "vr::TrackedCameraHandle_t"
				},
				{
					"paramname": "glTextureId",
					"paramtype": "vr::glUInt_t"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"methodname": "SetCameraTrackingSpace",
			"returntype": "void",
			"params": [
				{
					"paramname": "eUniverse",
					"paramtype": "vr::ETrackingUniverseOrigin"
				}
			]
		},
		{
			"classname": "vr::IVRTrackedCamera",
			"methodname": "GetCameraTrackingSpace",
			"returntype": "vr::ETrackingUniverseOrigin"
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Adds an application manifest to the list to load when building the list of installed applications. Temporary manifests are not automatically loaded ",
			"methodname": "AddApplicationManifest",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchApplicationManifestFullPath",
					"paramtype": "const char *"
				},
				{
					"paramname": "bTemporary",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Removes an application manifest from the list to load when building the list of installed applications. ",
			"methodname": "RemoveApplicationManifest",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchApplicationManifestFullPath",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns true if an application is installed ",
			"methodname": "IsApplicationInstalled",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns the number of applications available in the list ",
			"methodname": "GetApplicationCount",
			"returntype": "uint32_t"
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns the key of the specified application. The index is at least 0 and is less than the return  value of GetApplicationCount(). The buffer should be at least k_unMaxApplicationKeyLength in order to  fit the key. ",
			"methodname": "GetApplicationKeyByIndex",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "unApplicationIndex",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchAppKeyBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unAppKeyBufferLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns the key of the application for the specified Process Id. The buffer should be at least k_unMaxApplicationKeyLength in order to fit the key. ",
			"methodname": "GetApplicationKeyByProcessId",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "unProcessId",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchAppKeyBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unAppKeyBufferLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Launches the application. The existing scene application will exit and then the new application will start. This call is not valid for dashboard overlay applications. ",
			"methodname": "LaunchApplication",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Launches an instance of an application of type template, with its app key being pchNewAppKey (which must be unique) and optionally override sections from the manifest file via AppOverrideKeys_t",
			"methodname": "LaunchTemplateApplication",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchTemplateAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchNewAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pKeys",
					"array_count": "unKeys",
					"paramtype": "const struct vr::AppOverrideKeys_t *"
				},
				{
					"paramname": "unKeys",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "launches the application currently associated with this mime type and passes it the option args, typically the filename or object name of the item being launched ",
			"methodname": "LaunchApplicationFromMimeType",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchMimeType",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchArgs",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Launches the dashboard overlay application if it is not already running. This call is only valid for dashboard overlay applications. ",
			"methodname": "LaunchDashboardOverlay",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Cancel a pending launch for an application ",
			"methodname": "CancelApplicationLaunch",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Identifies a running application. OpenVR can't always tell which process started in response to a URL. This function allows a URL handler (or the process itself) to identify the app key  for the now running application. Passing a process ID of 0 identifies the calling process.  The application must be one that's known to the system via a call to AddApplicationManifest. ",
			"methodname": "IdentifyApplication",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "unProcessId",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns the process ID for an application. Return 0 if the application was not found or is not running. ",
			"methodname": "GetApplicationProcessId",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns a string for an applications error ",
			"methodname": "GetApplicationsErrorNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "error",
					"paramtype": "vr::EVRApplicationError"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns a value for an application property. The required buffer size to fit this value will be returned. ",
			"methodname": "GetApplicationPropertyString",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				},
				{
					"doc": "these are the properties available on applications.",
					"paramname": "eProperty",
					"paramtype": "vr::EVRApplicationProperty"
				},
				{
					"paramname": "pchPropertyValueBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unPropertyValueBufferLen",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRApplicationError *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns a bool value for an application property. Returns false in all error cases. ",
			"methodname": "GetApplicationPropertyBool",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "eProperty",
					"paramtype": "vr::EVRApplicationProperty"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRApplicationError *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns a uint64 value for an application property. Returns 0 in all error cases. ",
			"methodname": "GetApplicationPropertyUint64",
			"returntype": "uint64_t",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "eProperty",
					"paramtype": "vr::EVRApplicationProperty"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRApplicationError *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Sets the application auto-launch flag. This is only valid for applications which return true for VRApplicationProperty_IsDashboardOverlay_Bool. ",
			"methodname": "SetApplicationAutoLaunch",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "bAutoLaunch",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Gets the application auto-launch flag. This is only valid for applications which return true for VRApplicationProperty_IsDashboardOverlay_Bool. ",
			"methodname": "GetApplicationAutoLaunch",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Adds this mime-type to the list of supported mime types for this application",
			"methodname": "SetDefaultApplicationForMimeType",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchMimeType",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "return the app key that will open this mime type ",
			"methodname": "GetDefaultApplicationForMimeType",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchMimeType",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchAppKeyBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unAppKeyBufferLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Get the list of supported mime types for this application, comma-delimited ",
			"methodname": "GetApplicationSupportedMimeTypes",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchMimeTypesBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unMimeTypesBuffer",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Get the list of app-keys that support this mime type, comma-delimited, the return value is number of bytes you need to return the full string ",
			"methodname": "GetApplicationsThatSupportMimeType",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchMimeType",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchAppKeysThatSupportBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unAppKeysThatSupportBuffer",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Get the args list from an app launch that had the process already running, you call this when you get a VREvent_ApplicationMimeTypeLoad ",
			"methodname": "GetApplicationLaunchArguments",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "unHandle",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchArgs",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unArgs",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns the app key for the application that is starting up ",
			"methodname": "GetStartingApplication",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchAppKeyBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unAppKeyBufferLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns the application transition state ",
			"methodname": "GetSceneApplicationState",
			"returntype": "vr::EVRSceneApplicationState"
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns errors that would prevent the specified application from launching immediately. Calling this function will cause the current scene application to quit, so only call it when you are actually about to launch something else. What the caller should do about these failures depends on the failure:\n VRApplicationError_OldApplicationQuitting - An existing application has been told to quit. Wait for a VREvent_ProcessQuit and try again.\n VRApplicationError_ApplicationAlreadyStarting - This application is already starting. This is a permanent failure.\n VRApplicationError_LaunchInProgress      - A different application is already starting. This is a permanent failure.\n VRApplicationError_None                   - Go ahead and launch. Everything is clear.",
			"methodname": "PerformApplicationPrelaunchCheck",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns a string for an application transition state ",
			"methodname": "GetSceneApplicationStateNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "state",
					"paramtype": "vr::EVRSceneApplicationState"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Starts a subprocess within the calling application. This suppresses all application transition UI and automatically identifies the new executable  as part of the same application. On success the calling process should exit immediately.  If working directory is NULL or \"\" the directory portion of the binary path will be  the working directory. ",
			"methodname": "LaunchInternalProcess",
			"returntype": "vr::EVRApplicationError",
			"params": [
				{
					"paramname": "pchBinaryPath",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchArguments",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchWorkingDirectory",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRApplications",
			"doc": "Returns the current scene process ID according to the application system. A scene process will get scene focus once it starts rendering, but it will appear here once it calls VR_Init with the Scene application type. ",
			"methodname": "GetCurrentSceneProcessId",
			"returntype": "uint32_t"
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Get the current state of Chaperone calibration. This state can change at any time during a session due to physical base station changes.",
			"methodname": "GetCalibrationState",
			"returntype": "vr::ChaperoneCalibrationState"
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Returns the width and depth of the Play Area (formerly named Soft Bounds) in X and Z. Tracking space center (0,0,0) is the center of the Play Area.",
			"methodname": "GetPlayAreaSize",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pSizeX",
					"paramtype": "float *"
				},
				{
					"paramname": "pSizeZ",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Returns the 4 corner positions of the Play Area (formerly named Soft Bounds).\nCorners are in counter-clockwise order.\nStanding center (0,0,0) is the center of the Play Area.\nIt's a rectangle.\n2 sides are parallel to the X axis and 2 sides are parallel to the Z axis.\nHeight of every corner is 0Y (on the floor).",
			"methodname": "GetPlayAreaRect",
			"returntype": "bool",
			"params": [
				{
					"paramname": "rect",
					"paramtype": "struct vr::HmdQuad_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Reload Chaperone data from the .vrchap file on disk.",
			"methodname": "ReloadInfo",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Optionally give the chaperone system a hit about the color and brightness in the scene ",
			"methodname": "SetSceneColor",
			"returntype": "void",
			"params": [
				{
					"paramname": "color",
					"paramtype": "struct vr::HmdColor_t"
				}
			]
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Get the current chaperone bounds draw color and brightness ",
			"methodname": "GetBoundsColor",
			"returntype": "void",
			"params": [
				{
					"paramname": "pOutputColorArray",
					"paramtype": "struct vr::HmdColor_t *"
				},
				{
					"paramname": "nNumOutputColors",
					"paramtype": "int"
				},
				{
					"paramname": "flCollisionBoundsFadeDistance",
					"paramtype": "float"
				},
				{
					"paramname": "pOutputCameraColor",
					"paramtype": "struct vr::HmdColor_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Determine whether the bounds are showing right now ",
			"methodname": "AreBoundsVisible",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRChaperone",
			"doc": "Force the bounds to show, mostly for utilities ",
			"methodname": "ForceBoundsVisible",
			"returntype": "void",
			"params": [
				{
					"paramname": "bForce",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Saves the current working copy to disk",
			"methodname": "CommitWorkingCopy",
			"returntype": "bool",
			"params": [
				{
					"paramname": "configFile",
					"paramtype": "vr::EChaperoneConfigFile"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Reverts the working copy to match the live chaperone calibration.\nTo modify existing data this MUST be do WHILE getting a non-error ChaperoneCalibrationStatus.\nOnly after this should you do gets and sets on the existing data.",
			"methodname": "RevertWorkingCopy",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Returns the width and depth of the Play Area (formerly named Soft Bounds) in X and Z from the working copy. Tracking space center (0,0,0) is the center of the Play Area.",
			"methodname": "GetWorkingPlayAreaSize",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pSizeX",
					"paramtype": "float *"
				},
				{
					"paramname": "pSizeZ",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Returns the 4 corner positions of the Play Area (formerly named Soft Bounds) from the working copy.\nCorners are in clockwise order.\nTracking space center (0,0,0) is the center of the Play Area.\nIt's a rectangle.\n2 sides are parallel to the X axis and 2 sides are parallel to the Z axis.\nHeight of every corner is 0Y (on the floor).",
			"methodname": "GetWorkingPlayAreaRect",
			"returntype": "bool",
			"params": [
				{
					"paramname": "rect",
					"paramtype": "struct vr::HmdQuad_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Returns the number of Quads if the buffer points to null. Otherwise it returns Quads into the buffer up to the max specified from the working copy.",
			"methodname": "GetWorkingCollisionBoundsInfo",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pQuadsBuffer",
					"out_array_count": "punQuadsCount",
					"paramtype": "struct vr::HmdQuad_t *"
				},
				{
					"paramname": "punQuadsCount",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Returns the number of Quads if the buffer points to null. Otherwise it returns Quads into the buffer up to the max specified.",
			"methodname": "GetLiveCollisionBoundsInfo",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pQuadsBuffer",
					"out_array_count": "punQuadsCount",
					"paramtype": "struct vr::HmdQuad_t *"
				},
				{
					"paramname": "punQuadsCount",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Returns the preferred seated position from the working copy.",
			"methodname": "GetWorkingSeatedZeroPoseToRawTrackingPose",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pmatSeatedZeroPoseToRawTrackingPose",
					"paramtype": "struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Returns the standing origin from the working copy.",
			"methodname": "GetWorkingStandingZeroPoseToRawTrackingPose",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pmatStandingZeroPoseToRawTrackingPose",
					"paramtype": "struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Sets the Play Area in the working copy.",
			"methodname": "SetWorkingPlayAreaSize",
			"returntype": "void",
			"params": [
				{
					"paramname": "sizeX",
					"paramtype": "float"
				},
				{
					"paramname": "sizeZ",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Sets the Collision Bounds in the working copy. Note: ceiling height is ignored.",
			"methodname": "SetWorkingCollisionBoundsInfo",
			"returntype": "void",
			"params": [
				{
					"paramname": "pQuadsBuffer",
					"array_count": "unQuadsCount",
					"paramtype": "struct vr::HmdQuad_t *"
				},
				{
					"paramname": "unQuadsCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Sets the Collision Bounds in the working copy.",
			"methodname": "SetWorkingPerimeter",
			"returntype": "void",
			"params": [
				{
					"paramname": "pPointBuffer",
					"array_count": "unPointCount",
					"paramtype": "struct vr::HmdVector2_t *"
				},
				{
					"paramname": "unPointCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Sets the preferred seated position in the working copy.",
			"methodname": "SetWorkingSeatedZeroPoseToRawTrackingPose",
			"returntype": "void",
			"params": [
				{
					"paramname": "pMatSeatedZeroPoseToRawTrackingPose",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Sets the preferred standing position in the working copy.",
			"methodname": "SetWorkingStandingZeroPoseToRawTrackingPose",
			"returntype": "void",
			"params": [
				{
					"paramname": "pMatStandingZeroPoseToRawTrackingPose",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Tear everything down and reload it from the file on disk",
			"methodname": "ReloadFromDisk",
			"returntype": "void",
			"params": [
				{
					"paramname": "configFile",
					"paramtype": "vr::EChaperoneConfigFile"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Returns the preferred seated position.",
			"methodname": "GetLiveSeatedZeroPoseToRawTrackingPose",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pmatSeatedZeroPoseToRawTrackingPose",
					"paramtype": "struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"methodname": "ExportLiveToBuffer",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "pnBufferLength",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"methodname": "ImportFromBufferToWorking",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pBuffer",
					"paramtype": "const char *"
				},
				{
					"paramname": "nImportFlags",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Shows the chaperone data in the working set to preview in the compositor.",
			"methodname": "ShowWorkingSetPreview",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Hides the chaperone data in the working set to preview in the compositor (if it was visible).",
			"methodname": "HideWorkingSetPreview",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRChaperoneSetup",
			"doc": "Fire an event that the tracking system can use to know room setup is about to begin. This lets the tracking system make any last minute adjustments that should be incorporated into the new setup.  If the user is adjusting live in HMD using a tweak tool, keep in mind that calling this might cause the user to see the room jump.",
			"methodname": "RoomSetupStarting",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Sets tracking space returned by WaitGetPoses",
			"methodname": "SetTrackingSpace",
			"returntype": "void",
			"params": [
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Gets current tracking space returned by WaitGetPoses",
			"methodname": "GetTrackingSpace",
			"returntype": "vr::ETrackingUniverseOrigin"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Scene applications should call this function to get poses to render with (and optionally poses predicted an additional frame out to use for gameplay). This function will block until \"running start\" milliseconds before the start of the frame, and should be called at the last moment before needing to start rendering.\nReturn codes:\n - IsNotSceneApplication (make sure to call VR_Init with VRApplicaiton_Scene)\n - DoNotHaveFocus (some other app has taken focus - this will throttle the call to 10hz to reduce the impact on that app)",
			"methodname": "WaitGetPoses",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "pRenderPoseArray",
					"array_count": "unRenderPoseArrayCount",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "unRenderPoseArrayCount",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pGamePoseArray",
					"array_count": "unGamePoseArrayCount",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "unGamePoseArrayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Get the last set of poses returned by WaitGetPoses.",
			"methodname": "GetLastPoses",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "pRenderPoseArray",
					"array_count": "unRenderPoseArrayCount",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "unRenderPoseArrayCount",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pGamePoseArray",
					"array_count": "unGamePoseArrayCount",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "unGamePoseArrayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Interface for accessing last set of poses returned by WaitGetPoses one at a time.\n Returns VRCompositorError_IndexOutOfRange if unDeviceIndex not less than k_unMaxTrackedDeviceCount otherwise VRCompositorError_None.\n It is okay to pass NULL for either pose if you only want one of the values.",
			"methodname": "GetLastPoseForTrackedDeviceIndex",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pOutputPose",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "pOutputGamePose",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Updated scene texture to display. If pBounds is NULL the entire texture will be used.  If called from an OpenGL app, consider adding a glFlush after Submitting both frames to signal the driver to start processing, otherwise it may wait until the command buffer fills up, causing the app to miss frames.\n OpenGL dirty state:\n glBindTexture\n Return codes:\n - IsNotSceneApplication (make sure to call VR_Init with VRApplicaiton_Scene)\n - DoNotHaveFocus (some other app has taken focus)\n - TextureIsOnWrongDevice (application did not use proper AdapterIndex - see IVRSystem.GetDXGIOutputInfo)\n - SharedTexturesNotSupported (application needs to call CreateDXGIFactory1 or later before creating DX device)\n - TextureUsesUnsupportedFormat (scene textures must be compatible with DXGI sharing rules - e.g. uncompressed, no mips, etc.)\n - InvalidTexture (usually means bad arguments passed in)\n - AlreadySubmitted (app has submitted two left textures or two right textures in a single frame - i.e. before calling WaitGetPoses again)",
			"methodname": "Submit",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "pTexture",
					"paramtype": "const struct vr::Texture_t *"
				},
				{
					"paramname": "pBounds",
					"paramtype": "const struct vr::VRTextureBounds_t *"
				},
				{
					"paramname": "nSubmitFlags",
					"paramtype": "vr::EVRSubmitFlags"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Clears the frame that was sent with the last call to Submit. This will cause the compositor to show the grid until Submit is called again.",
			"methodname": "ClearLastSubmittedFrame",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Call immediately after presenting your app's window (i.e. companion window) to unblock the compositor. This is an optional call, which only needs to be used if you can't instead call WaitGetPoses immediately after Present. For example, if your engine's render and game loop are not on separate threads, or blocking the render thread until 3ms before the next vsync would introduce a deadlock of some sort.  This function tells the compositor that you have finished all rendering after having Submitted buffers for both eyes, and it is free to start its rendering work.  This should only be called from the same thread you are rendering on.",
			"methodname": "PostPresentHandoff",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Returns true if timing data is filled it.  Sets oldest timing info if nFramesAgo is larger than the stored history. Be sure to set timing.size = sizeof(Compositor_FrameTiming) on struct passed in before calling this function.",
			"methodname": "GetFrameTiming",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pTiming",
					"paramtype": "struct vr::Compositor_FrameTiming *"
				},
				{
					"paramname": "unFramesAgo",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Interface for copying a range of timing data.  Frames are returned in ascending order (oldest to newest) with the last being the most recent frame. Only the first entry's m_nSize needs to be set, as the rest will be inferred from that.  Returns total number of entries filled out.",
			"methodname": "GetFrameTimings",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pTiming",
					"array_count": "nFrames",
					"paramtype": "struct vr::Compositor_FrameTiming *"
				},
				{
					"paramname": "nFrames",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Returns the time in seconds left in the current (as identified by FrameTiming's frameIndex) frame. Due to \"running start\", this value may roll over to the next frame before ever reaching 0.0.",
			"methodname": "GetFrameTimeRemaining",
			"returntype": "float"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Fills out stats accumulated for the last connected application.  Pass in sizeof( Compositor_CumulativeStats ) as second parameter.",
			"methodname": "GetCumulativeStats",
			"returntype": "void",
			"params": [
				{
					"paramname": "pStats",
					"paramtype": "struct vr::Compositor_CumulativeStats *"
				},
				{
					"paramname": "nStatsSizeInBytes",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Fades the view on the HMD to the specified color. The fade will take fSeconds, and the color values are between 0.0 and 1.0. This color is faded on top of the scene based on the alpha parameter. Removing the fade color instantly  would be FadeToColor( 0.0, 0.0, 0.0, 0.0, 0.0 ).  Values are in un-premultiplied alpha space.",
			"methodname": "FadeToColor",
			"returntype": "void",
			"params": [
				{
					"paramname": "fSeconds",
					"paramtype": "float"
				},
				{
					"paramname": "fRed",
					"paramtype": "float"
				},
				{
					"paramname": "fGreen",
					"paramtype": "float"
				},
				{
					"paramname": "fBlue",
					"paramtype": "float"
				},
				{
					"paramname": "fAlpha",
					"paramtype": "float"
				},
				{
					"paramname": "bBackground",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Get current fade color value.",
			"methodname": "GetCurrentFadeColor",
			"returntype": "struct vr::HmdColor_t",
			"params": [
				{
					"paramname": "bBackground",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Fading the Grid in or out in fSeconds",
			"methodname": "FadeGrid",
			"returntype": "void",
			"params": [
				{
					"paramname": "fSeconds",
					"paramtype": "float"
				},
				{
					"paramname": "bFadeIn",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Get current alpha value of grid.",
			"methodname": "GetCurrentGridAlpha",
			"returntype": "float"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Override the skybox used in the compositor (e.g. for during level loads when the app can't feed scene images fast enough) Order is Front, Back, Left, Right, Top, Bottom.  If only a single texture is passed, it is assumed in lat-long format. If two are passed, it is assumed a lat-long stereo pair.",
			"methodname": "SetSkyboxOverride",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "pTextures",
					"array_count": "unTextureCount",
					"paramtype": "const struct vr::Texture_t *"
				},
				{
					"paramname": "unTextureCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Resets compositor skybox back to defaults.",
			"methodname": "ClearSkyboxOverride",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Brings the compositor window to the front. This is useful for covering any other window that may be on the HMD and is obscuring the compositor window.",
			"methodname": "CompositorBringToFront",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Pushes the compositor window to the back. This is useful for allowing other applications to draw directly to the HMD.",
			"methodname": "CompositorGoToBack",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Tells the compositor process to clean up and exit. You do not need to call this function at shutdown. Under normal  circumstances the compositor will manage its own life cycle based on what applications are running.",
			"methodname": "CompositorQuit",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Return whether the compositor is fullscreen",
			"methodname": "IsFullscreen",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Returns the process ID of the process that is currently rendering the scene",
			"methodname": "GetCurrentSceneFocusProcess",
			"returntype": "uint32_t"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Returns the process ID of the process that rendered the last frame (or 0 if the compositor itself rendered the frame.) Returns 0 when fading out from an app and the app's process Id when fading into an app.",
			"methodname": "GetLastFrameRenderer",
			"returntype": "uint32_t"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Returns true if the current process has the scene focus",
			"methodname": "CanRenderScene",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "DEPRECATED: Opens the headset view (as either a window or docked widget depending on user's preferences) that displays what the user sees in the headset.",
			"methodname": "ShowMirrorWindow",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "DEPRECATED: Closes the headset view, either as a window or docked widget.",
			"methodname": "HideMirrorWindow",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "DEPRECATED: Returns true if the headset view (either as a window or docked widget) is shown.",
			"methodname": "IsMirrorWindowVisible",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Writes back buffer and stereo left/right pair from the application to a 'screenshots' folder in the SteamVR runtime root.",
			"methodname": "CompositorDumpImages",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Let an app know it should be rendering with low resources.",
			"methodname": "ShouldAppRenderWithLowResources",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Override interleaved reprojection logic to force on.",
			"methodname": "ForceInterleavedReprojectionOn",
			"returntype": "void",
			"params": [
				{
					"paramname": "bOverride",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Force reconnecting to the compositor process.",
			"methodname": "ForceReconnectProcess",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Temporarily suspends rendering (useful for finer control over scene transitions).",
			"methodname": "SuspendRendering",
			"returntype": "void",
			"params": [
				{
					"paramname": "bSuspend",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Opens a shared D3D11 texture with the undistorted composited image for each eye.  Use ReleaseMirrorTextureD3D11 when finished instead of calling Release on the resource itself.",
			"methodname": "GetMirrorTextureD3D11",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "pD3D11DeviceOrResource",
					"paramtype": "void *"
				},
				{
					"paramname": "ppD3D11ShaderResourceView",
					"paramtype": "void **"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"methodname": "ReleaseMirrorTextureD3D11",
			"returntype": "void",
			"params": [
				{
					"paramname": "pD3D11ShaderResourceView",
					"paramtype": "void *"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Access to mirror textures from OpenGL.",
			"methodname": "GetMirrorTextureGL",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "eEye",
					"paramtype": "vr::EVREye"
				},
				{
					"paramname": "pglTextureId",
					"paramtype": "vr::glUInt_t *"
				},
				{
					"paramname": "pglSharedTextureHandle",
					"paramtype": "vr::glSharedTextureHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"methodname": "ReleaseSharedGLTexture",
			"returntype": "bool",
			"params": [
				{
					"paramname": "glTextureId",
					"paramtype": "vr::glUInt_t"
				},
				{
					"paramname": "glSharedTextureHandle",
					"paramtype": "vr::glSharedTextureHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"methodname": "LockGLSharedTextureForAccess",
			"returntype": "void",
			"params": [
				{
					"paramname": "glSharedTextureHandle",
					"paramtype": "vr::glSharedTextureHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"methodname": "UnlockGLSharedTextureForAccess",
			"returntype": "void",
			"params": [
				{
					"paramname": "glSharedTextureHandle",
					"paramtype": "vr::glSharedTextureHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "[Vulkan Only]\nreturn 0. Otherwise it returns the length of the number of bytes necessary to hold this string including the trailing null.  The string will be a space separated list of-required instance extensions to enable in VkCreateInstance",
			"methodname": "GetVulkanInstanceExtensionsRequired",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchValue",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "[Vulkan only]\nreturn 0. Otherwise it returns the length of the number of bytes necessary to hold this string including the trailing null.  The string will be a space separated list of required device extensions to enable in VkCreateDevice",
			"methodname": "GetVulkanDeviceExtensionsRequired",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pPhysicalDevice",
					"paramtype": "struct VkPhysicalDevice_T *"
				},
				{
					"paramname": "pchValue",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "[ Vulkan/D3D12 Only ]\nThere are two purposes for SetExplicitTimingMode:\n1. To get a more accurate GPU timestamp for when the frame begins in Vulkan/D3D12 applications.\n2. (Optional) To avoid having WaitGetPoses access the Vulkan queue so that the queue can be accessed from\nanother thread while WaitGetPoses is executing.\nMore accurate GPU timestamp for the start of the frame is achieved by the application calling SubmitExplicitTimingData immediately before its first submission to the Vulkan/D3D12 queue. This is more accurate because normally this GPU timestamp is recorded during WaitGetPoses.  In D3D11,  WaitGetPoses queues a GPU timestamp write, but it does not actually get submitted to the GPU until the  application flushes.  By using SubmitExplicitTimingData, the timestamp is recorded at the same place for  Vulkan/D3D12 as it is for D3D11, resulting in a more accurate GPU time measurement for the frame.\nAvoiding WaitGetPoses accessing the Vulkan queue can be achieved using SetExplicitTimingMode as well.  If this is desired, the application should set the timing mode to Explicit_ApplicationPerformsPostPresentHandoff and *MUSTcall PostPresentHandoff itself. If these conditions are met, then WaitGetPoses is guaranteed not to access the queue.  Note that PostPresentHandoff and SubmitExplicitTimingData will access the queue, so only WaitGetPoses becomes safe for accessing the queue from another thread.",
			"methodname": "SetExplicitTimingMode",
			"returntype": "void",
			"params": [
				{
					"paramname": "eTimingMode",
					"paramtype": "vr::EVRCompositorTimingMode"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "[ Vulkan/D3D12 Only ]\nSubmit explicit timing data.  When SetExplicitTimingMode is true, this must be called immediately before the application's first vkQueueSubmit (Vulkan) or ID3D12CommandQueue::ExecuteCommandLists (D3D12) of each frame. This function will insert a GPU timestamp write just before the application starts its rendering.  This function will perform a vkQueueSubmit on Vulkan so must not be done simultaneously with VkQueue operations on another thread. Returns VRCompositorError_RequestFailed if SetExplicitTimingMode is not enabled.",
			"methodname": "SubmitExplicitTimingData",
			"returntype": "vr::EVRCompositorError"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Indicates whether or not motion smoothing is enabled by the user settings. If you want to know if motion smoothing actually triggered due to a late frame, check Compositor_FrameTiming m_nReprojectionFlags & VRCompositor_ReprojectionMotion instead.",
			"methodname": "IsMotionSmoothingEnabled",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Indicates whether or not motion smoothing is supported by the current hardware.",
			"methodname": "IsMotionSmoothingSupported",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Indicates whether or not the current scene focus app is currently loading.  This is inferred from its use of FadeGrid to explicitly fade to the compositor to cover up the fact that it cannot render at a sustained full framerate during this time.",
			"methodname": "IsCurrentSceneFocusAppLoading",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Override the stage model used in the compositor to replace the grid.  RenderModelPath is a full path the an OBJ file to load. This file will be loaded asynchronously from disk and uploaded to the gpu by the runtime.  Once ready for rendering, the VREvent StageOverrideReady will be sent.  Use FadeToGrid to reveal.  Call ClearStageOverride to free the associated resources when finished. const ",
			"methodname": "SetStageOverride_Async",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "pchRenderModelPath",
					"paramtype": "const char *"
				},
				{
					"paramname": "pTransform",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				},
				{
					"paramname": "pRenderSettings",
					"paramtype": "const struct vr::Compositor_StageRenderSettings *"
				},
				{
					"paramname": "nSizeOfRenderSettings",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Resets the stage to its default user specified setting.",
			"methodname": "ClearStageOverride",
			"returntype": "void"
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Returns true if pBenchmarkResults is filled it.  Sets pBenchmarkResults with the result of the compositor benchmark. nSizeOfBenchmarkResults should be set to sizeof(Compositor_BenchmarkResults)",
			"methodname": "GetCompositorBenchmarkResults",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pBenchmarkResults",
					"paramtype": "struct vr::Compositor_BenchmarkResults *"
				},
				{
					"paramname": "nSizeOfBenchmarkResults",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Returns the frame id associated with the poses last returned by WaitGetPoses.  Deltas between IDs correspond to number of headset vsync intervals.",
			"methodname": "GetLastPosePredictionIDs",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "pRenderPosePredictionID",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pGamePosePredictionID",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRCompositor",
			"doc": "Get the most up-to-date predicted (or recorded - up to 100ms old) set of poses for a given frame id.",
			"methodname": "GetPosesForFrame",
			"returntype": "vr::EVRCompositorError",
			"params": [
				{
					"paramname": "unPosePredictionID",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pPoseArray",
					"array_count": "unPoseArrayCount",
					"paramtype": "struct vr::TrackedDevicePose_t *"
				},
				{
					"paramname": "unPoseArrayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Finds an existing overlay with the specified key.",
			"methodname": "FindOverlay",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "pchOverlayKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Creates a new named overlay. All overlays start hidden and with default settings.",
			"methodname": "CreateOverlay",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "pchOverlayKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchOverlayName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Destroys the specified overlay. When an application calls VR_Shutdown all overlays created by that app are automatically destroyed.",
			"methodname": "DestroyOverlay",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Fills the provided buffer with the string key of the overlay. Returns the size of buffer required to store the key, including the terminating null character. k_unVROverlayMaxKeyLength will be enough bytes to fit the string.",
			"methodname": "GetOverlayKey",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pchValue",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::EVROverlayError *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Fills the provided buffer with the friendly name of the overlay. Returns the size of buffer required to store the key, including the terminating null character. k_unVROverlayMaxNameLength will be enough bytes to fit the string.",
			"methodname": "GetOverlayName",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pchValue",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::EVROverlayError *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "set the name to use for this overlay",
			"methodname": "SetOverlayName",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pchName",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the raw image data from an overlay. Overlay image data is always returned as RGBA data, 4 bytes per pixel. If the buffer is not large enough, width and height  will be set and VROverlayError_ArrayTooSmall is returned.",
			"methodname": "GetOverlayImageData",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvBuffer",
					"paramtype": "void *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "punWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "punHeight",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "returns a string that corresponds with the specified overlay error. The string will be the name  of the error enum value for all valid error codes",
			"methodname": "GetOverlayErrorNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "error",
					"paramtype": "vr::EVROverlayError"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the pid that is allowed to render to this overlay (the creator pid is always allow to render), by default this is the pid of the process that made the overlay",
			"methodname": "SetOverlayRenderingPid",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "unPID",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the pid that is allowed to render to this overlay",
			"methodname": "GetOverlayRenderingPid",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Specify flag setting for a given overlay",
			"methodname": "SetOverlayFlag",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "eOverlayFlag",
					"paramtype": "vr::VROverlayFlags"
				},
				{
					"paramname": "bEnabled",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets flag setting for a given overlay",
			"methodname": "GetOverlayFlag",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "eOverlayFlag",
					"paramtype": "vr::VROverlayFlags"
				},
				{
					"paramname": "pbEnabled",
					"paramtype": "bool *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets all the flags for a given overlay",
			"methodname": "GetOverlayFlags",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pFlags",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the color tint of the overlay quad. Use 0.0 to 1.0 per channel.",
			"methodname": "SetOverlayColor",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "fRed",
					"paramtype": "float"
				},
				{
					"paramname": "fGreen",
					"paramtype": "float"
				},
				{
					"paramname": "fBlue",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the color tint of the overlay quad.",
			"methodname": "GetOverlayColor",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pfRed",
					"paramtype": "float *"
				},
				{
					"paramname": "pfGreen",
					"paramtype": "float *"
				},
				{
					"paramname": "pfBlue",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the alpha of the overlay quad. Use 1.0 for 100 percent opacity to 0.0 for 0 percent opacity.",
			"methodname": "SetOverlayAlpha",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "fAlpha",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the alpha of the overlay quad. By default overlays are rendering at 100 percent alpha (1.0).",
			"methodname": "GetOverlayAlpha",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pfAlpha",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the aspect ratio of the texels in the overlay. 1.0 means the texels are square. 2.0 means the texels are twice as wide as they are tall. Defaults to 1.0.",
			"methodname": "SetOverlayTexelAspect",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "fTexelAspect",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the aspect ratio of the texels in the overlay. Defaults to 1.0",
			"methodname": "GetOverlayTexelAspect",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pfTexelAspect",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the rendering sort order for the overlay. Overlays are rendered this order:\nOverlays owned by the scene application\nOverlays owned by some other application\nWithin a category overlays are rendered lowest sort order to highest sort order. Overlays with the same \nsort order are rendered back to front base on distance from the HMD.\nSort order defaults to 0.",
			"methodname": "SetOverlaySortOrder",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "unSortOrder",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the sort order of the overlay. See SetOverlaySortOrder for how this works.",
			"methodname": "GetOverlaySortOrder",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "punSortOrder",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the width of the overlay quad in meters. By default overlays are rendered on a quad that is 1 meter across",
			"methodname": "SetOverlayWidthInMeters",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "fWidthInMeters",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns the width of the overlay quad in meters. By default overlays are rendered on a quad that is 1 meter across",
			"methodname": "GetOverlayWidthInMeters",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pfWidthInMeters",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Use to draw overlay as a curved surface. Curvature is a percentage from (0..1] where 1 is a fully closed cylinder. For a specific radius, curvature can be computed as: overlay.width / (2 PI r).",
			"methodname": "SetOverlayCurvature",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "fCurvature",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns the curvature of the overlay as a percentage from (0..1] where 1 is a fully closed cylinder.",
			"methodname": "GetOverlayCurvature",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pfCurvature",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the colorspace the overlay texture's data is in.  Defaults to 'auto'. If the texture needs to be resolved, you should call SetOverlayTexture with the appropriate colorspace instead.",
			"methodname": "SetOverlayTextureColorSpace",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "eTextureColorSpace",
					"paramtype": "vr::EColorSpace"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the overlay's current colorspace setting.",
			"methodname": "GetOverlayTextureColorSpace",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "peTextureColorSpace",
					"paramtype": "vr::EColorSpace *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the part of the texture to use for the overlay. UV Min is the upper left corner and UV Max is the lower right corner.",
			"methodname": "SetOverlayTextureBounds",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pOverlayTextureBounds",
					"paramtype": "const struct vr::VRTextureBounds_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the part of the texture to use for the overlay. UV Min is the upper left corner and UV Max is the lower right corner.",
			"methodname": "GetOverlayTextureBounds",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pOverlayTextureBounds",
					"paramtype": "struct vr::VRTextureBounds_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns the transform type of this overlay.",
			"methodname": "GetOverlayTransformType",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "peTransformType",
					"paramtype": "vr::VROverlayTransformType *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the transform to absolute tracking origin.",
			"methodname": "SetOverlayTransformAbsolute",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "eTrackingOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "pmatTrackingOriginToOverlayTransform",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the transform if it is absolute. Returns an error if the transform is some other type.",
			"methodname": "GetOverlayTransformAbsolute",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "peTrackingOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin *"
				},
				{
					"paramname": "pmatTrackingOriginToOverlayTransform",
					"paramtype": "struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the transform to relative to the transform of the specified tracked device.",
			"methodname": "SetOverlayTransformTrackedDeviceRelative",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "unTrackedDevice",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pmatTrackedDeviceToOverlayTransform",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the transform if it is relative to a tracked device. Returns an error if the transform is some other type.",
			"methodname": "GetOverlayTransformTrackedDeviceRelative",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "punTrackedDevice",
					"paramtype": "vr::TrackedDeviceIndex_t *"
				},
				{
					"paramname": "pmatTrackedDeviceToOverlayTransform",
					"paramtype": "struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the transform to draw the overlay on a rendermodel component mesh instead of a quad. This will only draw when the system is drawing the device. Overlays with this transform type cannot receive mouse events.",
			"methodname": "SetOverlayTransformTrackedDeviceComponent",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pchComponentName",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the transform information when the overlay is rendering on a component.",
			"methodname": "GetOverlayTransformTrackedDeviceComponent",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "punDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t *"
				},
				{
					"paramname": "pchComponentName",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unComponentNameSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the transform if it is relative to another overlay. Returns an error if the transform is some other type.",
			"methodname": "GetOverlayTransformOverlayRelative",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "ulOverlayHandleParent",
					"paramtype": "vr::VROverlayHandle_t *"
				},
				{
					"paramname": "pmatParentOverlayToOverlayTransform",
					"paramtype": "struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the transform to relative to the transform of the specified overlay. This overlays visibility will also track the parents visibility",
			"methodname": "SetOverlayTransformOverlayRelative",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "ulOverlayHandleParent",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pmatParentOverlayToOverlayTransform",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the hotspot for the specified overlay when that overlay is used as a cursor. These are in texture space with 0,0 in the upper left corner of the texture and 1,1 in the lower right corner of the texture.",
			"methodname": "SetOverlayTransformCursor",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulCursorOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvHotspot",
					"paramtype": "const struct vr::HmdVector2_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets cursor hotspot/transform for the specified overlay",
			"methodname": "GetOverlayTransformCursor",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvHotspot",
					"paramtype": "struct vr::HmdVector2_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Shows the VR overlay.  For dashboard overlays, only the Dashboard Manager is allowed to call this.",
			"methodname": "ShowOverlay",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Hides the VR overlay.  For dashboard overlays, only the Dashboard Manager is allowed to call this.",
			"methodname": "HideOverlay",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns true if the overlay is visible.",
			"methodname": "IsOverlayVisible",
			"returntype": "bool",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Get the transform in 3d space associated with a specific 2d point in the overlay's coordinate space (where 0,0 is the lower left). -Z points out of the overlay",
			"methodname": "GetTransformForOverlayCoordinates",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "eTrackingOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "coordinatesInOverlay",
					"paramtype": "struct vr::HmdVector2_t"
				},
				{
					"paramname": "pmatTransform",
					"paramtype": "struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns true and fills the event with the next event on the overlay's event queue, if there is one.  If there are no events this method returns false. uncbVREvent should be the size in bytes of the VREvent_t struct",
			"methodname": "PollNextOverlayEvent",
			"returntype": "bool",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pEvent",
					"paramtype": "struct vr::VREvent_t *"
				},
				{
					"paramname": "uncbVREvent",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns the current input settings for the specified overlay.",
			"methodname": "GetOverlayInputMethod",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "peInputMethod",
					"paramtype": "vr::VROverlayInputMethod *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the input settings for the specified overlay.",
			"methodname": "SetOverlayInputMethod",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "eInputMethod",
					"paramtype": "vr::VROverlayInputMethod"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the mouse scaling factor that is used for mouse events. The actual texture may be a different size, but this is typically the size of the underlying UI in pixels.",
			"methodname": "GetOverlayMouseScale",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvecMouseScale",
					"paramtype": "struct vr::HmdVector2_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the mouse scaling factor that is used for mouse events. The actual texture may be a different size, but this is typically the size of the underlying UI in pixels (not in world space).",
			"methodname": "SetOverlayMouseScale",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvecMouseScale",
					"paramtype": "const struct vr::HmdVector2_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Computes the overlay-space pixel coordinates of where the ray intersects the overlay with the specified settings. Returns false if there is no intersection.",
			"methodname": "ComputeOverlayIntersection",
			"returntype": "bool",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pParams",
					"paramtype": "const struct vr::VROverlayIntersectionParams_t *"
				},
				{
					"paramname": "pResults",
					"paramtype": "struct vr::VROverlayIntersectionResults_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns true if the specified overlay is the hover target. An overlay is the hover target when it is the last overlay \"moused over\"  by the virtual mouse pointer",
			"methodname": "IsHoverTargetOverlay",
			"returntype": "bool",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets a list of primitives to be used for controller ray intersection typically the size of the underlying UI in pixels (not in world space).",
			"methodname": "SetOverlayIntersectionMask",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pMaskPrimitives",
					"paramtype": "struct vr::VROverlayIntersectionMaskPrimitive_t *"
				},
				{
					"paramname": "unNumMaskPrimitives",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unPrimitiveSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Triggers a haptic event on the laser mouse controller for the specified overlay",
			"methodname": "TriggerLaserMouseHapticVibration",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "fDurationSeconds",
					"paramtype": "float"
				},
				{
					"paramname": "fFrequency",
					"paramtype": "float"
				},
				{
					"paramname": "fAmplitude",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the cursor to use for the specified overlay. This will be drawn instead of the generic blob when the laser mouse is pointed at the specified overlay",
			"methodname": "SetOverlayCursor",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "ulCursorHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the override cursor position to use for this overlay in overlay mouse coordinates. This position will be used to draw the cursor instead of whatever the laser mouse cursor position is.",
			"methodname": "SetOverlayCursorPositionOverride",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvCursor",
					"paramtype": "const struct vr::HmdVector2_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Clears the override cursor position for this overlay",
			"methodname": "ClearOverlayCursorPositionOverride",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Texture to draw for the overlay. This function can only be called by the overlay's creator or renderer process (see SetOverlayRenderingPid) .\nOpenGL dirty state: glBindTexture",
			"methodname": "SetOverlayTexture",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pTexture",
					"paramtype": "const struct vr::Texture_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Use this to tell the overlay system to release the texture set for this overlay.",
			"methodname": "ClearOverlayTexture",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Separate interface for providing the data as a stream of bytes, but there is an upper bound on data that can be sent. This function can only be called by the overlay's renderer process.",
			"methodname": "SetOverlayRaw",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvBuffer",
					"paramtype": "void *"
				},
				{
					"paramname": "unWidth",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unHeight",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unBytesPerPixel",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Separate interface for providing the image through a filename: can be png or jpg, and should not be bigger than 1920x1080.\nThis function can only be called by the overlay's renderer process",
			"methodname": "SetOverlayFromFile",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pchFilePath",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Get the native texture handle/device for an overlay you have created. On windows this handle will be a ID3D11ShaderResourceView with a ID3D11Texture2D bound.\nThe texture will always be sized to match the backing texture you supplied in SetOverlayTexture above.\nYou MUST call ReleaseNativeOverlayHandle() with pNativeTextureHandle once you are done with this texture.\npNativeTextureHandle is an OUTPUT, it will be a pointer to a ID3D11ShaderResourceView *. pNativeTextureRef is an INPUT and should be a ID3D11Resource *. The device used by pNativeTextureRef will be used to bind pNativeTextureHandle.",
			"methodname": "GetOverlayTexture",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pNativeTextureHandle",
					"paramtype": "void **"
				},
				{
					"paramname": "pNativeTextureRef",
					"paramtype": "void *"
				},
				{
					"paramname": "pWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pHeight",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pNativeFormat",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pAPIType",
					"paramtype": "vr::ETextureType *"
				},
				{
					"paramname": "pColorSpace",
					"paramtype": "vr::EColorSpace *"
				},
				{
					"paramname": "pTextureBounds",
					"paramtype": "struct vr::VRTextureBounds_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Release the pNativeTextureHandle provided from the GetOverlayTexture call, this allows the system to free the underlying GPU resources for this object, so only do it once you stop rendering this texture.",
			"methodname": "ReleaseNativeOverlayHandle",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pNativeTextureHandle",
					"paramtype": "void *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Get the size of the overlay texture",
			"methodname": "GetOverlayTextureSize",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pHeight",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Creates a dashboard overlay and returns its handle",
			"methodname": "CreateDashboardOverlay",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "pchOverlayKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchOverlayFriendlyName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pMainHandle",
					"paramtype": "vr::VROverlayHandle_t *"
				},
				{
					"paramname": "pThumbnailHandle",
					"paramtype": "vr::VROverlayHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns true if the dashboard is visible",
			"methodname": "IsDashboardVisible",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "returns true if the dashboard is visible and the specified overlay is the active system Overlay",
			"methodname": "IsActiveDashboardOverlay",
			"returntype": "bool",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Sets the dashboard overlay to only appear when the specified process ID has scene focus",
			"methodname": "SetDashboardOverlaySceneProcess",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "unProcessId",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Gets the process ID that this dashboard overlay requires to have scene focus",
			"methodname": "GetDashboardOverlaySceneProcess",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "punProcessId",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Shows the dashboard.",
			"methodname": "ShowDashboard",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchOverlayToShow",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Returns the tracked device that has the laser pointer in the dashboard",
			"methodname": "GetPrimaryDashboardDevice",
			"returntype": "vr::TrackedDeviceIndex_t"
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Show the virtual keyboard to accept input. In most cases, you should pass KeyboardFlag_Modal to enable modal overlay behavior on the keyboard itself. See EKeyboardFlags for more.",
			"methodname": "ShowKeyboard",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "eInputMode",
					"paramtype": "vr::EGamepadTextInputMode"
				},
				{
					"paramname": "eLineInputMode",
					"paramtype": "vr::EGamepadTextInputLineMode"
				},
				{
					"paramname": "unFlags",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchDescription",
					"paramtype": "const char *"
				},
				{
					"paramname": "unCharMax",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchExistingText",
					"paramtype": "const char *"
				},
				{
					"paramname": "uUserValue",
					"paramtype": "uint64_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Show the virtual keyboard to accept input for an overlay. In most cases, you should pass KeyboardFlag_Modal to enable modal overlay behavior on the keyboard itself. See EKeyboardFlags for more.",
			"methodname": "ShowKeyboardForOverlay",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "eInputMode",
					"paramtype": "vr::EGamepadTextInputMode"
				},
				{
					"paramname": "eLineInputMode",
					"paramtype": "vr::EGamepadTextInputLineMode"
				},
				{
					"paramname": "unFlags",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchDescription",
					"paramtype": "const char *"
				},
				{
					"paramname": "unCharMax",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchExistingText",
					"paramtype": "const char *"
				},
				{
					"paramname": "uUserValue",
					"paramtype": "uint64_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Get the text that was entered into the text input",
			"methodname": "GetKeyboardText",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchText",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "cchText",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Hide the virtual keyboard",
			"methodname": "HideKeyboard",
			"returntype": "void"
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Set the position of the keyboard in world space",
			"methodname": "SetKeyboardTransformAbsolute",
			"returntype": "void",
			"params": [
				{
					"paramname": "eTrackingOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "pmatTrackingOriginToKeyboardTransform",
					"paramtype": "const struct vr::HmdMatrix34_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Set the position of the keyboard in overlay space by telling it to avoid a rectangle in the overlay. Rectangle coords have (0,0) in the bottom left *",
			"methodname": "SetKeyboardPositionForOverlay",
			"returntype": "void",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "avoidRect",
					"paramtype": "struct vr::HmdRect2_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "Show the message overlay. This will block and return you a result.",
			"methodname": "ShowMessageOverlay",
			"returntype": "vr::VRMessageOverlayResponse",
			"params": [
				{
					"paramname": "pchText",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchCaption",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchButton0Text",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchButton1Text",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchButton2Text",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchButton3Text",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVROverlay",
			"doc": "If the calling process owns the overlay and it's open, this will close it.",
			"methodname": "CloseMessageOverlay",
			"returntype": "void"
		},
		{
			"classname": "vr::IVROverlayView",
			"doc": "Acquire an OverlayView_t from an overlay handle\nThe overlay view can be used to sample the contents directly by a native API. The contents of the OverlayView_t will remain unchanged through the lifetime of the OverlayView_t.\nThe caller acquires read privileges over the OverlayView_t, but should not write to it.\nAcquireOverlayView() may be called on the same ulOverlayHandle multiple times to refresh the image contents. In this case the caller is strongly encouraged to re-use the same pOverlayView for all re-acquisition calls.\nIf the producer has not yet queued an image, AcquireOverlayView will return success, and the Texture_t will have the expected ETextureType. However, the Texture_t->handle will be nullptr. Once the producer generates the first overlay frame, Texture_t->handle will become a valid handle.",
			"methodname": "AcquireOverlayView",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pNativeDevice",
					"paramtype": "struct vr::VRNativeDevice_t *"
				},
				{
					"paramname": "pOverlayView",
					"paramtype": "struct vr::VROverlayView_t *"
				},
				{
					"paramname": "unOverlayViewSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVROverlayView",
			"doc": "Release an acquired OverlayView_t\nDenotes that pOverlayView will no longer require access to the resources it acquired in all previous calls to AcquireOverlayView().\nAll OverlayView_t*'s provided to AcquireOverlayView() as pOverlayViews must be passed into ReleaseOverlayView() in order for the underlying GPU resources to be freed.",
			"methodname": "ReleaseOverlayView",
			"returntype": "vr::EVROverlayError",
			"params": [
				{
					"paramname": "pOverlayView",
					"paramtype": "struct vr::VROverlayView_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlayView",
			"doc": "Posts an overlay event",
			"methodname": "PostOverlayEvent",
			"returntype": "void",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "pvrEvent",
					"paramtype": "const struct vr::VREvent_t *"
				}
			]
		},
		{
			"classname": "vr::IVROverlayView",
			"doc": "Determines whether this process is permitted to view an overlay's content.",
			"methodname": "IsViewingPermitted",
			"returntype": "bool",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Sets the resolution in pixels to render the headset view. These values are clamped to k_unHeadsetViewMaxWidth and k_unHeadsetViewMaxHeight respectively. For cropped views, the rendered output will be fit to aspect ratio defined by the the specified dimensions. For uncropped views, the caller should use GetHeadsetViewAspectRation to adjust the requested render size to avoid squashing or stretching, and then apply letterboxing to compensate when displaying the results.",
			"methodname": "SetHeadsetViewSize",
			"returntype": "void",
			"params": [
				{
					"paramname": "nWidth",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "nHeight",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Gets the current resolution used to render the headset view.",
			"methodname": "GetHeadsetViewSize",
			"returntype": "void",
			"params": [
				{
					"paramname": "pnWidth",
					"paramtype": "uint32_t *"
				},
				{
					"paramname": "pnHeight",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Set the mode used to render the headset view.",
			"methodname": "SetHeadsetViewMode",
			"returntype": "void",
			"params": [
				{
					"paramname": "eHeadsetViewMode",
					"paramtype": "vr::HeadsetViewMode_t"
				}
			]
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Get the current mode used to render the headset view.",
			"methodname": "GetHeadsetViewMode",
			"returntype": "vr::HeadsetViewMode_t"
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Set whether or not the headset view should be rendered cropped to hide the hidden area mesh or not.",
			"methodname": "SetHeadsetViewCropped",
			"returntype": "void",
			"params": [
				{
					"paramname": "bCropped",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Get the current cropping status of the headset view.",
			"methodname": "GetHeadsetViewCropped",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Get the aspect ratio (width:height) of the uncropped headset view (accounting for the current set mode).",
			"methodname": "GetHeadsetViewAspectRatio",
			"returntype": "float"
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Set the range [0..1] that the headset view blends across the stereo overlapped area in cropped both mode.",
			"methodname": "SetHeadsetViewBlendRange",
			"returntype": "void",
			"params": [
				{
					"paramname": "flStartPct",
					"paramtype": "float"
				},
				{
					"paramname": "flEndPct",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVRHeadsetView",
			"doc": "Get the current range [0..1] that the headset view blends across the stereo overlapped area in cropped both mode.",
			"methodname": "GetHeadsetViewBlendRange",
			"returntype": "void",
			"params": [
				{
					"paramname": "pStartPct",
					"paramtype": "float *"
				},
				{
					"paramname": "pEndPct",
					"paramtype": "float *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Loads and returns a render model for use in the application. pchRenderModelName should be a render model name from the Prop_RenderModelName_String property or an absolute path name to a render model on disk.\nThe resulting render model is valid until VR_Shutdown() is called or until FreeRenderModel() is called. When the  application is finished with the render model it should call FreeRenderModel() to free the memory associated with the model.\nThe method returns VRRenderModelError_Loading while the render model is still being loaded. The method returns VRRenderModelError_None once loaded successfully, otherwise will return an error.",
			"methodname": "LoadRenderModel_Async",
			"returntype": "vr::EVRRenderModelError",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "ppRenderModel",
					"paramtype": "struct vr::RenderModel_t **"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Frees a previously returned render model\nIt is safe to call this on a null ptr.",
			"methodname": "FreeRenderModel",
			"returntype": "void",
			"params": [
				{
					"paramname": "pRenderModel",
					"paramtype": "struct vr::RenderModel_t *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Loads and returns a texture for use in the application.",
			"methodname": "LoadTexture_Async",
			"returntype": "vr::EVRRenderModelError",
			"params": [
				{
					"paramname": "textureId",
					"paramtype": "vr::TextureID_t"
				},
				{
					"paramname": "ppTexture",
					"paramtype": "struct vr::RenderModel_TextureMap_t **"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Frees a previously returned texture\nIt is safe to call this on a null ptr.",
			"methodname": "FreeTexture",
			"returntype": "void",
			"params": [
				{
					"paramname": "pTexture",
					"paramtype": "struct vr::RenderModel_TextureMap_t *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Creates a D3D11 texture and loads data into it.",
			"methodname": "LoadTextureD3D11_Async",
			"returntype": "vr::EVRRenderModelError",
			"params": [
				{
					"paramname": "textureId",
					"paramtype": "vr::TextureID_t"
				},
				{
					"paramname": "pD3D11Device",
					"paramtype": "void *"
				},
				{
					"paramname": "ppD3D11Texture2D",
					"paramtype": "void **"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Helper function to copy the bits into an existing texture.",
			"methodname": "LoadIntoTextureD3D11_Async",
			"returntype": "vr::EVRRenderModelError",
			"params": [
				{
					"paramname": "textureId",
					"paramtype": "vr::TextureID_t"
				},
				{
					"paramname": "pDstTexture",
					"paramtype": "void *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Use this to free textures created with LoadTextureD3D11_Async instead of calling Release on them.",
			"methodname": "FreeTextureD3D11",
			"returntype": "void",
			"params": [
				{
					"paramname": "pD3D11Texture2D",
					"paramtype": "void *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Use this to get the names of available render models.  Index does not correlate to a tracked device index, but is only used for iterating over all available render models.  If the index is out of range, this function will return 0.\nOtherwise, it will return the size of the buffer required for the name.",
			"methodname": "GetRenderModelName",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "unRenderModelIndex",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchRenderModelName",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unRenderModelNameLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Returns the number of available render models.",
			"methodname": "GetRenderModelCount",
			"returntype": "uint32_t"
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Returns the number of components of the specified render model. Components are useful when client application wish to draw, label, or otherwise interact with components of tracked objects. Examples controller components:\n  renderable things such as triggers, buttons\n  non-renderable things which include coordinate systems such as 'tip', 'base', a neutral controller agnostic hand-pose\n  If all controller components are enumerated and rendered, it will be equivalent to drawing the traditional render model\n  Returns 0 if components not supported, >0 otherwise",
			"methodname": "GetComponentCount",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Use this to get the names of available components.  Index does not correlate to a tracked device index, but is only used for iterating over all available components.  If the index is out of range, this function will return 0.\nOtherwise, it will return the size of the buffer required for the name.",
			"methodname": "GetComponentName",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "unComponentIndex",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pchComponentName",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unComponentNameLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Get the button mask for all buttons associated with this component\nIf no buttons (or axes) are associated with this component, return 0\nNote: multiple components may be associated with the same button. Ex: two grip buttons on a single controller.\nNote: A single component may be associated with multiple buttons. Ex: A trackpad which also provides \"D-pad\" functionality",
			"methodname": "GetComponentButtonMask",
			"returntype": "uint64_t",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchComponentName",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Use this to get the render model name for the specified rendermode/component combination, to be passed to LoadRenderModel.\nIf the component name is out of range, this function will return 0.\nOtherwise, it will return the size of the buffer required for the name.",
			"methodname": "GetComponentRenderModelName",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchComponentName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchComponentRenderModelName",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unComponentRenderModelNameLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Use this to query information about the component, as a function of the controller state.\nFor dynamic controller components (ex: trigger) values will reflect component motions\nFor static components this will return a consistent value independent of the VRControllerState_t\nIf the pchRenderModelName or pchComponentName is invalid, this will return false (and transforms will be set to identity).\nOtherwise, return true\nNote: For dynamic objects, visibility may be dynamic. (I.e., true/false will be returned based on controller state and controller mode state )",
			"methodname": "GetComponentStateForDevicePath",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchComponentName",
					"paramtype": "const char *"
				},
				{
					"paramname": "devicePath",
					"paramtype": "vr::VRInputValueHandle_t"
				},
				{
					"paramname": "pState",
					"paramtype": "const vr::RenderModel_ControllerMode_State_t *"
				},
				{
					"paramname": "pComponentState",
					"paramtype": "vr::RenderModel_ComponentState_t *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "This version of GetComponentState takes a controller state block instead of an action origin. This function is deprecated. You should use the new input system and GetComponentStateForDevicePath instead.",
			"methodname": "GetComponentState",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchComponentName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pControllerState",
					"paramtype": "const vr::VRControllerState_t *"
				},
				{
					"paramname": "pState",
					"paramtype": "const struct vr::RenderModel_ControllerMode_State_t *"
				},
				{
					"paramname": "pComponentState",
					"paramtype": "struct vr::RenderModel_ComponentState_t *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Returns true if the render model has a component with the specified name",
			"methodname": "RenderModelHasComponent",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchComponentName",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Returns the URL of the thumbnail image for this rendermodel",
			"methodname": "GetRenderModelThumbnailURL",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchThumbnailURL",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unThumbnailURLLen",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRRenderModelError *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Provides a render model path that will load the unskinned model if the model name provided has been replace by the user. If the model hasn't been replaced the path value will still be a valid path to load the model. Pass this to LoadRenderModel_Async, etc. to load the model.",
			"methodname": "GetRenderModelOriginalPath",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchOriginalPath",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unOriginalPathLen",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRRenderModelError *"
				}
			]
		},
		{
			"classname": "vr::IVRRenderModels",
			"doc": "Returns a string for a render model error",
			"methodname": "GetRenderModelErrorNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "error",
					"paramtype": "vr::EVRRenderModelError"
				}
			]
		},
		{
			"classname": "vr::IVRNotifications",
			"doc": "Create a notification and enqueue it to be shown to the user. An overlay handle is required to create a notification, as otherwise it would be impossible for a user to act on it. To create a two-line notification, use a line break ('\n') to split the text into two lines. The pImage argument may be NULL, in which case the specified overlay's icon will be used instead.",
			"methodname": "CreateNotification",
			"returntype": "vr::EVRNotificationError",
			"params": [
				{
					"paramname": "ulOverlayHandle",
					"paramtype": "vr::VROverlayHandle_t"
				},
				{
					"paramname": "ulUserValue",
					"paramtype": "uint64_t"
				},
				{
					"paramname": "type",
					"paramtype": "vr::EVRNotificationType"
				},
				{
					"paramname": "pchText",
					"paramtype": "const char *"
				},
				{
					"paramname": "style",
					"paramtype": "vr::EVRNotificationStyle"
				},
				{
					"paramname": "pImage",
					"paramtype": "const struct vr::NotificationBitmap_t *"
				},
				{
					"paramname": "pNotificationId",
					"paramtype": "vr::VRNotificationId *"
				}
			]
		},
		{
			"classname": "vr::IVRNotifications",
			"doc": "Destroy a notification, hiding it first if it currently shown to the user.",
			"methodname": "RemoveNotification",
			"returntype": "vr::EVRNotificationError",
			"params": [
				{
					"paramname": "notificationId",
					"paramtype": "vr::VRNotificationId"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "GetSettingsErrorNameFromEnum",
			"returntype": "const char *",
			"params": [
				{
					"paramname": "eError",
					"paramtype": "vr::EVRSettingsError"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "SetBool",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "bValue",
					"paramtype": "bool"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "SetInt32",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "nValue",
					"paramtype": "int32_t"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "SetFloat",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "flValue",
					"paramtype": "float"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "SetString",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchValue",
					"paramtype": "const char *"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"doc": "Users of the system need to provide a proper default in default.vrsettings in the resources/settings/ directory of either the runtime or the driver_xxx directory. Otherwise the default will be false, 0, 0.0 or \"\"",
			"methodname": "GetBool",
			"returntype": "bool",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "GetInt32",
			"returntype": "int32_t",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "GetFloat",
			"returntype": "float",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "GetString",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchValue",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unValueLen",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "RemoveSection",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRSettings",
			"methodname": "RemoveKeyInSection",
			"returntype": "void",
			"params": [
				{
					"paramname": "pchSection",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSettingsKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "peError",
					"paramtype": "vr::EVRSettingsError *"
				}
			]
		},
		{
			"classname": "vr::IVRScreenshots",
			"doc": "Request a screenshot of the requested type. A request of the VRScreenshotType_Stereo type will always work. Other types will depend on the underlying application support.\n The first file name is for the preview image and should be a regular screenshot (ideally from the left eye). The second is the VR screenshot in the correct format. They should be in the same aspect ratio.  Formats per type: VRScreenshotType_Mono: the VR filename is ignored (can be nullptr), this is a normal flat single shot. VRScreenshotType_Stereo:  The VR image should be a side-by-side with the left eye image on the left. VRScreenshotType_Cubemap: The VR image should be six square images composited horizontally.\n VRScreenshotType_StereoPanorama: above/below with left eye panorama being the above image.  Image is typically square with the panorama being 2x horizontal.\n  Note that the VR dashboard will call this function when the user presses the screenshot binding (currently System Button + Trigger).  If Steam is running, the destination file names will be in %TEMP% and will be copied into Steam's screenshot library for the running application once SubmitScreenshot() is called.\n If Steam is not running, the paths will be in the user's documents folder under DocumentsSteamVRScreenshots. Other VR applications can call this to initiate a screenshot outside of user control.\n The destination file names do not need an extension, will be replaced with the correct one for the format which is currently .png.",
			"methodname": "RequestScreenshot",
			"returntype": "vr::EVRScreenshotError",
			"params": [
				{
					"paramname": "pOutScreenshotHandle",
					"paramtype": "vr::ScreenshotHandle_t *"
				},
				{
					"paramname": "type",
					"paramtype": "vr::EVRScreenshotType"
				},
				{
					"paramname": "pchPreviewFilename",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchVRFilename",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRScreenshots",
			"doc": "Called by the running VR application to indicate that it wishes to be in charge of screenshots.  If the application does not call this, the Compositor will only support VRScreenshotType_Stereo screenshots that will be captured without notification to the running app.\n Once hooked your application will receive a VREvent_RequestScreenshot event when the user presses the buttons to take a screenshot. */",
			"methodname": "HookScreenshot",
			"returntype": "vr::EVRScreenshotError",
			"params": [
				{
					"paramname": "pSupportedTypes",
					"array_count": "numTypes",
					"paramtype": "const vr::EVRScreenshotType *"
				},
				{
					"paramname": "numTypes",
					"paramtype": "int"
				}
			]
		},
		{
			"classname": "vr::IVRScreenshots",
			"doc": "When your application receives a VREvent_RequestScreenshot event, call these functions to get the details of the screenshot request. */",
			"methodname": "GetScreenshotPropertyType",
			"returntype": "vr::EVRScreenshotType",
			"params": [
				{
					"paramname": "screenshotHandle",
					"paramtype": "vr::ScreenshotHandle_t"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::EVRScreenshotError *"
				}
			]
		},
		{
			"classname": "vr::IVRScreenshots",
			"doc": "Get the filename for the preview or vr image (see vr::EScreenshotPropertyFilenames).  The return value is the size of the string.   */",
			"methodname": "GetScreenshotPropertyFilename",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "screenshotHandle",
					"paramtype": "vr::ScreenshotHandle_t"
				},
				{
					"paramname": "filenameType",
					"paramtype": "vr::EVRScreenshotPropertyFilenames"
				},
				{
					"paramname": "pchFilename",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "cchFilename",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pError",
					"paramtype": "vr::EVRScreenshotError *"
				}
			]
		},
		{
			"classname": "vr::IVRScreenshots",
			"doc": "Call this if the application is taking the screen shot will take more than a few ms processing. This will result in an overlay being presented that shows a completion bar. */",
			"methodname": "UpdateScreenshotProgress",
			"returntype": "vr::EVRScreenshotError",
			"params": [
				{
					"paramname": "screenshotHandle",
					"paramtype": "vr::ScreenshotHandle_t"
				},
				{
					"paramname": "flProgress",
					"paramtype": "float"
				}
			]
		},
		{
			"classname": "vr::IVRScreenshots",
			"doc": "Tells the compositor to take an internal screenshot of type VRScreenshotType_Stereo. It will take the current submitted scene textures of the running application and write them into the preview image and a side-by-side file for the VR image.\n This is similar to request screenshot, but doesn't ever talk to the application, just takes the shot and submits. */",
			"methodname": "TakeStereoScreenshot",
			"returntype": "vr::EVRScreenshotError",
			"params": [
				{
					"paramname": "pOutScreenshotHandle",
					"paramtype": "vr::ScreenshotHandle_t *"
				},
				{
					"paramname": "pchPreviewFilename",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchVRFilename",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRScreenshots",
			"doc": "Submit the completed screenshot.  If Steam is running this will call into the Steam client and upload the screenshot to the screenshots section of the library for the running application.  If Steam is not running, this function will display a notification to the user that the screenshot was taken. The paths should be full paths with extensions.\n File paths should be absolute including extensions. screenshotHandle can be k_unScreenshotHandleInvalid if this was a new shot taking by the app to be saved and not initiated by a user (achievement earned or something) */",
			"methodname": "SubmitScreenshot",
			"returntype": "vr::EVRScreenshotError",
			"params": [
				{
					"paramname": "screenshotHandle",
					"paramtype": "vr::ScreenshotHandle_t"
				},
				{
					"paramname": "type",
					"paramtype": "vr::EVRScreenshotType"
				},
				{
					"paramname": "pchSourcePreviewFilename",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchSourceVRFilename",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRResources",
			"doc": "Loads the specified resource into the provided buffer if large enough.\nReturns the size in bytes of the buffer required to hold the specified resource.",
			"methodname": "LoadSharedResource",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchResourceName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchBuffer",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRResources",
			"doc": "Provides the full path to the specified resource. Resource names can include named directories for drivers and other things, and this resolves all of those and returns the actual physical path.\npchResourceTypeDirectory is the subdirectory of resources to look in.",
			"methodname": "GetResourceFullPath",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "pchResourceName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchResourceTypeDirectory",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchPathBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferLen",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRDriverManager",
			"methodname": "GetDriverCount",
			"returntype": "uint32_t"
		},
		{
			"classname": "vr::IVRDriverManager",
			"doc": "Returns the length of the number of bytes necessary to hold this string including the trailing null.",
			"methodname": "GetDriverName",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "nDriver",
					"paramtype": "vr::DriverId_t"
				},
				{
					"paramname": "pchValue",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unBufferSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRDriverManager",
			"methodname": "GetDriverHandle",
			"returntype": "DriverHandle_t",
			"params": [
				{
					"paramname": "pchDriverName",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRDriverManager",
			"methodname": "IsEnabled",
			"returntype": "bool",
			"params": [
				{
					"paramname": "nDriver",
					"paramtype": "vr::DriverId_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Sets the path to the action manifest JSON file that is used by this application. If this information was set on the Steam partner site, calls to this function are ignored. If the Steam partner site setting and the path provided by this call are different, VRInputError_MismatchedActionManifest is returned.  This call must be made before the first call to UpdateActionState or IVRSystem::PollNextEvent.",
			"methodname": "SetActionManifestPath",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pchActionManifestPath",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Returns a handle for an action set. This handle is used for all performance-sensitive calls.",
			"methodname": "GetActionSetHandle",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pchActionSetName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pHandle",
					"paramtype": "vr::VRActionSetHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Returns a handle for an action. This handle is used for all performance-sensitive calls.",
			"methodname": "GetActionHandle",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pchActionName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pHandle",
					"paramtype": "vr::VRActionHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Returns a handle for any path in the input system. E.g. /user/hand/right",
			"methodname": "GetInputSourceHandle",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pchInputSourcePath",
					"paramtype": "const char *"
				},
				{
					"paramname": "pHandle",
					"paramtype": "vr::VRInputValueHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the current state into all actions. After this call, the results of Get*Action calls  will be the same until the next call to UpdateActionState.",
			"methodname": "UpdateActionState",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pSets",
					"array_count": "unSetCount",
					"paramtype": "struct vr::VRActiveActionSet_t *"
				},
				{
					"paramname": "unSizeOfVRSelectedActionSet_t",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unSetCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the state of a digital action given its handle. This will return VRInputError_WrongType if the type of action is something other than digital",
			"methodname": "GetDigitalActionData",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "pActionData",
					"paramtype": "struct vr::InputDigitalActionData_t *"
				},
				{
					"paramname": "unActionDataSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "ulRestrictToDevice",
					"paramtype": "vr::VRInputValueHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the state of an analog action given its handle. This will return VRInputError_WrongType if the type of action is something other than analog",
			"methodname": "GetAnalogActionData",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "pActionData",
					"paramtype": "struct vr::InputAnalogActionData_t *"
				},
				{
					"paramname": "unActionDataSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "ulRestrictToDevice",
					"paramtype": "vr::VRInputValueHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the state of a pose action given its handle for the number of seconds relative to now. This will generally be called with negative times from the fUpdateTime fields in other actions.",
			"methodname": "GetPoseActionDataRelativeToNow",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "fPredictedSecondsFromNow",
					"paramtype": "float"
				},
				{
					"paramname": "pActionData",
					"paramtype": "struct vr::InputPoseActionData_t *"
				},
				{
					"paramname": "unActionDataSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "ulRestrictToDevice",
					"paramtype": "vr::VRInputValueHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the state of a pose action given its handle. The returned values will match the values returned by the last call to IVRCompositor::WaitGetPoses().",
			"methodname": "GetPoseActionDataForNextFrame",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "pActionData",
					"paramtype": "struct vr::InputPoseActionData_t *"
				},
				{
					"paramname": "unActionDataSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "ulRestrictToDevice",
					"paramtype": "vr::VRInputValueHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the state of a skeletal action given its handle.",
			"methodname": "GetSkeletalActionData",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "pActionData",
					"paramtype": "struct vr::InputSkeletalActionData_t *"
				},
				{
					"paramname": "unActionDataSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Returns the current dominant hand for the user for this application. This function will only return success for applications which include \"supports_dominant_hand_setting\": true in their action manifests. The dominant hand will only change after a call to UpdateActionState, and the action data returned after that point will use the new dominant hand.",
			"methodname": "GetDominantHand",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "peDominantHand",
					"paramtype": "vr::ETrackedControllerRole *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Sets the dominant hand for the user for this application.",
			"methodname": "SetDominantHand",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "eDominantHand",
					"paramtype": "vr::ETrackedControllerRole"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the number of bones in skeleton associated with the given action",
			"methodname": "GetBoneCount",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "pBoneCount",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Fills the given array with the index of each bone's parent in the skeleton associated with the given action",
			"methodname": "GetBoneHierarchy",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "pParentIndices",
					"array_count": "unIndexArayCount",
					"paramtype": "vr::BoneIndex_t *"
				},
				{
					"paramname": "unIndexArayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Fills the given buffer with the name of the bone at the given index in the skeleton associated with the given action",
			"methodname": "GetBoneName",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "nBoneIndex",
					"paramtype": "vr::BoneIndex_t"
				},
				{
					"paramname": "pchBoneName",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unNameBufferSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Fills the given buffer with the transforms for a specific static skeletal reference pose",
			"methodname": "GetSkeletalReferenceTransforms",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "eTransformSpace",
					"paramtype": "vr::EVRSkeletalTransformSpace"
				},
				{
					"paramname": "eReferencePose",
					"paramtype": "vr::EVRSkeletalReferencePose"
				},
				{
					"paramname": "pTransformArray",
					"array_count": "unTransformArrayCount",
					"paramtype": "struct vr::VRBoneTransform_t *"
				},
				{
					"paramname": "unTransformArrayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the level of accuracy to which the controller is able to track the user to recreate a skeletal pose",
			"methodname": "GetSkeletalTrackingLevel",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "pSkeletalTrackingLevel",
					"paramtype": "vr::EVRSkeletalTrackingLevel *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the state of the skeletal bone data associated with this action and copies it into the given buffer.",
			"methodname": "GetSkeletalBoneData",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "eTransformSpace",
					"paramtype": "vr::EVRSkeletalTransformSpace"
				},
				{
					"paramname": "eMotionRange",
					"paramtype": "vr::EVRSkeletalMotionRange"
				},
				{
					"paramname": "pTransformArray",
					"array_count": "unTransformArrayCount",
					"paramtype": "struct vr::VRBoneTransform_t *"
				},
				{
					"paramname": "unTransformArrayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads summary information about the current pose of the skeleton associated with the given action.  ",
			"methodname": "GetSkeletalSummaryData",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "eSummaryType",
					"paramtype": "vr::EVRSummaryType"
				},
				{
					"paramname": "pSkeletalSummaryData",
					"paramtype": "struct vr::VRSkeletalSummaryData_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Reads the state of the skeletal bone data in a compressed form that is suitable for sending over the network. The required buffer size will never exceed ( sizeof(VR_BoneTransform_t)*boneCount + 2). Usually the size will be much smaller.",
			"methodname": "GetSkeletalBoneDataCompressed",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "eMotionRange",
					"paramtype": "vr::EVRSkeletalMotionRange"
				},
				{
					"paramname": "pvCompressedData",
					"out_buffer_count": "unCompressedSize",
					"paramtype": "void *"
				},
				{
					"paramname": "unCompressedSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "punRequiredCompressedSize",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Turns a compressed buffer from GetSkeletalBoneDataCompressed and turns it back into a bone transform array.",
			"methodname": "DecompressSkeletalBoneData",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pvCompressedBuffer",
					"paramtype": "const void *"
				},
				{
					"paramname": "unCompressedBufferSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "eTransformSpace",
					"paramtype": "vr::EVRSkeletalTransformSpace"
				},
				{
					"paramname": "pTransformArray",
					"array_count": "unTransformArrayCount",
					"paramtype": "struct vr::VRBoneTransform_t *"
				},
				{
					"paramname": "unTransformArrayCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Triggers a haptic event as described by the specified action",
			"methodname": "TriggerHapticVibrationAction",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "fStartSecondsFromNow",
					"paramtype": "float"
				},
				{
					"paramname": "fDurationSeconds",
					"paramtype": "float"
				},
				{
					"paramname": "fFrequency",
					"paramtype": "float"
				},
				{
					"paramname": "fAmplitude",
					"paramtype": "float"
				},
				{
					"paramname": "ulRestrictToDevice",
					"paramtype": "vr::VRInputValueHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Retrieve origin handles for an action",
			"methodname": "GetActionOrigins",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "actionSetHandle",
					"paramtype": "vr::VRActionSetHandle_t"
				},
				{
					"paramname": "digitalActionHandle",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "originsOut",
					"array_count": "originOutCount",
					"paramtype": "vr::VRInputValueHandle_t *"
				},
				{
					"paramname": "originOutCount",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Retrieves the name of the origin in the current language. unStringSectionsToInclude is a bitfield of values in EVRInputStringBits that allows the application to specify which parts of the origin's information it wants a string for.",
			"methodname": "GetOriginLocalizedName",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "origin",
					"paramtype": "vr::VRInputValueHandle_t"
				},
				{
					"paramname": "pchNameArray",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unNameArraySize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unStringSectionsToInclude",
					"paramtype": "int32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Retrieves useful information for the origin of this action",
			"methodname": "GetOriginTrackedDeviceInfo",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "origin",
					"paramtype": "vr::VRInputValueHandle_t"
				},
				{
					"paramname": "pOriginInfo",
					"paramtype": "struct vr::InputOriginInfo_t *"
				},
				{
					"paramname": "unOriginInfoSize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Retrieves useful information about the bindings for an action",
			"methodname": "GetActionBindingInfo",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "action",
					"paramtype": "vr::VRActionHandle_t"
				},
				{
					"paramname": "pOriginInfo",
					"paramtype": "struct vr::InputBindingInfo_t *"
				},
				{
					"paramname": "unBindingInfoSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unBindingInfoCount",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "punReturnedBindingInfoCount",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Shows the current binding for the action in-headset",
			"methodname": "ShowActionOrigins",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "actionSetHandle",
					"paramtype": "vr::VRActionSetHandle_t"
				},
				{
					"paramname": "ulActionHandle",
					"paramtype": "vr::VRActionHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Shows the current binding all the actions in the specified action sets",
			"methodname": "ShowBindingsForActionSet",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pSets",
					"array_count": "unSetCount",
					"paramtype": "struct vr::VRActiveActionSet_t *"
				},
				{
					"paramname": "unSizeOfVRSelectedActionSet_t",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unSetCount",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "originToHighlight",
					"paramtype": "vr::VRInputValueHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Use this to query what action on the component returned by GetOriginTrackedDeviceInfo would trigger this binding.",
			"methodname": "GetComponentStateForBinding",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pchRenderModelName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchComponentName",
					"paramtype": "const char *"
				},
				{
					"paramname": "pOriginInfo",
					"paramtype": "const struct vr::InputBindingInfo_t *"
				},
				{
					"paramname": "unBindingInfoSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unBindingInfoCount",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pComponentState",
					"paramtype": "vr::RenderModel_ComponentState_t *"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Legacy Input",
			"methodname": "IsUsingLegacyInput",
			"returntype": "bool"
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Opens the binding user interface. If no app key is provided it will use the key from the calling process. If no set is provided it will open to the root of the app binding page.",
			"methodname": "OpenBindingUI",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "pchAppKey",
					"paramtype": "const char *"
				},
				{
					"paramname": "ulActionSetHandle",
					"paramtype": "vr::VRActionSetHandle_t"
				},
				{
					"paramname": "ulDeviceHandle",
					"paramtype": "vr::VRInputValueHandle_t"
				},
				{
					"paramname": "bShowOnDesktop",
					"paramtype": "bool"
				}
			]
		},
		{
			"classname": "vr::IVRInput",
			"doc": "Returns the variant set in the current bindings. If the binding doesn't include a variant setting, this function  will return an empty string",
			"methodname": "GetBindingVariant",
			"returntype": "vr::EVRInputError",
			"params": [
				{
					"paramname": "ulDevicePath",
					"paramtype": "vr::VRInputValueHandle_t"
				},
				{
					"paramname": "pchVariantArray",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unVariantArraySize",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRIOBuffer",
			"doc": "opens an existing or creates a new IOBuffer of unSize bytes",
			"methodname": "Open",
			"returntype": "vr::EIOBufferError",
			"params": [
				{
					"paramname": "pchPath",
					"paramtype": "const char *"
				},
				{
					"paramname": "mode",
					"paramtype": "vr::EIOBufferMode"
				},
				{
					"paramname": "unElementSize",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "unElements",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "pulBuffer",
					"paramtype": "vr::IOBufferHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRIOBuffer",
			"doc": "closes a previously opened or created buffer",
			"methodname": "Close",
			"returntype": "vr::EIOBufferError",
			"params": [
				{
					"paramname": "ulBuffer",
					"paramtype": "vr::IOBufferHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRIOBuffer",
			"doc": "reads up to unBytes from buffer into *pDst, returning number of bytes read in *punRead",
			"methodname": "Read",
			"returntype": "vr::EIOBufferError",
			"params": [
				{
					"paramname": "ulBuffer",
					"paramtype": "vr::IOBufferHandle_t"
				},
				{
					"paramname": "pDst",
					"paramtype": "void *"
				},
				{
					"paramname": "unBytes",
					"paramtype": "uint32_t"
				},
				{
					"paramname": "punRead",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRIOBuffer",
			"doc": "writes unBytes of data from *pSrc into a buffer.",
			"methodname": "Write",
			"returntype": "vr::EIOBufferError",
			"params": [
				{
					"paramname": "ulBuffer",
					"paramtype": "vr::IOBufferHandle_t"
				},
				{
					"paramname": "pSrc",
					"paramtype": "void *"
				},
				{
					"paramname": "unBytes",
					"paramtype": "uint32_t"
				}
			]
		},
		{
			"classname": "vr::IVRIOBuffer",
			"doc": "retrieves the property container of an buffer.",
			"methodname": "PropertyContainer",
			"returntype": "vr::PropertyContainerHandle_t",
			"params": [
				{
					"paramname": "ulBuffer",
					"paramtype": "vr::IOBufferHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRIOBuffer",
			"doc": "inexpensively checks for readers to allow writers to fast-fail potentially expensive copies and writes.",
			"methodname": "HasReaders",
			"returntype": "bool",
			"params": [
				{
					"paramname": "ulBuffer",
					"paramtype": "vr::IOBufferHandle_t"
				}
			]
		},
		{
			"classname": "vr::IVRSpatialAnchors",
			"doc": "Returns a handle for an spatial anchor described by \"descriptor\".  On success, pHandle will contain a handle valid for this session.  Caller can wait for an event or occasionally poll GetSpatialAnchorPose() to find the virtual coordinate associated with this anchor.",
			"methodname": "CreateSpatialAnchorFromDescriptor",
			"returntype": "vr::EVRSpatialAnchorError",
			"params": [
				{
					"paramname": "pchDescriptor",
					"paramtype": "const char *"
				},
				{
					"paramname": "pHandleOut",
					"paramtype": "vr::SpatialAnchorHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSpatialAnchors",
			"doc": "Returns a handle for an new spatial anchor at pPose.  On success, pHandle will contain a handle valid for this session.  Caller can wait for an event or occasionally poll GetSpatialAnchorDescriptor() to find the permanent descriptor for this pose. The result of GetSpatialAnchorPose() may evolve from this initial position if the driver chooses to update it.\n The anchor will be associated with the driver that provides unDeviceIndex, and the driver may use that specific device as a hint for how to best create the anchor.\n The eOrigin must match whatever tracking origin you are working in (seated/standing/raw). This should be called when the user is close to (and ideally looking at/interacting with) the target physical location.  At that moment, the driver will have the most information about how to recover that physical point in the future, and the quality of the anchor (when the descriptor is re-used) will be highest. The caller may decide to apply offsets from this initial pose, but is advised to stay relatively close to the  original pose location for highest fidelity.",
			"methodname": "CreateSpatialAnchorFromPose",
			"returntype": "vr::EVRSpatialAnchorError",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "pPose",
					"paramtype": "struct vr::SpatialAnchorPose_t *"
				},
				{
					"paramname": "pHandleOut",
					"paramtype": "vr::SpatialAnchorHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSpatialAnchors",
			"doc": "Get the pose for a given handle.  This is intended to be cheap enough to call every frame (or fairly often) so that the driver can refine this position when it has more information available.",
			"methodname": "GetSpatialAnchorPose",
			"returntype": "vr::EVRSpatialAnchorError",
			"params": [
				{
					"paramname": "unHandle",
					"paramtype": "vr::SpatialAnchorHandle_t"
				},
				{
					"paramname": "eOrigin",
					"paramtype": "vr::ETrackingUniverseOrigin"
				},
				{
					"paramname": "pPoseOut",
					"paramtype": "struct vr::SpatialAnchorPose_t *"
				}
			]
		},
		{
			"classname": "vr::IVRSpatialAnchors",
			"doc": "Get the descriptor for a given handle.  This will be empty for handles where the driver has not yet built a descriptor.  It will be the application-supplied descriptor for previously saved anchors that the application is requesting poses for.  If the driver has called UpdateSpatialAnchorDescriptor() already in this session, it will be the descriptor provided by the driver.\n Returns true if the descriptor fits into the buffer, else false.  Buffer size should be at least k_unMaxSpatialAnchorDescriptorSize.",
			"methodname": "GetSpatialAnchorDescriptor",
			"returntype": "vr::EVRSpatialAnchorError",
			"params": [
				{
					"paramname": "unHandle",
					"paramtype": "vr::SpatialAnchorHandle_t"
				},
				{
					"paramname": "pchDescriptorOut",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "punDescriptorBufferLenInOut",
					"paramtype": "uint32_t *"
				}
			]
		},
		{
			"classname": "vr::IVRDebug",
			"doc": "Create a vr profiler discrete event (point) \nThe event will be associated with the message provided in pchMessage, and the current time will be used as the event timestamp.",
			"methodname": "EmitVrProfilerEvent",
			"returntype": "vr::EVRDebugError",
			"params": [
				{
					"paramname": "pchMessage",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRDebug",
			"doc": "Create an vr profiler duration event (line) \nThe current time will be used as the timestamp for the start of the line. On success, pHandleOut will contain a handle valid for terminating this event.",
			"methodname": "BeginVrProfilerEvent",
			"returntype": "vr::EVRDebugError",
			"params": [
				{
					"paramname": "pHandleOut",
					"paramtype": "vr::VrProfilerEventHandle_t *"
				}
			]
		},
		{
			"classname": "vr::IVRDebug",
			"doc": "Terminate a vr profiler event \nThe event associated with hHandle will be considered completed when this method is called. The current time will be used assocaited to the termination time of the event, and pchMessage will be used as the event title.",
			"methodname": "FinishVrProfilerEvent",
			"returntype": "vr::EVRDebugError",
			"params": [
				{
					"paramname": "hHandle",
					"paramtype": "vr::VrProfilerEventHandle_t"
				},
				{
					"paramname": "pchMessage",
					"paramtype": "const char *"
				}
			]
		},
		{
			"classname": "vr::IVRDebug",
			"doc": "Sends a request to the driver for the specified device and returns the response. The maximum response size is 32k, but this method can be called with a smaller buffer. If the response exceeds the size of the buffer, it is truncated. The size of the response including its terminating null is returned.",
			"methodname": "DriverDebugRequest",
			"returntype": "uint32_t",
			"params": [
				{
					"paramname": "unDeviceIndex",
					"paramtype": "vr::TrackedDeviceIndex_t"
				},
				{
					"paramname": "pchRequest",
					"paramtype": "const char *"
				},
				{
					"paramname": "pchResponseBuffer",
					"out_string": " ",
					"paramtype": "char *"
				},
				{
					"paramname": "unResponseBufferSize",
					"paramtype": "uint32_t"
				}
			]
		}
	]
}